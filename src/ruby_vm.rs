/* automatically generated by rust-bindgen */

pub type VALUE = ::std::os::raw::c_ulong;
pub type ID = ::std::os::raw::c_ulong;
pub type ruby_check_sizeof_int = [::std::os::raw::c_char; 1usize];
pub type ruby_check_sizeof_long = [::std::os::raw::c_char; 1usize];
pub type ruby_check_sizeof_long_long = [::std::os::raw::c_char; 1usize];
pub type ruby_check_sizeof_voidp = [::std::os::raw::c_char; 1usize];
pub const RUBY_SPECIAL_SHIFT: Enum_ruby_special_consts =
    Enum_ruby_special_consts::RUBY_Qnil;
#[derive(Clone, Copy)]
#[repr(u32)]
pub enum Enum_ruby_special_consts {
    RUBY_Qfalse = 0,
    RUBY_Qtrue = 20,
    RUBY_Qnil = 8,
    RUBY_Qundef = 52,
    RUBY_IMMEDIATE_MASK = 7,
    RUBY_FIXNUM_FLAG = 1,
    RUBY_FLONUM_MASK = 3,
    RUBY_FLONUM_FLAG = 2,
    RUBY_SYMBOL_FLAG = 12,
}
#[derive(Clone, Copy)]
#[repr(u32)]
pub enum Enum_ruby_value_type {
    RUBY_T_NONE = 0,
    RUBY_T_OBJECT = 1,
    RUBY_T_CLASS = 2,
    RUBY_T_MODULE = 3,
    RUBY_T_FLOAT = 4,
    RUBY_T_STRING = 5,
    RUBY_T_REGEXP = 6,
    RUBY_T_ARRAY = 7,
    RUBY_T_HASH = 8,
    RUBY_T_STRUCT = 9,
    RUBY_T_BIGNUM = 10,
    RUBY_T_FILE = 11,
    RUBY_T_DATA = 12,
    RUBY_T_MATCH = 13,
    RUBY_T_COMPLEX = 14,
    RUBY_T_RATIONAL = 15,
    RUBY_T_NIL = 17,
    RUBY_T_TRUE = 18,
    RUBY_T_FALSE = 19,
    RUBY_T_SYMBOL = 20,
    RUBY_T_FIXNUM = 21,
    RUBY_T_UNDEF = 27,
    RUBY_T_NODE = 28,
    RUBY_T_ICLASS = 29,
    RUBY_T_ZOMBIE = 30,
    RUBY_T_MASK = 31,
}
#[repr(C)]
#[derive(Copy)]
pub struct Struct_RBasic {
    pub flags: VALUE,
    pub klass: VALUE,
}
impl ::std::clone::Clone for Struct_RBasic {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_RBasic {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub struct Struct_RObject {
    pub basic: Struct_RBasic,
    pub _as: Union_Unnamed1,
}
impl ::std::clone::Clone for Struct_RObject {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_RObject {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub struct Union_Unnamed1 {
    pub _bindgen_data_: [u64; 3usize],
}
impl Union_Unnamed1 {
    pub unsafe fn heap(&mut self) -> *mut Struct_Unnamed2 {
        let raw: *mut u8 = ::std::mem::transmute(&self._bindgen_data_);
        ::std::mem::transmute(raw.offset(0))
    }
    pub unsafe fn ary(&mut self) -> *mut [VALUE; 3usize] {
        let raw: *mut u8 = ::std::mem::transmute(&self._bindgen_data_);
        ::std::mem::transmute(raw.offset(0))
    }
}
impl ::std::clone::Clone for Union_Unnamed1 {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Union_Unnamed1 {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub struct Struct_Unnamed2 {
    pub numiv: ::std::os::raw::c_long,
    pub ivptr: *mut VALUE,
    pub iv_index_tbl: *mut Struct_st_table,
}
impl ::std::clone::Clone for Struct_Unnamed2 {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_Unnamed2 {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type rb_classext_t = Struct_rb_classext_struct;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_RClass {
    pub basic: Struct_RBasic,
    pub _super: VALUE,
    pub ptr: *mut rb_classext_t,
    pub m_tbl_wrapper: *mut Struct_method_table_wrapper,
}
impl ::std::clone::Clone for Struct_RClass {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_RClass {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub struct Struct_RFloat {
    pub basic: Struct_RBasic,
    pub float_value: ::std::os::raw::c_double,
}
impl ::std::clone::Clone for Struct_RFloat {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_RFloat {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub struct Struct_RString {
    pub basic: Struct_RBasic,
    pub _as: Union_Unnamed3,
}
impl ::std::clone::Clone for Struct_RString {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_RString {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub struct Union_Unnamed3 {
    pub _bindgen_data_: [u64; 3usize],
}
impl Union_Unnamed3 {
    pub unsafe fn heap(&mut self) -> *mut Struct_Unnamed4 {
        let raw: *mut u8 = ::std::mem::transmute(&self._bindgen_data_);
        ::std::mem::transmute(raw.offset(0))
    }
    pub unsafe fn ary(&mut self) -> *mut [::std::os::raw::c_char; 24usize] {
        let raw: *mut u8 = ::std::mem::transmute(&self._bindgen_data_);
        ::std::mem::transmute(raw.offset(0))
    }
}
impl ::std::clone::Clone for Union_Unnamed3 {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Union_Unnamed3 {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub struct Struct_Unnamed4 {
    pub len: ::std::os::raw::c_long,
    pub ptr: *mut ::std::os::raw::c_char,
    pub aux: Union_Unnamed5,
}
impl ::std::clone::Clone for Struct_Unnamed4 {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_Unnamed4 {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub struct Union_Unnamed5 {
    pub _bindgen_data_: [u64; 1usize],
}
impl Union_Unnamed5 {
    pub unsafe fn capa(&mut self) -> *mut ::std::os::raw::c_long {
        let raw: *mut u8 = ::std::mem::transmute(&self._bindgen_data_);
        ::std::mem::transmute(raw.offset(0))
    }
    pub unsafe fn shared(&mut self) -> *mut VALUE {
        let raw: *mut u8 = ::std::mem::transmute(&self._bindgen_data_);
        ::std::mem::transmute(raw.offset(0))
    }
}
impl ::std::clone::Clone for Union_Unnamed5 {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Union_Unnamed5 {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub struct Struct_RArray {
    pub basic: Struct_RBasic,
    pub _as: Union_Unnamed6,
}
impl ::std::clone::Clone for Struct_RArray {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_RArray {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub struct Union_Unnamed6 {
    pub _bindgen_data_: [u64; 3usize],
}
impl Union_Unnamed6 {
    pub unsafe fn heap(&mut self) -> *mut Struct_Unnamed7 {
        let raw: *mut u8 = ::std::mem::transmute(&self._bindgen_data_);
        ::std::mem::transmute(raw.offset(0))
    }
    pub unsafe fn ary(&mut self) -> *mut [VALUE; 3usize] {
        let raw: *mut u8 = ::std::mem::transmute(&self._bindgen_data_);
        ::std::mem::transmute(raw.offset(0))
    }
}
impl ::std::clone::Clone for Union_Unnamed6 {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Union_Unnamed6 {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub struct Struct_Unnamed7 {
    pub len: ::std::os::raw::c_long,
    pub aux: Union_Unnamed8,
    pub ptr: *const VALUE,
}
impl ::std::clone::Clone for Struct_Unnamed7 {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_Unnamed7 {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub struct Union_Unnamed8 {
    pub _bindgen_data_: [u64; 1usize],
}
impl Union_Unnamed8 {
    pub unsafe fn capa(&mut self) -> *mut ::std::os::raw::c_long {
        let raw: *mut u8 = ::std::mem::transmute(&self._bindgen_data_);
        ::std::mem::transmute(raw.offset(0))
    }
    pub unsafe fn shared(&mut self) -> *mut VALUE {
        let raw: *mut u8 = ::std::mem::transmute(&self._bindgen_data_);
        ::std::mem::transmute(raw.offset(0))
    }
}
impl ::std::clone::Clone for Union_Unnamed8 {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Union_Unnamed8 {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub enum Struct_re_pattern_buffer { }
#[repr(C)]
#[derive(Copy)]
pub struct Struct_RRegexp {
    pub basic: Struct_RBasic,
    pub ptr: *mut Struct_re_pattern_buffer,
    pub src: VALUE,
    pub usecnt: ::std::os::raw::c_ulong,
}
impl ::std::clone::Clone for Struct_RRegexp {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_RRegexp {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub struct Struct_RHash {
    pub basic: Struct_RBasic,
    pub ntbl: *mut Struct_st_table,
    pub iter_lev: ::std::os::raw::c_int,
    pub ifnone: VALUE,
}
impl ::std::clone::Clone for Struct_RHash {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_RHash {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub enum Struct_rb_io_t { }
#[repr(C)]
#[derive(Copy)]
pub struct Struct_RFile {
    pub basic: Struct_RBasic,
    pub fptr: *mut Struct_rb_io_t,
}
impl ::std::clone::Clone for Struct_RFile {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_RFile {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub struct Struct_RRational {
    pub basic: Struct_RBasic,
    pub num: VALUE,
    pub den: VALUE,
}
impl ::std::clone::Clone for Struct_RRational {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_RRational {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub struct Struct_RComplex {
    pub basic: Struct_RBasic,
    pub real: VALUE,
    pub imag: VALUE,
}
impl ::std::clone::Clone for Struct_RComplex {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_RComplex {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub struct Struct_RData {
    pub basic: Struct_RBasic,
    pub dmark: ::std::option::Option<unsafe extern "C" fn(arg1:
                                                              *mut ::std::os::raw::c_void)>,
    pub dfree: ::std::option::Option<unsafe extern "C" fn(arg1:
                                                              *mut ::std::os::raw::c_void)>,
    pub data: *mut ::std::os::raw::c_void,
}
impl ::std::clone::Clone for Struct_RData {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_RData {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type rb_data_type_t = Struct_rb_data_type_struct;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_rb_data_type_struct {
    pub wrap_struct_name: *const ::std::os::raw::c_char,
    pub function: Struct_Unnamed9,
    pub parent: *const rb_data_type_t,
    pub data: *mut ::std::os::raw::c_void,
    pub flags: VALUE,
}
impl ::std::clone::Clone for Struct_rb_data_type_struct {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_rb_data_type_struct {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub struct Struct_Unnamed9 {
    pub dmark: ::std::option::Option<unsafe extern "C" fn(arg1:
                                                              *mut ::std::os::raw::c_void)>,
    pub dfree: ::std::option::Option<unsafe extern "C" fn(arg1:
                                                              *mut ::std::os::raw::c_void)>,
    pub dsize: ::std::option::Option<unsafe extern "C" fn(arg1:
                                                              *const ::std::os::raw::c_void)
                                         -> size_t>,
    pub reserved: [*mut ::std::os::raw::c_void; 2usize],
}
impl ::std::clone::Clone for Struct_Unnamed9 {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_Unnamed9 {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub struct Struct_RTypedData {
    pub basic: Struct_RBasic,
    pub _type: *const rb_data_type_t,
    pub typed_flag: VALUE,
    pub data: *mut ::std::os::raw::c_void,
}
impl ::std::clone::Clone for Struct_RTypedData {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_RTypedData {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type RUBY_DATA_FUNC =
    ::std::option::Option<unsafe extern "C" fn(arg1:
                                                   *mut ::std::os::raw::c_void)>;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_RStruct {
    pub basic: Struct_RBasic,
    pub _as: Union_Unnamed10,
}
impl ::std::clone::Clone for Struct_RStruct {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_RStruct {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub struct Union_Unnamed10 {
    pub _bindgen_data_: [u64; 3usize],
}
impl Union_Unnamed10 {
    pub unsafe fn heap(&mut self) -> *mut Struct_Unnamed11 {
        let raw: *mut u8 = ::std::mem::transmute(&self._bindgen_data_);
        ::std::mem::transmute(raw.offset(0))
    }
    pub unsafe fn ary(&mut self) -> *mut [VALUE; 3usize] {
        let raw: *mut u8 = ::std::mem::transmute(&self._bindgen_data_);
        ::std::mem::transmute(raw.offset(0))
    }
}
impl ::std::clone::Clone for Union_Unnamed10 {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Union_Unnamed10 {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub struct Struct_Unnamed11 {
    pub len: ::std::os::raw::c_long,
    pub ptr: *const VALUE,
}
impl ::std::clone::Clone for Struct_Unnamed11 {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_Unnamed11 {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub struct Struct_RBignum {
    pub basic: Struct_RBasic,
    pub _as: Union_Unnamed12,
}
impl ::std::clone::Clone for Struct_RBignum {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_RBignum {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub struct Union_Unnamed12 {
    pub _bindgen_data_: [u64; 3usize],
}
impl Union_Unnamed12 {
    pub unsafe fn heap(&mut self) -> *mut Struct_Unnamed13 {
        let raw: *mut u8 = ::std::mem::transmute(&self._bindgen_data_);
        ::std::mem::transmute(raw.offset(0))
    }
    pub unsafe fn ary(&mut self) -> *mut [::std::os::raw::c_uint; 6usize] {
        let raw: *mut u8 = ::std::mem::transmute(&self._bindgen_data_);
        ::std::mem::transmute(raw.offset(0))
    }
}
impl ::std::clone::Clone for Union_Unnamed12 {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Union_Unnamed12 {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub struct Struct_Unnamed13 {
    pub len: ::std::os::raw::c_long,
    pub digits: *mut ::std::os::raw::c_uint,
}
impl ::std::clone::Clone for Struct_Unnamed13 {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_Unnamed13 {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type ruby_glob_func =
    unsafe extern "C" fn(arg1: *const ::std::os::raw::c_char, arg2: VALUE,
                         arg3: *mut ::std::os::raw::c_void)
        -> ::std::os::raw::c_int;
pub enum Struct_rb_global_variable { }
pub type rb_gvar_getter_t =
    unsafe extern "C" fn(id: ID, data: *mut ::std::os::raw::c_void,
                         gvar: *mut Struct_rb_global_variable) -> VALUE;
pub type rb_gvar_setter_t =
    unsafe extern "C" fn(val: VALUE, id: ID,
                         data: *mut ::std::os::raw::c_void,
                         gvar: *mut Struct_rb_global_variable);
pub type rb_gvar_marker_t = unsafe extern "C" fn(var: *mut VALUE);
pub type rb_block_call_func =
    unsafe extern "C" fn(yielded_arg: VALUE, callback_arg: VALUE,
                         argc: ::std::os::raw::c_int, argv: *const VALUE,
                         blockarg: VALUE) -> VALUE;
pub type rb_block_call_func_t =
    ::std::option::Option<extern "C" fn() -> VALUE>;
pub type st_data_t = ::std::os::raw::c_ulong;
pub type st_table = Struct_st_table;
pub type st_index_t = st_data_t;
pub type st_compare_func =
    extern "C" fn(arg1: st_data_t, arg2: st_data_t) -> ::std::os::raw::c_int;
pub type st_hash_func = extern "C" fn(arg1: st_data_t) -> st_index_t;
pub type st_check_for_sizeof_st_index_t = [::std::os::raw::c_char; 1usize];
#[repr(C)]
#[derive(Copy)]
pub struct Struct_st_hash_type {
    pub compare: ::std::option::Option<extern "C" fn()
                                           -> ::std::os::raw::c_int>,
    pub hash: ::std::option::Option<extern "C" fn() -> st_index_t>,
}
impl ::std::clone::Clone for Struct_st_hash_type {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_st_hash_type {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub enum Struct_st_table_entry { }
pub enum Struct_st_packed_entry { }
#[repr(C)]
#[derive(Copy)]
pub struct Struct_st_table {
    pub _type: *const Struct_st_hash_type,
    pub num_bins: st_index_t,
    pub _bindgen_bitfield_1_: ::std::os::raw::c_uint,
    pub _bindgen_bitfield_2_: st_index_t,
    pub _as: Union_Unnamed14,
}
impl ::std::clone::Clone for Struct_st_table {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_st_table {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub struct Union_Unnamed14 {
    pub _bindgen_data_: [u64; 3usize],
}
impl Union_Unnamed14 {
    pub unsafe fn big(&mut self) -> *mut Struct_Unnamed15 {
        let raw: *mut u8 = ::std::mem::transmute(&self._bindgen_data_);
        ::std::mem::transmute(raw.offset(0))
    }
    pub unsafe fn packed(&mut self) -> *mut Struct_Unnamed16 {
        let raw: *mut u8 = ::std::mem::transmute(&self._bindgen_data_);
        ::std::mem::transmute(raw.offset(0))
    }
}
impl ::std::clone::Clone for Union_Unnamed14 {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Union_Unnamed14 {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub struct Struct_Unnamed15 {
    pub bins: *mut *mut Struct_st_table_entry,
    pub head: *mut Struct_st_table_entry,
    pub tail: *mut Struct_st_table_entry,
}
impl ::std::clone::Clone for Struct_Unnamed15 {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_Unnamed15 {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub struct Struct_Unnamed16 {
    pub entries: *mut Struct_st_packed_entry,
    pub real_entries: st_index_t,
}
impl ::std::clone::Clone for Struct_Unnamed16 {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_Unnamed16 {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[derive(Clone, Copy)]
#[repr(u32)]
pub enum Enum_st_retval {
    ST_CONTINUE = 0,
    ST_STOP = 1,
    ST_DELETE = 2,
    ST_CHECK = 3,
}
pub type st_update_callback_func =
    unsafe extern "C" fn(key: *mut st_data_t, value: *mut st_data_t,
                         arg: st_data_t, existing: ::std::os::raw::c_int)
        -> ::std::os::raw::c_int;
pub type rb_enumerator_size_func =
    extern "C" fn(arg1: VALUE, arg2: VALUE, arg3: VALUE) -> VALUE;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_Unnamed17 {
    pub maxfd: ::std::os::raw::c_int,
    pub fdset: *mut fd_set,
}
impl ::std::clone::Clone for Struct_Unnamed17 {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_Unnamed17 {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type rb_fdset_t = Struct_Unnamed17;
pub type rb_alloc_func_t =
    ::std::option::Option<extern "C" fn(arg1: VALUE) -> VALUE>;
pub type rb_hash_update_func =
    extern "C" fn(newkey: VALUE, oldkey: VALUE, value: VALUE) -> VALUE;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_rb_exec_arg {
    pub execarg_obj: VALUE,
}
impl ::std::clone::Clone for Struct_rb_exec_arg {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_rb_exec_arg {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type rb_unblock_function_t =
    unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void);
pub type rb_blocking_function_t =
    unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void) -> VALUE;
pub type rb_event_flag_t = ::std::os::raw::c_ulong;
pub type rb_event_hook_func_t =
    ::std::option::Option<extern "C" fn(evflag: rb_event_flag_t, data: VALUE,
                                        _self: VALUE, mid: ID, klass: VALUE)>;
#[derive(Clone, Copy)]
#[repr(u32)]
pub enum Enum_node_type {
    NODE_SCOPE = 0,
    NODE_BLOCK = 1,
    NODE_IF = 2,
    NODE_CASE = 3,
    NODE_WHEN = 4,
    NODE_OPT_N = 5,
    NODE_WHILE = 6,
    NODE_UNTIL = 7,
    NODE_ITER = 8,
    NODE_FOR = 9,
    NODE_BREAK = 10,
    NODE_NEXT = 11,
    NODE_REDO = 12,
    NODE_RETRY = 13,
    NODE_BEGIN = 14,
    NODE_RESCUE = 15,
    NODE_RESBODY = 16,
    NODE_ENSURE = 17,
    NODE_AND = 18,
    NODE_OR = 19,
    NODE_MASGN = 20,
    NODE_LASGN = 21,
    NODE_DASGN = 22,
    NODE_DASGN_CURR = 23,
    NODE_GASGN = 24,
    NODE_IASGN = 25,
    NODE_IASGN2 = 26,
    NODE_CDECL = 27,
    NODE_CVASGN = 28,
    NODE_CVDECL = 29,
    NODE_OP_ASGN1 = 30,
    NODE_OP_ASGN2 = 31,
    NODE_OP_ASGN_AND = 32,
    NODE_OP_ASGN_OR = 33,
    NODE_OP_CDECL = 34,
    NODE_CALL = 35,
    NODE_FCALL = 36,
    NODE_VCALL = 37,
    NODE_SUPER = 38,
    NODE_ZSUPER = 39,
    NODE_ARRAY = 40,
    NODE_ZARRAY = 41,
    NODE_VALUES = 42,
    NODE_HASH = 43,
    NODE_RETURN = 44,
    NODE_YIELD = 45,
    NODE_LVAR = 46,
    NODE_DVAR = 47,
    NODE_GVAR = 48,
    NODE_IVAR = 49,
    NODE_CONST = 50,
    NODE_CVAR = 51,
    NODE_NTH_REF = 52,
    NODE_BACK_REF = 53,
    NODE_MATCH = 54,
    NODE_MATCH2 = 55,
    NODE_MATCH3 = 56,
    NODE_LIT = 57,
    NODE_STR = 58,
    NODE_DSTR = 59,
    NODE_XSTR = 60,
    NODE_DXSTR = 61,
    NODE_EVSTR = 62,
    NODE_DREGX = 63,
    NODE_DREGX_ONCE = 64,
    NODE_ARGS = 65,
    NODE_ARGS_AUX = 66,
    NODE_OPT_ARG = 67,
    NODE_KW_ARG = 68,
    NODE_POSTARG = 69,
    NODE_ARGSCAT = 70,
    NODE_ARGSPUSH = 71,
    NODE_SPLAT = 72,
    NODE_TO_ARY = 73,
    NODE_BLOCK_ARG = 74,
    NODE_BLOCK_PASS = 75,
    NODE_DEFN = 76,
    NODE_DEFS = 77,
    NODE_ALIAS = 78,
    NODE_VALIAS = 79,
    NODE_UNDEF = 80,
    NODE_CLASS = 81,
    NODE_MODULE = 82,
    NODE_SCLASS = 83,
    NODE_COLON2 = 84,
    NODE_COLON3 = 85,
    NODE_CREF = 86,
    NODE_DOT2 = 87,
    NODE_DOT3 = 88,
    NODE_FLIP2 = 89,
    NODE_FLIP3 = 90,
    NODE_SELF = 91,
    NODE_NIL = 92,
    NODE_TRUE = 93,
    NODE_FALSE = 94,
    NODE_ERRINFO = 95,
    NODE_DEFINED = 96,
    NODE_POSTEXE = 97,
    NODE_ALLOCA = 98,
    NODE_BMETHOD = 99,
    NODE_MEMO = 100,
    NODE_IFUNC = 101,
    NODE_DSYM = 102,
    NODE_ATTRASGN = 103,
    NODE_PRELUDE = 104,
    NODE_LAMBDA = 105,
    NODE_LAST = 106,
}
#[repr(C)]
#[derive(Copy)]
pub struct Struct_RNode {
    pub flags: VALUE,
    pub nd_reserved: VALUE,
    pub u1: Union_Unnamed18,
    pub u2: Union_Unnamed19,
    pub u3: Union_Unnamed20,
}
impl ::std::clone::Clone for Struct_RNode {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_RNode {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub struct Union_Unnamed18 {
    pub _bindgen_data_: [u64; 1usize],
}
impl Union_Unnamed18 {
    pub unsafe fn node(&mut self) -> *mut *mut Struct_RNode {
        let raw: *mut u8 = ::std::mem::transmute(&self._bindgen_data_);
        ::std::mem::transmute(raw.offset(0))
    }
    pub unsafe fn id(&mut self) -> *mut ID {
        let raw: *mut u8 = ::std::mem::transmute(&self._bindgen_data_);
        ::std::mem::transmute(raw.offset(0))
    }
    pub unsafe fn value(&mut self) -> *mut VALUE {
        let raw: *mut u8 = ::std::mem::transmute(&self._bindgen_data_);
        ::std::mem::transmute(raw.offset(0))
    }
    pub unsafe fn cfunc(&mut self)
     -> *mut ::std::option::Option<extern "C" fn() -> VALUE> {
        let raw: *mut u8 = ::std::mem::transmute(&self._bindgen_data_);
        ::std::mem::transmute(raw.offset(0))
    }
    pub unsafe fn tbl(&mut self) -> *mut *mut ID {
        let raw: *mut u8 = ::std::mem::transmute(&self._bindgen_data_);
        ::std::mem::transmute(raw.offset(0))
    }
}
impl ::std::clone::Clone for Union_Unnamed18 {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Union_Unnamed18 {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub struct Union_Unnamed19 {
    pub _bindgen_data_: [u64; 1usize],
}
impl Union_Unnamed19 {
    pub unsafe fn node(&mut self) -> *mut *mut Struct_RNode {
        let raw: *mut u8 = ::std::mem::transmute(&self._bindgen_data_);
        ::std::mem::transmute(raw.offset(0))
    }
    pub unsafe fn id(&mut self) -> *mut ID {
        let raw: *mut u8 = ::std::mem::transmute(&self._bindgen_data_);
        ::std::mem::transmute(raw.offset(0))
    }
    pub unsafe fn argc(&mut self) -> *mut ::std::os::raw::c_long {
        let raw: *mut u8 = ::std::mem::transmute(&self._bindgen_data_);
        ::std::mem::transmute(raw.offset(0))
    }
    pub unsafe fn value(&mut self) -> *mut VALUE {
        let raw: *mut u8 = ::std::mem::transmute(&self._bindgen_data_);
        ::std::mem::transmute(raw.offset(0))
    }
}
impl ::std::clone::Clone for Union_Unnamed19 {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Union_Unnamed19 {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub struct Union_Unnamed20 {
    pub _bindgen_data_: [u64; 1usize],
}
impl Union_Unnamed20 {
    pub unsafe fn node(&mut self) -> *mut *mut Struct_RNode {
        let raw: *mut u8 = ::std::mem::transmute(&self._bindgen_data_);
        ::std::mem::transmute(raw.offset(0))
    }
    pub unsafe fn id(&mut self) -> *mut ID {
        let raw: *mut u8 = ::std::mem::transmute(&self._bindgen_data_);
        ::std::mem::transmute(raw.offset(0))
    }
    pub unsafe fn state(&mut self) -> *mut ::std::os::raw::c_long {
        let raw: *mut u8 = ::std::mem::transmute(&self._bindgen_data_);
        ::std::mem::transmute(raw.offset(0))
    }
    pub unsafe fn entry(&mut self) -> *mut *mut Struct_rb_global_entry {
        let raw: *mut u8 = ::std::mem::transmute(&self._bindgen_data_);
        ::std::mem::transmute(raw.offset(0))
    }
    pub unsafe fn args(&mut self) -> *mut *mut Struct_rb_args_info {
        let raw: *mut u8 = ::std::mem::transmute(&self._bindgen_data_);
        ::std::mem::transmute(raw.offset(0))
    }
    pub unsafe fn cnt(&mut self) -> *mut ::std::os::raw::c_long {
        let raw: *mut u8 = ::std::mem::transmute(&self._bindgen_data_);
        ::std::mem::transmute(raw.offset(0))
    }
    pub unsafe fn value(&mut self) -> *mut VALUE {
        let raw: *mut u8 = ::std::mem::transmute(&self._bindgen_data_);
        ::std::mem::transmute(raw.offset(0))
    }
}
impl ::std::clone::Clone for Union_Unnamed20 {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Union_Unnamed20 {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type NODE = Struct_RNode;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_rb_global_entry {
    pub var: *mut Struct_rb_global_variable,
    pub id: ID,
}
impl ::std::clone::Clone for Struct_rb_global_entry {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_rb_global_entry {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub enum Struct_kwtable { }
#[repr(C)]
#[derive(Copy)]
pub struct Struct_rb_args_info {
    pub pre_init: *mut NODE,
    pub post_init: *mut NODE,
    pub pre_args_num: ::std::os::raw::c_int,
    pub post_args_num: ::std::os::raw::c_int,
    pub first_post_arg: ID,
    pub rest_arg: ID,
    pub block_arg: ID,
    pub kw_args: *mut NODE,
    pub kw_rest_arg: *mut NODE,
    pub opt_args: *mut NODE,
}
impl ::std::clone::Clone for Struct_rb_args_info {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_rb_args_info {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub enum Struct_parser_params { }
pub const RUBY_ID_INTERNAL: Enum_ruby_id_types =
    Enum_ruby_id_types::RUBY_ID_JUNK;
pub const RUBY_ID_SCOPE_SHIFT: Enum_ruby_id_types =
    Enum_ruby_id_types::RUBY_ID_GLOBAL;
pub const RUBY_ID_SCOPE_MASK: Enum_ruby_id_types =
    Enum_ruby_id_types::RUBY_ID_JUNK;
#[derive(Clone, Copy)]
#[repr(u32)]
pub enum Enum_ruby_id_types {
    RUBY_ID_LOCAL = 0,
    RUBY_ID_INSTANCE = 1,
    RUBY_ID_GLOBAL = 3,
    RUBY_ID_ATTRSET = 4,
    RUBY_ID_CONST = 5,
    RUBY_ID_CLASS = 6,
    RUBY_ID_JUNK = 7,
}
pub const tLAST_OP_ID: Enum_ruby_method_ids =
    Enum_ruby_method_ids::id_core_hash_merge_kwd;
#[derive(Clone, Copy)]
#[repr(u32)]
pub enum Enum_ruby_method_ids {
    idDot2 = 128,
    idDot3 = 129,
    idUPlus = 130,
    idUMinus = 131,
    idPow = 132,
    idCmp = 134,
    idPLUS = 43,
    idMINUS = 45,
    idMULT = 42,
    idDIV = 47,
    idMOD = 37,
    idLT = 60,
    idLTLT = 135,
    idLE = 137,
    idGT = 62,
    idGE = 138,
    idEq = 139,
    idEqq = 140,
    idNeq = 141,
    idNot = 33,
    idBackquote = 96,
    idEqTilde = 142,
    idNeqTilde = 143,
    idAREF = 144,
    idASET = 145,
    tPRESERVED_ID_BEGIN = 147,
    idNULL = 148,
    idEmptyP = 149,
    idEqlP = 150,
    idRespond_to = 151,
    idRespond_to_missing = 152,
    idIFUNC = 153,
    idCFUNC = 154,
    id_core_set_method_alias = 155,
    id_core_set_variable_alias = 156,
    id_core_undef_method = 157,
    id_core_define_method = 158,
    id_core_define_singleton_method = 159,
    id_core_set_postexe = 160,
    id_core_hash_from_ary = 161,
    id_core_hash_merge_ary = 162,
    id_core_hash_merge_ptr = 163,
    id_core_hash_merge_kwd = 164,
    tPRESERVED_ID_END = 165,
    tFreeze = 166,
    tInspect = 167,
    tIntern = 168,
    tObject_id = 169,
    tConst_missing = 170,
    tMethodMissing = 171,
    tMethod_added = 172,
    tSingleton_method_added = 173,
    tMethod_removed = 174,
    tSingleton_method_removed = 175,
    tMethod_undefined = 176,
    tSingleton_method_undefined = 177,
    tLength = 178,
    tSize = 179,
    tGets = 180,
    tSucc = 181,
    tEach = 182,
    tProc = 183,
    tLambda = 184,
    tSend = 185,
    t__send__ = 186,
    t__attached__ = 187,
    tInitialize = 188,
    tInitialize_copy = 189,
    tInitialize_clone = 190,
    tInitialize_dup = 191,
    tUScore = 192,
    idFreeze = 1328,
    idInspect = 1336,
    idIntern = 1344,
    idObject_id = 1352,
    idConst_missing = 1360,
    idMethodMissing = 1368,
    idMethod_added = 1376,
    idSingleton_method_added = 1384,
    idMethod_removed = 1392,
    idSingleton_method_removed = 1400,
    idMethod_undefined = 1408,
    idSingleton_method_undefined = 1416,
    idLength = 1424,
    idSize = 1432,
    idGets = 1440,
    idSucc = 1448,
    idEach = 1456,
    idProc = 1464,
    idLambda = 1472,
    idSend = 1480,
    id__send__ = 1488,
    id__attached__ = 1496,
    idInitialize = 1504,
    idInitialize_copy = 1512,
    idInitialize_clone = 1520,
    idInitialize_dup = 1528,
    idUScore = 1536,
    idLAST_OP_ID = 20,
}
#[repr(C)]
#[derive(Copy)]
pub struct Struct_rb_deprecated_classext_struct {
    pub conflict: [::std::os::raw::c_char; 24usize],
}
impl ::std::clone::Clone for Struct_rb_deprecated_classext_struct {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_rb_deprecated_classext_struct {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type rb_subclass_entry_t = Struct_rb_subclass_entry;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_rb_subclass_entry {
    pub klass: VALUE,
    pub next: *mut rb_subclass_entry_t,
}
impl ::std::clone::Clone for Struct_rb_subclass_entry {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_rb_subclass_entry {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type rb_serial_t = ::std::os::raw::c_ulonglong;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_rb_classext_struct {
    pub iv_index_tbl: *mut Struct_st_table,
    pub iv_tbl: *mut Struct_st_table,
    pub const_tbl: *mut Struct_st_table,
    pub subclasses: *mut rb_subclass_entry_t,
    pub parent_subclasses: *mut *mut rb_subclass_entry_t,
    pub module_subclasses: *mut *mut rb_subclass_entry_t,
    pub class_serial: rb_serial_t,
    pub origin: VALUE,
    pub refined_class: VALUE,
    pub allocator: rb_alloc_func_t,
}
impl ::std::clone::Clone for Struct_rb_classext_struct {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_rb_classext_struct {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub struct Struct_method_table_wrapper {
    pub tbl: *mut st_table,
    pub serial: size_t,
}
impl ::std::clone::Clone for Struct_method_table_wrapper {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_method_table_wrapper {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub enum Struct_vtm { }
#[repr(C)]
#[derive(Copy)]
pub struct Struct_RBasicRaw {
    pub flags: VALUE,
    pub klass: VALUE,
}
impl ::std::clone::Clone for Struct_RBasicRaw {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_RBasicRaw {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub struct Struct_rb_execarg {
    pub use_shell: ::std::os::raw::c_int,
    pub invoke: Union_Unnamed21,
    pub redirect_fds: VALUE,
    pub envp_str: VALUE,
    pub envp_buf: VALUE,
    pub dup2_tmpbuf: VALUE,
    pub _bindgen_bitfield_1_: ::std::os::raw::c_uint,
    pub pgroup_pgid: pid_t,
    pub rlimit_limits: VALUE,
    pub umask_mask: mode_t,
    pub uid: uid_t,
    pub gid: gid_t,
    pub fd_dup2: VALUE,
    pub fd_close: VALUE,
    pub fd_open: VALUE,
    pub fd_dup2_child: VALUE,
    pub close_others_maxhint: ::std::os::raw::c_int,
    pub env_modification: VALUE,
    pub chdir_dir: VALUE,
}
impl ::std::clone::Clone for Struct_rb_execarg {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_rb_execarg {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub struct Union_Unnamed21 {
    pub _bindgen_data_: [u64; 4usize],
}
impl Union_Unnamed21 {
    pub unsafe fn sh(&mut self) -> *mut Struct_Unnamed22 {
        let raw: *mut u8 = ::std::mem::transmute(&self._bindgen_data_);
        ::std::mem::transmute(raw.offset(0))
    }
    pub unsafe fn cmd(&mut self) -> *mut Struct_Unnamed23 {
        let raw: *mut u8 = ::std::mem::transmute(&self._bindgen_data_);
        ::std::mem::transmute(raw.offset(0))
    }
}
impl ::std::clone::Clone for Union_Unnamed21 {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Union_Unnamed21 {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub struct Struct_Unnamed22 {
    pub shell_script: VALUE,
}
impl ::std::clone::Clone for Struct_Unnamed22 {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_Unnamed22 {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub struct Struct_Unnamed23 {
    pub command_name: VALUE,
    pub command_abspath: VALUE,
    pub argv_str: VALUE,
    pub argv_buf: VALUE,
}
impl ::std::clone::Clone for Struct_Unnamed23 {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_Unnamed23 {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type rb_check_funcall_hook =
    unsafe extern "C" fn(arg1: ::std::os::raw::c_int, arg2: VALUE, arg3: ID,
                         arg4: ::std::os::raw::c_int, arg5: *const VALUE,
                         arg6: VALUE);
pub const NOEX_UNDEF: Enum_Unnamed24 = Enum_Unnamed24::NOEX_NOSUPER;
pub const NOEX_BIT_WIDTH: Enum_Unnamed24 = Enum_Unnamed24::NOEX_BASIC;
pub const NOEX_SAFE_SHIFT_OFFSET: Enum_Unnamed24 = Enum_Unnamed24::NOEX_BASIC;
#[derive(Clone, Copy)]
#[repr(u32)]
pub enum Enum_Unnamed24 {
    NOEX_PUBLIC = 0,
    NOEX_NOSUPER = 1,
    NOEX_PRIVATE = 2,
    NOEX_PROTECTED = 4,
    NOEX_MASK = 6,
    NOEX_BASIC = 8,
    NOEX_MODFUNC = 18,
    NOEX_SUPER = 32,
    NOEX_VCALL = 64,
    NOEX_RESPONDS = 128,
}
pub type rb_method_flag_t = Enum_Unnamed24;
#[derive(Clone, Copy)]
#[repr(u32)]
pub enum Enum_Unnamed25 {
    VM_METHOD_TYPE_ISEQ = 0,
    VM_METHOD_TYPE_CFUNC = 1,
    VM_METHOD_TYPE_ATTRSET = 2,
    VM_METHOD_TYPE_IVAR = 3,
    VM_METHOD_TYPE_BMETHOD = 4,
    VM_METHOD_TYPE_ZSUPER = 5,
    VM_METHOD_TYPE_UNDEF = 6,
    VM_METHOD_TYPE_NOTIMPLEMENTED = 7,
    VM_METHOD_TYPE_OPTIMIZED = 8,
    VM_METHOD_TYPE_MISSING = 9,
    VM_METHOD_TYPE_REFINED = 10,
}
pub type rb_method_type_t = Enum_Unnamed25;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_rb_method_cfunc_struct {
    pub func: ::std::option::Option<extern "C" fn() -> VALUE>,
    pub invoker: ::std::option::Option<unsafe extern "C" fn(func:
                                                                ::std::option::Option<extern "C" fn()
                                                                                          ->
                                                                                              VALUE>,
                                                            recv: VALUE,
                                                            argc:
                                                                ::std::os::raw::c_int,
                                                            argv:
                                                                *const VALUE)
                                           -> VALUE>,
    pub argc: ::std::os::raw::c_int,
}
impl ::std::clone::Clone for Struct_rb_method_cfunc_struct {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_rb_method_cfunc_struct {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type rb_method_cfunc_t = Struct_rb_method_cfunc_struct;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_rb_method_attr_struct {
    pub id: ID,
    pub location: VALUE,
}
impl ::std::clone::Clone for Struct_rb_method_attr_struct {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_rb_method_attr_struct {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type rb_method_attr_t = Struct_rb_method_attr_struct;
pub type rb_iseq_t = Struct_rb_iseq_struct;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_rb_method_definition_struct {
    pub _type: rb_method_type_t,
    pub original_id: ID,
    pub body: Union_Unnamed26,
    pub alias_count: ::std::os::raw::c_int,
}
impl ::std::clone::Clone for Struct_rb_method_definition_struct {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_rb_method_definition_struct {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub struct Union_Unnamed26 {
    pub _bindgen_data_: [u64; 3usize],
}
impl Union_Unnamed26 {
    pub unsafe fn iseq(&mut self) -> *mut *mut rb_iseq_t {
        let raw: *mut u8 = ::std::mem::transmute(&self._bindgen_data_);
        ::std::mem::transmute(raw.offset(0))
    }
    pub unsafe fn cfunc(&mut self) -> *mut rb_method_cfunc_t {
        let raw: *mut u8 = ::std::mem::transmute(&self._bindgen_data_);
        ::std::mem::transmute(raw.offset(0))
    }
    pub unsafe fn attr(&mut self) -> *mut rb_method_attr_t {
        let raw: *mut u8 = ::std::mem::transmute(&self._bindgen_data_);
        ::std::mem::transmute(raw.offset(0))
    }
    pub unsafe fn _proc(&mut self) -> *mut VALUE {
        let raw: *mut u8 = ::std::mem::transmute(&self._bindgen_data_);
        ::std::mem::transmute(raw.offset(0))
    }
    pub unsafe fn optimize_type(&mut self)
     -> *mut Enum_method_optimized_type {
        let raw: *mut u8 = ::std::mem::transmute(&self._bindgen_data_);
        ::std::mem::transmute(raw.offset(0))
    }
    pub unsafe fn orig_me(&mut self)
     -> *mut *mut Struct_rb_method_entry_struct {
        let raw: *mut u8 = ::std::mem::transmute(&self._bindgen_data_);
        ::std::mem::transmute(raw.offset(0))
    }
}
impl ::std::clone::Clone for Union_Unnamed26 {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Union_Unnamed26 {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type rb_method_definition_t = Struct_rb_method_definition_struct;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_rb_method_entry_struct {
    pub flag: rb_method_flag_t,
    pub mark: ::std::os::raw::c_char,
    pub def: *mut rb_method_definition_t,
    pub called_id: ID,
    pub klass: VALUE,
}
impl ::std::clone::Clone for Struct_rb_method_entry_struct {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_rb_method_entry_struct {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type rb_method_entry_t = Struct_rb_method_entry_struct;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_unlinked_method_entry_list_entry {
    pub next: *mut Struct_unlinked_method_entry_list_entry,
    pub me: *mut rb_method_entry_t,
}
impl ::std::clone::Clone for Struct_unlinked_method_entry_list_entry {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_unlinked_method_entry_list_entry {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type rb_atomic_t = ::std::os::raw::c_uint;
pub type rb_nativethread_id_t = pthread_t;
pub type rb_nativethread_lock_t = pthread_mutex_t;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_rb_thread_cond_struct {
    pub cond: pthread_cond_t,
    pub clockid: clockid_t,
}
impl ::std::clone::Clone for Struct_rb_thread_cond_struct {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_rb_thread_cond_struct {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type rb_nativethread_cond_t = Struct_rb_thread_cond_struct;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_native_thread_data_struct {
    pub signal_thread_list: *mut ::std::os::raw::c_void,
    pub sleep_cond: rb_nativethread_cond_t,
}
impl ::std::clone::Clone for Struct_native_thread_data_struct {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_native_thread_data_struct {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type native_thread_data_t = Struct_native_thread_data_struct;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_rb_global_vm_lock_struct {
    pub acquired: ::std::os::raw::c_ulong,
    pub lock: pthread_mutex_t,
    pub waiting: ::std::os::raw::c_ulong,
    pub cond: rb_nativethread_cond_t,
    pub switch_cond: rb_nativethread_cond_t,
    pub switch_wait_cond: rb_nativethread_cond_t,
    pub need_yield: ::std::os::raw::c_int,
    pub wait_yield: ::std::os::raw::c_int,
}
impl ::std::clone::Clone for Struct_rb_global_vm_lock_struct {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_rb_global_vm_lock_struct {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type rb_global_vm_lock_t = Struct_rb_global_vm_lock_struct;
pub type rb_num_t = ::std::os::raw::c_ulong;
pub enum Struct_iseq_compile_data_ensure_node_stack { }
pub enum Struct_rb_compile_option_struct { }
pub type rb_compile_option_t = Struct_rb_compile_option_struct;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_iseq_inline_cache_entry {
    pub ic_serial: rb_serial_t,
    pub ic_value: Union_Unnamed27,
}
impl ::std::clone::Clone for Struct_iseq_inline_cache_entry {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_iseq_inline_cache_entry {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub struct Union_Unnamed27 {
    pub _bindgen_data_: [u64; 1usize],
}
impl Union_Unnamed27 {
    pub unsafe fn index(&mut self) -> *mut size_t {
        let raw: *mut u8 = ::std::mem::transmute(&self._bindgen_data_);
        ::std::mem::transmute(raw.offset(0))
    }
    pub unsafe fn value(&mut self) -> *mut VALUE {
        let raw: *mut u8 = ::std::mem::transmute(&self._bindgen_data_);
        ::std::mem::transmute(raw.offset(0))
    }
}
impl ::std::clone::Clone for Union_Unnamed27 {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Union_Unnamed27 {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub struct Union_iseq_inline_storage_entry {
    pub _bindgen_data_: [u64; 3usize],
}
impl Union_iseq_inline_storage_entry {
    pub unsafe fn once(&mut self) -> *mut Struct_Unnamed28 {
        let raw: *mut u8 = ::std::mem::transmute(&self._bindgen_data_);
        ::std::mem::transmute(raw.offset(0))
    }
    pub unsafe fn cache(&mut self) -> *mut Struct_iseq_inline_cache_entry {
        let raw: *mut u8 = ::std::mem::transmute(&self._bindgen_data_);
        ::std::mem::transmute(raw.offset(0))
    }
}
impl ::std::clone::Clone for Union_iseq_inline_storage_entry {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Union_iseq_inline_storage_entry {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub struct Struct_Unnamed28 {
    pub running_thread: *mut Struct_rb_thread_struct,
    pub value: VALUE,
    pub done: VALUE,
}
impl ::std::clone::Clone for Struct_Unnamed28 {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_Unnamed28 {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub struct Struct_rb_call_info_struct {
    pub mid: ID,
    pub flag: VALUE,
    pub orig_argc: ::std::os::raw::c_int,
    pub blockiseq: *mut rb_iseq_t,
    pub method_state: rb_serial_t,
    pub class_serial: rb_serial_t,
    pub klass: VALUE,
    pub me: *const rb_method_entry_t,
    pub defined_class: VALUE,
    pub argc: ::std::os::raw::c_int,
    pub blockptr: *mut Struct_rb_block_struct,
    pub recv: VALUE,
    pub aux: Union_Unnamed29,
    pub call: ::std::option::Option<unsafe extern "C" fn(th:
                                                             *mut Struct_rb_thread_struct,
                                                         cfp:
                                                             *mut Struct_rb_control_frame_struct,
                                                         ci:
                                                             *mut Struct_rb_call_info_struct)
                                        -> VALUE>,
}
impl ::std::clone::Clone for Struct_rb_call_info_struct {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_rb_call_info_struct {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub struct Union_Unnamed29 {
    pub _bindgen_data_: [u64; 1usize],
}
impl Union_Unnamed29 {
    pub unsafe fn opt_pc(&mut self) -> *mut ::std::os::raw::c_int {
        let raw: *mut u8 = ::std::mem::transmute(&self._bindgen_data_);
        ::std::mem::transmute(raw.offset(0))
    }
    pub unsafe fn index(&mut self) -> *mut ::std::os::raw::c_long {
        let raw: *mut u8 = ::std::mem::transmute(&self._bindgen_data_);
        ::std::mem::transmute(raw.offset(0))
    }
    pub unsafe fn missing_reason(&mut self) -> *mut ::std::os::raw::c_int {
        let raw: *mut u8 = ::std::mem::transmute(&self._bindgen_data_);
        ::std::mem::transmute(raw.offset(0))
    }
    pub unsafe fn inc_sp(&mut self) -> *mut ::std::os::raw::c_int {
        let raw: *mut u8 = ::std::mem::transmute(&self._bindgen_data_);
        ::std::mem::transmute(raw.offset(0))
    }
}
impl ::std::clone::Clone for Union_Unnamed29 {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Union_Unnamed29 {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type rb_call_info_t = Struct_rb_call_info_struct;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_rb_iseq_location_struct {
    pub path: VALUE,
    pub absolute_path: VALUE,
    pub base_label: VALUE,
    pub label: VALUE,
    pub first_lineno: size_t,
}
impl ::std::clone::Clone for Struct_rb_iseq_location_struct {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_rb_iseq_location_struct {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type rb_iseq_location_t = Struct_rb_iseq_location_struct;
pub enum Struct_iseq_line_info_entry { }
pub enum Struct_iseq_catch_table_entry { }
pub enum Struct_iseq_compile_data { }
#[repr(C)]
#[derive(Copy)]
pub struct Struct_rb_iseq_struct {
    pub _type: Enum_iseq_type,
    pub location: rb_iseq_location_t,
    pub iseq: *mut VALUE,
    pub iseq_encoded: *mut VALUE,
    pub iseq_size: ::std::os::raw::c_ulong,
    pub mark_ary: VALUE,
    pub coverage: VALUE,
    pub line_info_table: *mut Struct_iseq_line_info_entry,
    pub line_info_size: size_t,
    pub local_table: *mut ID,
    pub local_table_size: ::std::os::raw::c_int,
    pub local_size: ::std::os::raw::c_int,
    pub is_entries: *mut Union_iseq_inline_storage_entry,
    pub is_size: ::std::os::raw::c_int,
    pub callinfo_entries: *mut rb_call_info_t,
    pub callinfo_size: ::std::os::raw::c_int,
    pub argc: ::std::os::raw::c_int,
    pub arg_simple: ::std::os::raw::c_int,
    pub arg_rest: ::std::os::raw::c_int,
    pub arg_block: ::std::os::raw::c_int,
    pub arg_opts: ::std::os::raw::c_int,
    pub arg_post_len: ::std::os::raw::c_int,
    pub arg_post_start: ::std::os::raw::c_int,
    pub arg_size: ::std::os::raw::c_int,
    pub arg_opt_table: *mut VALUE,
    pub arg_keyword: ::std::os::raw::c_int,
    pub arg_keyword_check: ::std::os::raw::c_int,
    pub arg_keywords: ::std::os::raw::c_int,
    pub arg_keyword_required: ::std::os::raw::c_int,
    pub arg_keyword_table: *mut ID,
    pub stack_max: size_t,
    pub catch_table: *mut Struct_iseq_catch_table_entry,
    pub catch_table_size: ::std::os::raw::c_int,
    pub parent_iseq: *mut Struct_rb_iseq_struct,
    pub local_iseq: *mut Struct_rb_iseq_struct,
    pub _self: VALUE,
    pub orig: VALUE,
    pub cref_stack: *mut NODE,
    pub klass: VALUE,
    pub defined_method_id: ID,
    pub flip_cnt: rb_num_t,
    pub compile_data: *mut Struct_iseq_compile_data,
}
impl ::std::clone::Clone for Struct_rb_iseq_struct {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_rb_iseq_struct {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[derive(Clone, Copy)]
#[repr(u32)]
pub enum Enum_ruby_special_exceptions {
    ruby_error_reenter = 0,
    ruby_error_nomemory = 1,
    ruby_error_sysstack = 2,
    ruby_error_closed_stream = 3,
    ruby_special_error_count = 4,
}
pub enum Struct_rb_objspace { }
pub enum Struct_rb_event_hook_struct { }
#[repr(C)]
#[derive(Copy)]
pub struct Struct_rb_hook_list_struct {
    pub hooks: *mut Struct_rb_event_hook_struct,
    pub events: rb_event_flag_t,
    pub need_clean: ::std::os::raw::c_int,
}
impl ::std::clone::Clone for Struct_rb_hook_list_struct {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_rb_hook_list_struct {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type rb_hook_list_t = Struct_rb_hook_list_struct;
pub enum Struct_rb_postponed_job_struct { }
#[repr(C)]
#[derive(Copy)]
pub struct Struct_rb_vm_struct {
    pub _self: VALUE,
    pub gvl: rb_global_vm_lock_t,
    pub thread_destruct_lock: rb_nativethread_lock_t,
    pub main_thread: *mut Struct_rb_thread_struct,
    pub running_thread: *mut Struct_rb_thread_struct,
    pub living_threads: *mut st_table,
    pub thgroup_default: VALUE,
    pub running: ::std::os::raw::c_int,
    pub thread_abort_on_exception: ::std::os::raw::c_int,
    pub trace_running: ::std::os::raw::c_int,
    pub sleeper: ::std::os::raw::c_int,
    pub mark_object_ary: VALUE,
    pub special_exceptions: [VALUE; 4usize],
    pub top_self: VALUE,
    pub load_path: VALUE,
    pub load_path_snapshot: VALUE,
    pub load_path_check_cache: VALUE,
    pub expanded_load_path: VALUE,
    pub loaded_features: VALUE,
    pub loaded_features_snapshot: VALUE,
    pub loaded_features_index: *mut Struct_st_table,
    pub loading_table: *mut Struct_st_table,
    pub trap_list: [Struct_Unnamed30; 65usize],
    pub event_hooks: rb_hook_list_t,
    pub ensure_rollback_table: *mut Struct_st_table,
    pub postponed_job_buffer: *mut Struct_rb_postponed_job_struct,
    pub postponed_job_index: ::std::os::raw::c_int,
    pub src_encoding_index: ::std::os::raw::c_int,
    pub verbose: VALUE,
    pub debug: VALUE,
    pub orig_progname: VALUE,
    pub progname: VALUE,
    pub coverages: VALUE,
    pub unlinked_method_entry_list: *mut Struct_unlinked_method_entry_list_entry,
    pub defined_module_hash: VALUE,
    pub objspace: *mut Struct_rb_objspace,
    pub at_exit: Struct_RArray,
    pub defined_strings: *mut VALUE,
    pub default_params: Struct_Unnamed31,
}
impl ::std::clone::Clone for Struct_rb_vm_struct {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_rb_vm_struct {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub struct Struct_Unnamed30 {
    pub cmd: VALUE,
    pub safe: ::std::os::raw::c_int,
}
impl ::std::clone::Clone for Struct_Unnamed30 {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_Unnamed30 {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub struct Struct_Unnamed31 {
    pub thread_vm_stack_size: size_t,
    pub thread_machine_stack_size: size_t,
    pub fiber_vm_stack_size: size_t,
    pub fiber_machine_stack_size: size_t,
}
impl ::std::clone::Clone for Struct_Unnamed31 {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_Unnamed31 {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type rb_vm_t = Struct_rb_vm_struct;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_rb_control_frame_struct {
    pub pc: *mut VALUE,
    pub sp: *mut VALUE,
    pub iseq: *mut rb_iseq_t,
    pub flag: VALUE,
    pub _self: VALUE,
    pub klass: VALUE,
    pub ep: *mut VALUE,
    pub block_iseq: *mut rb_iseq_t,
    pub _proc: VALUE,
    pub me: *const rb_method_entry_t,
}
impl ::std::clone::Clone for Struct_rb_control_frame_struct {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_rb_control_frame_struct {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type rb_control_frame_t = Struct_rb_control_frame_struct;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_rb_block_struct {
    pub _self: VALUE,
    pub klass: VALUE,
    pub ep: *mut VALUE,
    pub iseq: *mut rb_iseq_t,
    pub _proc: VALUE,
}
impl ::std::clone::Clone for Struct_rb_block_struct {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_rb_block_struct {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type rb_block_t = Struct_rb_block_struct;
#[derive(Clone, Copy)]
#[repr(u32)]
pub enum Enum_rb_thread_status {
    THREAD_RUNNABLE = 0,
    THREAD_STOPPED = 1,
    THREAD_STOPPED_FOREVER = 2,
    THREAD_KILLED = 3,
}
pub type rb_jmpbuf_t = jmp_buf;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_rb_vm_tag {
    pub tag: VALUE,
    pub retval: VALUE,
    pub buf: rb_jmpbuf_t,
    pub prev: *mut Struct_rb_vm_tag,
}
impl ::std::clone::Clone for Struct_rb_vm_tag {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_rb_vm_tag {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub struct Struct_rb_vm_protect_tag {
    pub prev: *mut Struct_rb_vm_protect_tag,
}
impl ::std::clone::Clone for Struct_rb_vm_protect_tag {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_rb_vm_protect_tag {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub struct Struct_rb_unblock_callback {
    pub func: *mut ::std::option::Option<extern "C" fn()>,
    pub arg: *mut ::std::os::raw::c_void,
}
impl ::std::clone::Clone for Struct_rb_unblock_callback {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_rb_unblock_callback {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub enum Struct_rb_mutex_struct { }
#[repr(C)]
#[derive(Copy)]
pub struct Struct_rb_thread_list_struct {
    pub next: *mut Struct_rb_thread_list_struct,
    pub th: *mut Struct_rb_thread_struct,
}
impl ::std::clone::Clone for Struct_rb_thread_list_struct {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_rb_thread_list_struct {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type rb_thread_list_t = Struct_rb_thread_list_struct;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_rb_ensure_entry {
    pub marker: VALUE,
    pub e_proc: ::std::option::Option<extern "C" fn() -> VALUE>,
    pub data2: VALUE,
}
impl ::std::clone::Clone for Struct_rb_ensure_entry {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_rb_ensure_entry {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type rb_ensure_entry_t = Struct_rb_ensure_entry;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_rb_ensure_list {
    pub next: *mut Struct_rb_ensure_list,
    pub entry: Struct_rb_ensure_entry,
}
impl ::std::clone::Clone for Struct_rb_ensure_list {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_rb_ensure_list {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type rb_ensure_list_t = Struct_rb_ensure_list;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_rb_thread_struct {
    pub _self: VALUE,
    pub vm: *mut rb_vm_t,
    pub stack: *mut VALUE,
    pub stack_size: size_t,
    pub cfp: *mut rb_control_frame_t,
    pub safe_level: ::std::os::raw::c_int,
    pub raised_flag: ::std::os::raw::c_int,
    pub last_status: VALUE,
    pub state: ::std::os::raw::c_int,
    pub waiting_fd: ::std::os::raw::c_int,
    pub passed_block: *const rb_block_t,
    pub passed_bmethod_me: *const rb_method_entry_t,
    pub passed_ci: *mut rb_call_info_t,
    pub top_self: VALUE,
    pub top_wrapper: VALUE,
    pub base_block: *mut rb_block_t,
    pub root_lep: *mut VALUE,
    pub root_svar: VALUE,
    pub thread_id: rb_nativethread_id_t,
    pub status: Enum_rb_thread_status,
    pub to_kill: ::std::os::raw::c_int,
    pub priority: ::std::os::raw::c_int,
    pub native_thread_data: native_thread_data_t,
    pub blocking_region_buffer: *mut ::std::os::raw::c_void,
    pub thgroup: VALUE,
    pub value: VALUE,
    pub errinfo: VALUE,
    pub pending_interrupt_queue: VALUE,
    pub pending_interrupt_queue_checked: ::std::os::raw::c_int,
    pub pending_interrupt_mask_stack: VALUE,
    pub interrupt_flag: rb_atomic_t,
    pub interrupt_mask: ::std::os::raw::c_ulong,
    pub interrupt_lock: rb_nativethread_lock_t,
    pub interrupt_cond: rb_nativethread_cond_t,
    pub unblock: Struct_rb_unblock_callback,
    pub locking_mutex: VALUE,
    pub keeping_mutexes: *mut Struct_rb_mutex_struct,
    pub tag: *mut Struct_rb_vm_tag,
    pub protect_tag: *mut Struct_rb_vm_protect_tag,
    pub parse_in_eval: ::std::os::raw::c_int,
    pub mild_compile_error: ::std::os::raw::c_int,
    pub local_storage: *mut st_table,
    pub join_list: *mut rb_thread_list_t,
    pub first_proc: VALUE,
    pub first_args: VALUE,
    pub first_func: ::std::option::Option<extern "C" fn() -> VALUE>,
    pub machine: Struct_Unnamed32,
    pub mark_stack_len: ::std::os::raw::c_int,
    pub stat_insn_usage: VALUE,
    pub event_hooks: rb_hook_list_t,
    pub trace_arg: *mut Struct_rb_trace_arg_struct,
    pub fiber: VALUE,
    pub root_fiber: VALUE,
    pub root_jmpbuf: rb_jmpbuf_t,
    pub ensure_list: *mut rb_ensure_list_t,
    pub method_missing_reason: ::std::os::raw::c_int,
    pub abort_on_exception: ::std::os::raw::c_int,
    pub altstack: *mut ::std::os::raw::c_void,
    pub running_time_us: ::std::os::raw::c_ulong,
}
impl ::std::clone::Clone for Struct_rb_thread_struct {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_rb_thread_struct {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub struct Struct_Unnamed32 {
    pub stack_start: *mut VALUE,
    pub stack_end: *mut VALUE,
    pub stack_maxsize: size_t,
    pub regs: jmp_buf,
}
impl ::std::clone::Clone for Struct_Unnamed32 {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_Unnamed32 {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type rb_thread_t = Struct_rb_thread_struct;
#[derive(Clone, Copy)]
#[repr(u32)]
pub enum Enum_Unnamed33 {
    VM_DEFINECLASS_TYPE_CLASS = 0,
    VM_DEFINECLASS_TYPE_SINGLETON_CLASS = 1,
    VM_DEFINECLASS_TYPE_MODULE = 2,
    VM_DEFINECLASS_TYPE_MASK = 7,
}
pub type rb_vm_defineclass_type_t = Enum_Unnamed33;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_Unnamed34 {
    pub block: rb_block_t,
    pub envval: VALUE,
    pub blockprocval: VALUE,
    pub safe_level: ::std::os::raw::c_int,
    pub is_from_method: ::std::os::raw::c_int,
    pub is_lambda: ::std::os::raw::c_int,
}
impl ::std::clone::Clone for Struct_Unnamed34 {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_Unnamed34 {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type rb_proc_t = Struct_Unnamed34;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_Unnamed35 {
    pub env: *mut VALUE,
    pub env_size: ::std::os::raw::c_int,
    pub local_size: ::std::os::raw::c_int,
    pub prev_envval: VALUE,
    pub block: rb_block_t,
}
impl ::std::clone::Clone for Struct_Unnamed35 {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_Unnamed35 {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type rb_env_t = Struct_Unnamed35;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_Unnamed36 {
    pub env: VALUE,
    pub path: VALUE,
    pub blockprocval: VALUE,
    pub first_lineno: ::std::os::raw::c_ushort,
}
impl ::std::clone::Clone for Struct_Unnamed36 {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_Unnamed36 {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type rb_binding_t = Struct_Unnamed36;
#[derive(Clone, Copy)]
#[repr(u32)]
pub enum Enum_vm_check_match_type {
    VM_CHECKMATCH_TYPE_WHEN = 1,
    VM_CHECKMATCH_TYPE_CASE = 2,
    VM_CHECKMATCH_TYPE_RESCUE = 3,
}
#[derive(Clone, Copy)]
#[repr(u32)]
pub enum Enum_vm_special_object_type {
    VM_SPECIAL_OBJECT_VMCORE = 1,
    VM_SPECIAL_OBJECT_CBASE = 2,
    VM_SPECIAL_OBJECT_CONST_BASE = 3,
}
pub type IC = *mut Struct_iseq_inline_cache_entry;
pub type CALL_INFO = *mut rb_call_info_t;
pub type CDHASH = VALUE;
pub type rb_insn_func_t =
    ::std::option::Option<unsafe extern "C" fn(arg1: *mut rb_thread_t,
                                               arg2: *mut rb_control_frame_t)
                              -> *mut rb_control_frame_t>;
pub type rb_backtrace_iter_func =
    unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void, arg2: VALUE,
                         arg3: ::std::os::raw::c_int, arg4: VALUE)
        -> ::std::os::raw::c_int;
#[derive(Clone, Copy)]
#[repr(u32)]
pub enum Enum_Unnamed37 {
    TIMER_INTERRUPT_MASK = 1,
    PENDING_INTERRUPT_MASK = 2,
    POSTPONED_JOB_INTERRUPT_MASK = 4,
    TRAP_INTERRUPT_MASK = 8,
}
#[repr(C)]
#[derive(Copy)]
pub struct Struct_rb_trace_arg_struct {
    pub event: rb_event_flag_t,
    pub th: *mut rb_thread_t,
    pub cfp: *mut rb_control_frame_t,
    pub _self: VALUE,
    pub id: ID,
    pub klass: VALUE,
    pub data: VALUE,
    pub klass_solved: ::std::os::raw::c_int,
    pub lineno: ::std::os::raw::c_int,
    pub path: VALUE,
}
impl ::std::clone::Clone for Struct_rb_trace_arg_struct {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_rb_trace_arg_struct {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
extern "C" {
    pub static mut rb_mKernel: VALUE;
    pub static mut rb_mComparable: VALUE;
    pub static mut rb_mEnumerable: VALUE;
    pub static mut rb_mErrno: VALUE;
    pub static mut rb_mFileTest: VALUE;
    pub static mut rb_mGC: VALUE;
    pub static mut rb_mMath: VALUE;
    pub static mut rb_mProcess: VALUE;
    pub static mut rb_mWaitReadable: VALUE;
    pub static mut rb_mWaitWritable: VALUE;
    pub static mut rb_cBasicObject: VALUE;
    pub static mut rb_cObject: VALUE;
    pub static mut rb_cArray: VALUE;
    pub static mut rb_cBignum: VALUE;
    pub static mut rb_cBinding: VALUE;
    pub static mut rb_cClass: VALUE;
    pub static mut rb_cCont: VALUE;
    pub static mut rb_cDir: VALUE;
    pub static mut rb_cData: VALUE;
    pub static mut rb_cFalseClass: VALUE;
    pub static mut rb_cEncoding: VALUE;
    pub static mut rb_cEnumerator: VALUE;
    pub static mut rb_cFile: VALUE;
    pub static mut rb_cFixnum: VALUE;
    pub static mut rb_cFloat: VALUE;
    pub static mut rb_cHash: VALUE;
    pub static mut rb_cInteger: VALUE;
    pub static mut rb_cIO: VALUE;
    pub static mut rb_cMatch: VALUE;
    pub static mut rb_cMethod: VALUE;
    pub static mut rb_cModule: VALUE;
    pub static mut rb_cNameErrorMesg: VALUE;
    pub static mut rb_cNilClass: VALUE;
    pub static mut rb_cNumeric: VALUE;
    pub static mut rb_cProc: VALUE;
    pub static mut rb_cRandom: VALUE;
    pub static mut rb_cRange: VALUE;
    pub static mut rb_cRational: VALUE;
    pub static mut rb_cComplex: VALUE;
    pub static mut rb_cRegexp: VALUE;
    pub static mut rb_cStat: VALUE;
    pub static mut rb_cString: VALUE;
    pub static mut rb_cStruct: VALUE;
    pub static mut rb_cSymbol: VALUE;
    pub static mut rb_cThread: VALUE;
    pub static mut rb_cTime: VALUE;
    pub static mut rb_cTrueClass: VALUE;
    pub static mut rb_cUnboundMethod: VALUE;
    pub static mut rb_eException: VALUE;
    pub static mut rb_eStandardError: VALUE;
    pub static mut rb_eSystemExit: VALUE;
    pub static mut rb_eInterrupt: VALUE;
    pub static mut rb_eSignal: VALUE;
    pub static mut rb_eFatal: VALUE;
    pub static mut rb_eArgError: VALUE;
    pub static mut rb_eEOFError: VALUE;
    pub static mut rb_eIndexError: VALUE;
    pub static mut rb_eStopIteration: VALUE;
    pub static mut rb_eKeyError: VALUE;
    pub static mut rb_eRangeError: VALUE;
    pub static mut rb_eIOError: VALUE;
    pub static mut rb_eRuntimeError: VALUE;
    pub static mut rb_eSecurityError: VALUE;
    pub static mut rb_eSystemCallError: VALUE;
    pub static mut rb_eThreadError: VALUE;
    pub static mut rb_eTypeError: VALUE;
    pub static mut rb_eZeroDivError: VALUE;
    pub static mut rb_eNotImpError: VALUE;
    pub static mut rb_eNoMemError: VALUE;
    pub static mut rb_eNoMethodError: VALUE;
    pub static mut rb_eFloatDomainError: VALUE;
    pub static mut rb_eLocalJumpError: VALUE;
    pub static mut rb_eSysStackError: VALUE;
    pub static mut rb_eRegexpError: VALUE;
    pub static mut rb_eEncodingError: VALUE;
    pub static mut rb_eEncCompatError: VALUE;
    pub static mut rb_eScriptError: VALUE;
    pub static mut rb_eNameError: VALUE;
    pub static mut rb_eSyntaxError: VALUE;
    pub static mut rb_eLoadError: VALUE;
    pub static mut rb_eMathDomainError: VALUE;
    pub static mut rb_stdin: VALUE;
    pub static mut rb_stdout: VALUE;
    pub static mut rb_stderr: VALUE;
    pub static mut rb_fs: VALUE;
    pub static mut rb_output_fs: VALUE;
    pub static mut rb_rs: VALUE;
    pub static mut rb_default_rs: VALUE;
    pub static mut rb_output_rs: VALUE;
    pub static mut ruby_sourceline: ::std::os::raw::c_int;
    pub static mut ruby_sourcefile: *mut ::std::os::raw::c_char;
    pub static mut rb_argv0: VALUE;
    pub static mut ruby_digit36_to_number_table:
               *const ::std::os::raw::c_char;
    pub static ruby_threadptr_data_type: rb_data_type_t;
    pub static mut rb_cISeq: VALUE;
    pub static mut rb_cRubyVM: VALUE;
    pub static mut rb_cEnv: VALUE;
    pub static mut rb_mRubyVMFrozenCore: VALUE;
    pub static ruby_binding_data_type: rb_data_type_t;
    pub static mut ruby_current_thread: *mut rb_thread_t;
    pub static mut ruby_current_vm: *mut rb_vm_t;
    pub static mut ruby_vm_event_flags: rb_event_flag_t;
}
extern "C" {
    pub fn strlcpy(arg1: *mut ::std::os::raw::c_char,
                   arg2: *const ::std::os::raw::c_char, arg3: size_t)
     -> size_t;
    pub fn strlcat(arg1: *mut ::std::os::raw::c_char,
                   arg2: *const ::std::os::raw::c_char, arg3: size_t)
     -> size_t;
    pub fn setproctitle(fmt: *const ::std::os::raw::c_char, ...);
    pub fn ruby_xmalloc(arg1: size_t) -> *mut ::std::os::raw::c_void;
    pub fn ruby_xmalloc2(arg1: size_t, arg2: size_t)
     -> *mut ::std::os::raw::c_void;
    pub fn ruby_xcalloc(arg1: size_t, arg2: size_t)
     -> *mut ::std::os::raw::c_void;
    pub fn ruby_xrealloc(arg1: *mut ::std::os::raw::c_void, arg2: size_t)
     -> *mut ::std::os::raw::c_void;
    pub fn ruby_xrealloc2(arg1: *mut ::std::os::raw::c_void, arg2: size_t,
                          arg3: size_t) -> *mut ::std::os::raw::c_void;
    pub fn ruby_xfree(arg1: *mut ::std::os::raw::c_void);
    pub fn rb_int2inum(arg1: ::std::os::raw::c_long) -> VALUE;
    pub fn rb_uint2inum(arg1: VALUE) -> VALUE;
    pub fn rb_ll2inum(arg1: ::std::os::raw::c_longlong) -> VALUE;
    pub fn rb_ull2inum(arg1: ::std::os::raw::c_ulonglong) -> VALUE;
    pub fn rb_out_of_int(num: ::std::os::raw::c_long);
    pub fn rb_check_type(arg1: VALUE, arg2: ::std::os::raw::c_int);
    pub fn rb_str_to_str(arg1: VALUE) -> VALUE;
    pub fn rb_string_value(arg1: *mut VALUE) -> VALUE;
    pub fn rb_string_value_ptr(arg1: *mut VALUE)
     -> *mut ::std::os::raw::c_char;
    pub fn rb_string_value_cstr(arg1: *mut VALUE)
     -> *mut ::std::os::raw::c_char;
    pub fn rb_check_safe_obj(arg1: VALUE);
    pub fn rb_check_safe_str(arg1: VALUE);
    pub fn rb_str_export(arg1: VALUE) -> VALUE;
    pub fn rb_str_export_locale(arg1: VALUE) -> VALUE;
    pub fn rb_get_path(arg1: VALUE) -> VALUE;
    pub fn rb_get_path_no_checksafe(arg1: VALUE) -> VALUE;
    pub fn rb_secure(arg1: ::std::os::raw::c_int);
    pub fn rb_safe_level() -> ::std::os::raw::c_int;
    pub fn rb_set_safe_level(arg1: ::std::os::raw::c_int);
    pub fn rb_set_safe_level_force(arg1: ::std::os::raw::c_int);
    pub fn rb_secure_update(arg1: VALUE);
    pub fn rb_insecure_operation();
    pub fn rb_errinfo() -> VALUE;
    pub fn rb_set_errinfo(arg1: VALUE);
    pub fn rb_num2long(arg1: VALUE) -> ::std::os::raw::c_long;
    pub fn rb_num2ulong(arg1: VALUE) -> VALUE;
    pub fn rb_num2int(arg1: VALUE) -> ::std::os::raw::c_long;
    pub fn rb_fix2int(arg1: VALUE) -> ::std::os::raw::c_long;
    pub fn rb_num2uint(arg1: VALUE) -> ::std::os::raw::c_ulong;
    pub fn rb_fix2uint(arg1: VALUE) -> ::std::os::raw::c_ulong;
    pub fn rb_num2short(arg1: VALUE) -> ::std::os::raw::c_short;
    pub fn rb_num2ushort(arg1: VALUE) -> ::std::os::raw::c_ushort;
    pub fn rb_fix2short(arg1: VALUE) -> ::std::os::raw::c_short;
    pub fn rb_fix2ushort(arg1: VALUE) -> ::std::os::raw::c_ushort;
    pub fn rb_num2ll(arg1: VALUE) -> ::std::os::raw::c_longlong;
    pub fn rb_num2ull(arg1: VALUE) -> ::std::os::raw::c_ulonglong;
    pub fn rb_num2dbl(arg1: VALUE) -> ::std::os::raw::c_double;
    pub fn rb_uint2big(arg1: VALUE) -> VALUE;
    pub fn rb_int2big(arg1: ::std::os::raw::c_long) -> VALUE;
    pub fn rb_newobj() -> VALUE;
    pub fn rb_newobj_of(arg1: VALUE, arg2: VALUE) -> VALUE;
    pub fn rb_obj_setup(obj: VALUE, klass: VALUE, _type: VALUE) -> VALUE;
    pub fn rb_obj_hide(obj: VALUE) -> VALUE;
    pub fn rb_obj_reveal(obj: VALUE, klass: VALUE) -> VALUE;
    pub fn rb_float_value(arg1: VALUE) -> ::std::os::raw::c_double;
    pub fn rb_float_new(arg1: ::std::os::raw::c_double) -> VALUE;
    pub fn rb_float_new_in_heap(arg1: ::std::os::raw::c_double) -> VALUE;
    pub fn rb_data_object_alloc(arg1: VALUE,
                                arg2: *mut ::std::os::raw::c_void,
                                arg3: RUBY_DATA_FUNC, arg4: RUBY_DATA_FUNC)
     -> VALUE;
    pub fn rb_data_typed_object_alloc(klass: VALUE,
                                      datap: *mut ::std::os::raw::c_void,
                                      arg1: *const rb_data_type_t) -> VALUE;
    pub fn rb_typeddata_inherited_p(child: *const rb_data_type_t,
                                    parent: *const rb_data_type_t)
     -> ::std::os::raw::c_int;
    pub fn rb_typeddata_is_kind_of(arg1: VALUE, arg2: *const rb_data_type_t)
     -> ::std::os::raw::c_int;
    pub fn rb_check_typeddata(arg1: VALUE, arg2: *const rb_data_type_t)
     -> *mut ::std::os::raw::c_void;
    pub fn rb_gc_writebarrier(a: VALUE, b: VALUE);
    pub fn rb_gc_writebarrier_unprotect_promoted(obj: VALUE);
    pub fn rb_alloc_tmp_buffer(store: *mut VALUE, len: ::std::os::raw::c_long)
     -> *mut ::std::os::raw::c_void;
    pub fn rb_free_tmp_buffer(store: *mut VALUE);
    pub fn rb_obj_infect(arg1: VALUE, arg2: VALUE);
    pub fn rb_glob(arg1: *const ::std::os::raw::c_char,
                   arg2:
                       ::std::option::Option<unsafe extern "C" fn(arg1:
                                                                      *const ::std::os::raw::c_char,
                                                                  arg2: VALUE,
                                                                  arg3:
                                                                      *mut ::std::os::raw::c_void)>,
                   arg3: VALUE);
    pub fn ruby_glob(arg1: *const ::std::os::raw::c_char,
                     arg2: ::std::os::raw::c_int,
                     arg3:
                         *mut ::std::option::Option<extern "C" fn()
                                                        ->
                                                            ::std::os::raw::c_int>,
                     arg4: VALUE) -> ::std::os::raw::c_int;
    pub fn ruby_brace_glob(arg1: *const ::std::os::raw::c_char,
                           arg2: ::std::os::raw::c_int,
                           arg3:
                               *mut ::std::option::Option<extern "C" fn()
                                                              ->
                                                                  ::std::os::raw::c_int>,
                           arg4: VALUE) -> ::std::os::raw::c_int;
    pub fn rb_define_class(arg1: *const ::std::os::raw::c_char, arg2: VALUE)
     -> VALUE;
    pub fn rb_define_module(arg1: *const ::std::os::raw::c_char) -> VALUE;
    pub fn rb_define_class_under(arg1: VALUE,
                                 arg2: *const ::std::os::raw::c_char,
                                 arg3: VALUE) -> VALUE;
    pub fn rb_define_module_under(arg1: VALUE,
                                  arg2: *const ::std::os::raw::c_char)
     -> VALUE;
    pub fn rb_include_module(arg1: VALUE, arg2: VALUE);
    pub fn rb_extend_object(arg1: VALUE, arg2: VALUE);
    pub fn rb_prepend_module(arg1: VALUE, arg2: VALUE);
    pub fn rb_gvar_undef_getter(id: ID, data: *mut ::std::os::raw::c_void,
                                gvar: *mut Struct_rb_global_variable)
     -> VALUE;
    pub fn rb_gvar_undef_setter(val: VALUE, id: ID,
                                data: *mut ::std::os::raw::c_void,
                                gvar: *mut Struct_rb_global_variable);
    pub fn rb_gvar_undef_marker(var: *mut VALUE);
    pub fn rb_gvar_val_getter(id: ID, data: *mut ::std::os::raw::c_void,
                              gvar: *mut Struct_rb_global_variable) -> VALUE;
    pub fn rb_gvar_val_setter(val: VALUE, id: ID,
                              data: *mut ::std::os::raw::c_void,
                              gvar: *mut Struct_rb_global_variable);
    pub fn rb_gvar_val_marker(var: *mut VALUE);
    pub fn rb_gvar_var_getter(id: ID, data: *mut ::std::os::raw::c_void,
                              gvar: *mut Struct_rb_global_variable) -> VALUE;
    pub fn rb_gvar_var_setter(val: VALUE, id: ID,
                              data: *mut ::std::os::raw::c_void,
                              gvar: *mut Struct_rb_global_variable);
    pub fn rb_gvar_var_marker(var: *mut VALUE);
    pub fn rb_gvar_readonly_setter(val: VALUE, id: ID,
                                   data: *mut ::std::os::raw::c_void,
                                   gvar: *mut Struct_rb_global_variable);
    pub fn rb_define_variable(arg1: *const ::std::os::raw::c_char,
                              arg2: *mut VALUE);
    pub fn rb_define_virtual_variable(arg1: *const ::std::os::raw::c_char,
                                      arg2:
                                          ::std::option::Option<extern "C" fn()
                                                                    -> VALUE>,
                                      arg3:
                                          ::std::option::Option<extern "C" fn()>);
    pub fn rb_define_hooked_variable(arg1: *const ::std::os::raw::c_char,
                                     arg2: *mut VALUE,
                                     arg3:
                                         ::std::option::Option<extern "C" fn()
                                                                   -> VALUE>,
                                     arg4:
                                         ::std::option::Option<extern "C" fn()>);
    pub fn rb_define_readonly_variable(arg1: *const ::std::os::raw::c_char,
                                       arg2: *mut VALUE);
    pub fn rb_define_const(arg1: VALUE, arg2: *const ::std::os::raw::c_char,
                           arg3: VALUE);
    pub fn rb_define_global_const(arg1: *const ::std::os::raw::c_char,
                                  arg2: VALUE);
    pub fn rb_define_method(arg1: VALUE, arg2: *const ::std::os::raw::c_char,
                            arg3:
                                ::std::option::Option<extern "C" fn()
                                                          -> VALUE>,
                            arg4: ::std::os::raw::c_int);
    pub fn rb_define_module_function(arg1: VALUE,
                                     arg2: *const ::std::os::raw::c_char,
                                     arg3:
                                         ::std::option::Option<extern "C" fn()
                                                                   -> VALUE>,
                                     arg4: ::std::os::raw::c_int);
    pub fn rb_define_global_function(arg1: *const ::std::os::raw::c_char,
                                     arg2:
                                         ::std::option::Option<extern "C" fn()
                                                                   -> VALUE>,
                                     arg3: ::std::os::raw::c_int);
    pub fn rb_undef_method(arg1: VALUE, arg2: *const ::std::os::raw::c_char);
    pub fn rb_define_alias(arg1: VALUE, arg2: *const ::std::os::raw::c_char,
                           arg3: *const ::std::os::raw::c_char);
    pub fn rb_define_attr(arg1: VALUE, arg2: *const ::std::os::raw::c_char,
                          arg3: ::std::os::raw::c_int,
                          arg4: ::std::os::raw::c_int);
    pub fn rb_global_variable(arg1: *mut VALUE);
    pub fn rb_gc_register_mark_object(arg1: VALUE);
    pub fn rb_gc_register_address(arg1: *mut VALUE);
    pub fn rb_gc_unregister_address(arg1: *mut VALUE);
    pub fn rb_intern(arg1: *const ::std::os::raw::c_char) -> ID;
    pub fn rb_intern2(arg1: *const ::std::os::raw::c_char,
                      arg2: ::std::os::raw::c_long) -> ID;
    pub fn rb_intern_str(str: VALUE) -> ID;
    pub fn rb_id2name(arg1: ID) -> *const ::std::os::raw::c_char;
    pub fn rb_check_id(arg1: *mut VALUE) -> ID;
    pub fn rb_to_id(arg1: VALUE) -> ID;
    pub fn rb_id2str(arg1: ID) -> VALUE;
    pub fn rb_class2name(arg1: VALUE) -> *const ::std::os::raw::c_char;
    pub fn rb_obj_classname(arg1: VALUE) -> *const ::std::os::raw::c_char;
    pub fn rb_p(arg1: VALUE);
    pub fn rb_eval_string(arg1: *const ::std::os::raw::c_char) -> VALUE;
    pub fn rb_eval_string_protect(arg1: *const ::std::os::raw::c_char,
                                  arg2: *mut ::std::os::raw::c_int) -> VALUE;
    pub fn rb_eval_string_wrap(arg1: *const ::std::os::raw::c_char,
                               arg2: *mut ::std::os::raw::c_int) -> VALUE;
    pub fn rb_funcall(arg1: VALUE, arg2: ID, arg3: ::std::os::raw::c_int, ...)
     -> VALUE;
    pub fn rb_funcallv(arg1: VALUE, arg2: ID, arg3: ::std::os::raw::c_int,
                       arg4: *const VALUE) -> VALUE;
    pub fn rb_funcallv_public(arg1: VALUE, arg2: ID,
                              arg3: ::std::os::raw::c_int, arg4: *const VALUE)
     -> VALUE;
    pub fn rb_funcall_passing_block(arg1: VALUE, arg2: ID,
                                    arg3: ::std::os::raw::c_int,
                                    arg4: *const VALUE) -> VALUE;
    pub fn rb_funcall_with_block(arg1: VALUE, arg2: ID,
                                 arg3: ::std::os::raw::c_int,
                                 arg4: *const VALUE, arg5: VALUE) -> VALUE;
    pub fn rb_scan_args(arg1: ::std::os::raw::c_int, arg2: *const VALUE,
                        arg3: *const ::std::os::raw::c_char, ...)
     -> ::std::os::raw::c_int;
    pub fn rb_call_super(arg1: ::std::os::raw::c_int, arg2: *const VALUE)
     -> VALUE;
    pub fn rb_gv_set(arg1: *const ::std::os::raw::c_char, arg2: VALUE)
     -> VALUE;
    pub fn rb_gv_get(arg1: *const ::std::os::raw::c_char) -> VALUE;
    pub fn rb_iv_get(arg1: VALUE, arg2: *const ::std::os::raw::c_char)
     -> VALUE;
    pub fn rb_iv_set(arg1: VALUE, arg2: *const ::std::os::raw::c_char,
                     arg3: VALUE) -> VALUE;
    pub fn rb_equal(arg1: VALUE, arg2: VALUE) -> VALUE;
    pub fn rb_ruby_verbose_ptr() -> *mut VALUE;
    pub fn rb_ruby_debug_ptr() -> *mut VALUE;
    pub fn rb_raise(arg1: VALUE, arg2: *const ::std::os::raw::c_char, ...);
    pub fn rb_fatal(arg1: *const ::std::os::raw::c_char, ...);
    pub fn rb_bug(arg1: *const ::std::os::raw::c_char, ...);
    pub fn rb_bug_errno(arg1: *const ::std::os::raw::c_char,
                        arg2: ::std::os::raw::c_int);
    pub fn rb_sys_fail(arg1: *const ::std::os::raw::c_char);
    pub fn rb_sys_fail_str(arg1: VALUE);
    pub fn rb_mod_sys_fail(arg1: VALUE, arg2: *const ::std::os::raw::c_char);
    pub fn rb_mod_sys_fail_str(arg1: VALUE, arg2: VALUE);
    pub fn rb_readwrite_sys_fail(arg1: ::std::os::raw::c_int,
                                 arg2: *const ::std::os::raw::c_char);
    pub fn rb_iter_break();
    pub fn rb_iter_break_value(arg1: VALUE);
    pub fn rb_exit(arg1: ::std::os::raw::c_int);
    pub fn rb_notimplement();
    pub fn rb_syserr_new(arg1: ::std::os::raw::c_int,
                         arg2: *const ::std::os::raw::c_char) -> VALUE;
    pub fn rb_syserr_new_str(n: ::std::os::raw::c_int, arg: VALUE) -> VALUE;
    pub fn rb_syserr_fail(arg1: ::std::os::raw::c_int,
                          arg2: *const ::std::os::raw::c_char);
    pub fn rb_syserr_fail_str(arg1: ::std::os::raw::c_int, arg2: VALUE);
    pub fn rb_mod_syserr_fail(arg1: VALUE, arg2: ::std::os::raw::c_int,
                              arg3: *const ::std::os::raw::c_char);
    pub fn rb_mod_syserr_fail_str(arg1: VALUE, arg2: ::std::os::raw::c_int,
                                  arg3: VALUE);
    pub fn rb_warning(arg1: *const ::std::os::raw::c_char, ...);
    pub fn rb_compile_warning(arg1: *const ::std::os::raw::c_char,
                              arg2: ::std::os::raw::c_int,
                              arg3: *const ::std::os::raw::c_char, ...);
    pub fn rb_sys_warning(arg1: *const ::std::os::raw::c_char, ...);
    pub fn rb_warn(arg1: *const ::std::os::raw::c_char, ...);
    pub fn rb_compile_warn(arg1: *const ::std::os::raw::c_char,
                           arg2: ::std::os::raw::c_int,
                           arg3: *const ::std::os::raw::c_char, ...);
    pub fn rb_each(arg1: VALUE) -> VALUE;
    pub fn rb_yield(arg1: VALUE) -> VALUE;
    pub fn rb_yield_values(n: ::std::os::raw::c_int, ...) -> VALUE;
    pub fn rb_yield_values2(n: ::std::os::raw::c_int, argv: *const VALUE)
     -> VALUE;
    pub fn rb_yield_splat(arg1: VALUE) -> VALUE;
    pub fn rb_yield_block(arg1: VALUE, arg2: VALUE,
                          arg3: ::std::os::raw::c_int, arg4: *const VALUE,
                          arg5: VALUE) -> VALUE;
    pub fn rb_block_given_p() -> ::std::os::raw::c_int;
    pub fn rb_need_block();
    pub fn rb_iterate(arg1:
                          ::std::option::Option<extern "C" fn(arg1: VALUE)
                                                    -> VALUE>, arg2: VALUE,
                      arg3: ::std::option::Option<extern "C" fn() -> VALUE>,
                      arg4: VALUE) -> VALUE;
    pub fn rb_block_call(arg1: VALUE, arg2: ID, arg3: ::std::os::raw::c_int,
                         arg4: *const VALUE, arg5: rb_block_call_func_t,
                         arg6: VALUE) -> VALUE;
    pub fn rb_rescue(arg1: ::std::option::Option<extern "C" fn() -> VALUE>,
                     arg2: VALUE,
                     arg3: ::std::option::Option<extern "C" fn() -> VALUE>,
                     arg4: VALUE) -> VALUE;
    pub fn rb_rescue2(arg1: ::std::option::Option<extern "C" fn() -> VALUE>,
                      arg2: VALUE,
                      arg3: ::std::option::Option<extern "C" fn() -> VALUE>,
                      arg4: VALUE, ...) -> VALUE;
    pub fn rb_ensure(arg1: ::std::option::Option<extern "C" fn() -> VALUE>,
                     arg2: VALUE,
                     arg3: ::std::option::Option<extern "C" fn() -> VALUE>,
                     arg4: VALUE) -> VALUE;
    pub fn rb_catch(arg1: *const ::std::os::raw::c_char,
                    arg2: ::std::option::Option<extern "C" fn() -> VALUE>,
                    arg3: VALUE) -> VALUE;
    pub fn rb_catch_obj(arg1: VALUE,
                        arg2: ::std::option::Option<extern "C" fn() -> VALUE>,
                        arg3: VALUE) -> VALUE;
    pub fn rb_throw(arg1: *const ::std::os::raw::c_char, arg2: VALUE);
    pub fn rb_throw_obj(arg1: VALUE, arg2: VALUE);
    pub fn rb_require(arg1: *const ::std::os::raw::c_char) -> VALUE;
    pub fn st_init_table(arg1: *const Struct_st_hash_type) -> *mut st_table;
    pub fn st_init_table_with_size(arg1: *const Struct_st_hash_type,
                                   arg2: st_index_t) -> *mut st_table;
    pub fn st_init_numtable() -> *mut st_table;
    pub fn st_init_numtable_with_size(arg1: st_index_t) -> *mut st_table;
    pub fn st_init_strtable() -> *mut st_table;
    pub fn st_init_strtable_with_size(arg1: st_index_t) -> *mut st_table;
    pub fn st_init_strcasetable() -> *mut st_table;
    pub fn st_init_strcasetable_with_size(arg1: st_index_t) -> *mut st_table;
    pub fn st_delete(arg1: *mut st_table, arg2: *mut st_data_t,
                     arg3: *mut st_data_t) -> ::std::os::raw::c_int;
    pub fn st_delete_safe(arg1: *mut st_table, arg2: *mut st_data_t,
                          arg3: *mut st_data_t, arg4: st_data_t)
     -> ::std::os::raw::c_int;
    pub fn st_shift(arg1: *mut st_table, arg2: *mut st_data_t,
                    arg3: *mut st_data_t) -> ::std::os::raw::c_int;
    pub fn st_insert(arg1: *mut st_table, arg2: st_data_t, arg3: st_data_t)
     -> ::std::os::raw::c_int;
    pub fn st_insert2(arg1: *mut st_table, arg2: st_data_t, arg3: st_data_t,
                      arg4:
                          ::std::option::Option<extern "C" fn(arg1: st_data_t)
                                                    -> st_data_t>)
     -> ::std::os::raw::c_int;
    pub fn st_lookup(arg1: *mut st_table, arg2: st_data_t,
                     arg3: *mut st_data_t) -> ::std::os::raw::c_int;
    pub fn st_get_key(arg1: *mut st_table, arg2: st_data_t,
                      arg3: *mut st_data_t) -> ::std::os::raw::c_int;
    pub fn st_update(table: *mut st_table, key: st_data_t,
                     func:
                         *mut ::std::option::Option<extern "C" fn()
                                                        ->
                                                            ::std::os::raw::c_int>,
                     arg: st_data_t) -> ::std::os::raw::c_int;
    pub fn st_foreach(arg1: *mut st_table,
                      arg2:
                          ::std::option::Option<extern "C" fn()
                                                    -> ::std::os::raw::c_int>,
                      arg3: st_data_t) -> ::std::os::raw::c_int;
    pub fn st_foreach_check(arg1: *mut st_table,
                            arg2:
                                ::std::option::Option<extern "C" fn()
                                                          ->
                                                              ::std::os::raw::c_int>,
                            arg3: st_data_t, arg4: st_data_t)
     -> ::std::os::raw::c_int;
    pub fn st_reverse_foreach(arg1: *mut st_table,
                              arg2:
                                  ::std::option::Option<extern "C" fn()
                                                            ->
                                                                ::std::os::raw::c_int>,
                              arg3: st_data_t) -> ::std::os::raw::c_int;
    pub fn st_keys(table: *mut st_table, keys: *mut st_data_t,
                   size: st_index_t) -> st_index_t;
    pub fn st_keys_check(table: *mut st_table, keys: *mut st_data_t,
                         size: st_index_t, never: st_data_t) -> st_index_t;
    pub fn st_values(table: *mut st_table, values: *mut st_data_t,
                     size: st_index_t) -> st_index_t;
    pub fn st_values_check(table: *mut st_table, values: *mut st_data_t,
                           size: st_index_t, never: st_data_t) -> st_index_t;
    pub fn st_add_direct(arg1: *mut st_table, arg2: st_data_t,
                         arg3: st_data_t);
    pub fn st_free_table(arg1: *mut st_table);
    pub fn st_cleanup_safe(arg1: *mut st_table, arg2: st_data_t);
    pub fn st_clear(arg1: *mut st_table);
    pub fn st_copy(arg1: *mut st_table) -> *mut st_table;
    pub fn st_numcmp(arg1: st_data_t, arg2: st_data_t)
     -> ::std::os::raw::c_int;
    pub fn st_numhash(arg1: st_data_t) -> st_index_t;
    pub fn st_locale_insensitive_strcasecmp(s1: *const ::std::os::raw::c_char,
                                            s2: *const ::std::os::raw::c_char)
     -> ::std::os::raw::c_int;
    pub fn st_locale_insensitive_strncasecmp(s1:
                                                 *const ::std::os::raw::c_char,
                                             s2:
                                                 *const ::std::os::raw::c_char,
                                             n: size_t)
     -> ::std::os::raw::c_int;
    pub fn st_memsize(arg1: *const st_table) -> size_t;
    pub fn st_hash(ptr: *const ::std::os::raw::c_void, len: size_t,
                   h: st_index_t) -> st_index_t;
    pub fn st_hash_uint32(h: st_index_t, i: uint32_t) -> st_index_t;
    pub fn st_hash_uint(h: st_index_t, i: st_index_t) -> st_index_t;
    pub fn st_hash_end(h: st_index_t) -> st_index_t;
    pub fn st_hash_start(h: st_index_t) -> st_index_t;
    pub fn rb_mem_clear(arg1: *mut VALUE, arg2: ::std::os::raw::c_long);
    pub fn rb_assoc_new(arg1: VALUE, arg2: VALUE) -> VALUE;
    pub fn rb_check_array_type(arg1: VALUE) -> VALUE;
    pub fn rb_ary_new() -> VALUE;
    pub fn rb_ary_new_capa(capa: ::std::os::raw::c_long) -> VALUE;
    pub fn rb_ary_new_from_args(n: ::std::os::raw::c_long, ...) -> VALUE;
    pub fn rb_ary_new_from_values(n: ::std::os::raw::c_long,
                                  elts: *const VALUE) -> VALUE;
    pub fn rb_ary_tmp_new(arg1: ::std::os::raw::c_long) -> VALUE;
    pub fn rb_ary_free(arg1: VALUE);
    pub fn rb_ary_modify(arg1: VALUE);
    pub fn rb_ary_freeze(arg1: VALUE) -> VALUE;
    pub fn rb_ary_shared_with_p(arg1: VALUE, arg2: VALUE) -> VALUE;
    pub fn rb_ary_aref(arg1: ::std::os::raw::c_int, arg2: *mut VALUE,
                       arg3: VALUE) -> VALUE;
    pub fn rb_ary_subseq(arg1: VALUE, arg2: ::std::os::raw::c_long,
                         arg3: ::std::os::raw::c_long) -> VALUE;
    pub fn rb_ary_store(arg1: VALUE, arg2: ::std::os::raw::c_long,
                        arg3: VALUE);
    pub fn rb_ary_dup(arg1: VALUE) -> VALUE;
    pub fn rb_ary_resurrect(ary: VALUE) -> VALUE;
    pub fn rb_ary_to_ary(arg1: VALUE) -> VALUE;
    pub fn rb_ary_to_s(arg1: VALUE) -> VALUE;
    pub fn rb_ary_cat(arg1: VALUE, arg2: *const VALUE,
                      arg3: ::std::os::raw::c_long) -> VALUE;
    pub fn rb_ary_push(arg1: VALUE, arg2: VALUE) -> VALUE;
    pub fn rb_ary_pop(arg1: VALUE) -> VALUE;
    pub fn rb_ary_shift(arg1: VALUE) -> VALUE;
    pub fn rb_ary_unshift(arg1: VALUE, arg2: VALUE) -> VALUE;
    pub fn rb_ary_entry(arg1: VALUE, arg2: ::std::os::raw::c_long) -> VALUE;
    pub fn rb_ary_each(arg1: VALUE) -> VALUE;
    pub fn rb_ary_join(arg1: VALUE, arg2: VALUE) -> VALUE;
    pub fn rb_ary_reverse(arg1: VALUE) -> VALUE;
    pub fn rb_ary_rotate(arg1: VALUE, arg2: ::std::os::raw::c_long) -> VALUE;
    pub fn rb_ary_sort(arg1: VALUE) -> VALUE;
    pub fn rb_ary_sort_bang(arg1: VALUE) -> VALUE;
    pub fn rb_ary_delete(arg1: VALUE, arg2: VALUE) -> VALUE;
    pub fn rb_ary_delete_at(arg1: VALUE, arg2: ::std::os::raw::c_long)
     -> VALUE;
    pub fn rb_ary_clear(arg1: VALUE) -> VALUE;
    pub fn rb_ary_plus(arg1: VALUE, arg2: VALUE) -> VALUE;
    pub fn rb_ary_concat(arg1: VALUE, arg2: VALUE) -> VALUE;
    pub fn rb_ary_assoc(arg1: VALUE, arg2: VALUE) -> VALUE;
    pub fn rb_ary_rassoc(arg1: VALUE, arg2: VALUE) -> VALUE;
    pub fn rb_ary_includes(arg1: VALUE, arg2: VALUE) -> VALUE;
    pub fn rb_ary_cmp(arg1: VALUE, arg2: VALUE) -> VALUE;
    pub fn rb_ary_replace(copy: VALUE, orig: VALUE) -> VALUE;
    pub fn rb_get_values_at(arg1: VALUE, arg2: ::std::os::raw::c_long,
                            arg3: ::std::os::raw::c_int, arg4: *mut VALUE,
                            arg5:
                                ::std::option::Option<extern "C" fn(arg1:
                                                                        VALUE,
                                                                    arg2:
                                                                        ::std::os::raw::c_long)
                                                          -> VALUE>) -> VALUE;
    pub fn rb_ary_resize(ary: VALUE, len: ::std::os::raw::c_long) -> VALUE;
    pub fn rb_big_new(arg1: ::std::os::raw::c_long,
                      arg2: ::std::os::raw::c_int) -> VALUE;
    pub fn rb_bigzero_p(x: VALUE) -> ::std::os::raw::c_int;
    pub fn rb_big_clone(arg1: VALUE) -> VALUE;
    pub fn rb_big_2comp(arg1: VALUE);
    pub fn rb_big_norm(arg1: VALUE) -> VALUE;
    pub fn rb_big_resize(big: VALUE, len: ::std::os::raw::c_long);
    pub fn rb_cstr_to_inum(arg1: *const ::std::os::raw::c_char,
                           arg2: ::std::os::raw::c_int,
                           arg3: ::std::os::raw::c_int) -> VALUE;
    pub fn rb_str_to_inum(arg1: VALUE, arg2: ::std::os::raw::c_int,
                          arg3: ::std::os::raw::c_int) -> VALUE;
    pub fn rb_cstr2inum(arg1: *const ::std::os::raw::c_char,
                        arg2: ::std::os::raw::c_int) -> VALUE;
    pub fn rb_str2inum(arg1: VALUE, arg2: ::std::os::raw::c_int) -> VALUE;
    pub fn rb_big2str(arg1: VALUE, arg2: ::std::os::raw::c_int) -> VALUE;
    pub fn rb_big2str0(arg1: VALUE, arg2: ::std::os::raw::c_int,
                       arg3: ::std::os::raw::c_int) -> VALUE;
    pub fn rb_big2long(arg1: VALUE) -> ::std::os::raw::c_long;
    pub fn rb_big2ulong(arg1: VALUE) -> VALUE;
    pub fn rb_big2ulong_pack(x: VALUE) -> VALUE;
    pub fn rb_big2ll(arg1: VALUE) -> ::std::os::raw::c_longlong;
    pub fn rb_big2ull(arg1: VALUE) -> ::std::os::raw::c_ulonglong;
    pub fn rb_quad_pack(arg1: *mut ::std::os::raw::c_char, arg2: VALUE);
    pub fn rb_quad_unpack(arg1: *const ::std::os::raw::c_char,
                          arg2: ::std::os::raw::c_int) -> VALUE;
    pub fn rb_big_pack(val: VALUE, buf: *mut ::std::os::raw::c_ulong,
                       num_longs: ::std::os::raw::c_long);
    pub fn rb_big_unpack(buf: *mut ::std::os::raw::c_ulong,
                         num_longs: ::std::os::raw::c_long) -> VALUE;
    pub fn rb_uv_to_utf8(arg1: *mut ::std::os::raw::c_char,
                         arg2: ::std::os::raw::c_ulong)
     -> ::std::os::raw::c_int;
    pub fn rb_dbl2big(arg1: ::std::os::raw::c_double) -> VALUE;
    pub fn rb_big2dbl(arg1: VALUE) -> ::std::os::raw::c_double;
    pub fn rb_big_cmp(arg1: VALUE, arg2: VALUE) -> VALUE;
    pub fn rb_big_eq(arg1: VALUE, arg2: VALUE) -> VALUE;
    pub fn rb_big_eql(arg1: VALUE, arg2: VALUE) -> VALUE;
    pub fn rb_big_plus(arg1: VALUE, arg2: VALUE) -> VALUE;
    pub fn rb_big_minus(arg1: VALUE, arg2: VALUE) -> VALUE;
    pub fn rb_big_mul(arg1: VALUE, arg2: VALUE) -> VALUE;
    pub fn rb_big_div(arg1: VALUE, arg2: VALUE) -> VALUE;
    pub fn rb_big_idiv(arg1: VALUE, arg2: VALUE) -> VALUE;
    pub fn rb_big_modulo(arg1: VALUE, arg2: VALUE) -> VALUE;
    pub fn rb_big_divmod(arg1: VALUE, arg2: VALUE) -> VALUE;
    pub fn rb_big_pow(arg1: VALUE, arg2: VALUE) -> VALUE;
    pub fn rb_big_and(arg1: VALUE, arg2: VALUE) -> VALUE;
    pub fn rb_big_or(arg1: VALUE, arg2: VALUE) -> VALUE;
    pub fn rb_big_xor(arg1: VALUE, arg2: VALUE) -> VALUE;
    pub fn rb_big_lshift(arg1: VALUE, arg2: VALUE) -> VALUE;
    pub fn rb_big_rshift(arg1: VALUE, arg2: VALUE) -> VALUE;
    pub fn rb_integer_pack(val: VALUE, words: *mut ::std::os::raw::c_void,
                           numwords: size_t, wordsize: size_t, nails: size_t,
                           flags: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
    pub fn rb_integer_unpack(words: *const ::std::os::raw::c_void,
                             numwords: size_t, wordsize: size_t,
                             nails: size_t, flags: ::std::os::raw::c_int)
     -> VALUE;
    pub fn rb_absint_size(val: VALUE,
                          nlz_bits_ret: *mut ::std::os::raw::c_int) -> size_t;
    pub fn rb_absint_numwords(val: VALUE, word_numbits: size_t,
                              nlz_bits_ret: *mut size_t) -> size_t;
    pub fn rb_absint_singlebit_p(val: VALUE) -> ::std::os::raw::c_int;
    pub fn rb_rational_raw(arg1: VALUE, arg2: VALUE) -> VALUE;
    pub fn rb_rational_new(arg1: VALUE, arg2: VALUE) -> VALUE;
    pub fn rb_Rational(arg1: VALUE, arg2: VALUE) -> VALUE;
    pub fn rb_flt_rationalize_with_prec(arg1: VALUE, arg2: VALUE) -> VALUE;
    pub fn rb_flt_rationalize(arg1: VALUE) -> VALUE;
    pub fn rb_complex_raw(arg1: VALUE, arg2: VALUE) -> VALUE;
    pub fn rb_complex_new(arg1: VALUE, arg2: VALUE) -> VALUE;
    pub fn rb_complex_polar(arg1: VALUE, arg2: VALUE) -> VALUE;
    pub fn rb_Complex(arg1: VALUE, arg2: VALUE) -> VALUE;
    pub fn rb_class_boot(arg1: VALUE) -> VALUE;
    pub fn rb_class_new(arg1: VALUE) -> VALUE;
    pub fn rb_mod_init_copy(arg1: VALUE, arg2: VALUE) -> VALUE;
    pub fn rb_singleton_class_clone(arg1: VALUE) -> VALUE;
    pub fn rb_singleton_class_attached(arg1: VALUE, arg2: VALUE);
    pub fn rb_make_metaclass(arg1: VALUE, arg2: VALUE) -> VALUE;
    pub fn rb_check_inheritable(arg1: VALUE);
    pub fn rb_class_inherited(arg1: VALUE, arg2: VALUE) -> VALUE;
    pub fn rb_define_class_id(arg1: ID, arg2: VALUE) -> VALUE;
    pub fn rb_define_class_id_under(arg1: VALUE, arg2: ID, arg3: VALUE)
     -> VALUE;
    pub fn rb_module_new() -> VALUE;
    pub fn rb_define_module_id(arg1: ID) -> VALUE;
    pub fn rb_define_module_id_under(arg1: VALUE, arg2: ID) -> VALUE;
    pub fn rb_include_class_new(arg1: VALUE, arg2: VALUE) -> VALUE;
    pub fn rb_mod_included_modules(arg1: VALUE) -> VALUE;
    pub fn rb_mod_include_p(arg1: VALUE, arg2: VALUE) -> VALUE;
    pub fn rb_mod_ancestors(arg1: VALUE) -> VALUE;
    pub fn rb_class_instance_methods(arg1: ::std::os::raw::c_int,
                                     arg2: *mut VALUE, arg3: VALUE) -> VALUE;
    pub fn rb_class_public_instance_methods(arg1: ::std::os::raw::c_int,
                                            arg2: *mut VALUE, arg3: VALUE)
     -> VALUE;
    pub fn rb_class_protected_instance_methods(arg1: ::std::os::raw::c_int,
                                               arg2: *mut VALUE, arg3: VALUE)
     -> VALUE;
    pub fn rb_class_private_instance_methods(arg1: ::std::os::raw::c_int,
                                             arg2: *mut VALUE, arg3: VALUE)
     -> VALUE;
    pub fn rb_obj_singleton_methods(arg1: ::std::os::raw::c_int,
                                    arg2: *mut VALUE, arg3: VALUE) -> VALUE;
    pub fn rb_define_method_id(arg1: VALUE, arg2: ID,
                               arg3:
                                   ::std::option::Option<extern "C" fn()
                                                             -> VALUE>,
                               arg4: ::std::os::raw::c_int);
    pub fn rb_frozen_class_p(arg1: VALUE);
    pub fn rb_undef(arg1: VALUE, arg2: ID);
    pub fn rb_define_protected_method(arg1: VALUE,
                                      arg2: *const ::std::os::raw::c_char,
                                      arg3:
                                          ::std::option::Option<extern "C" fn()
                                                                    -> VALUE>,
                                      arg4: ::std::os::raw::c_int);
    pub fn rb_define_private_method(arg1: VALUE,
                                    arg2: *const ::std::os::raw::c_char,
                                    arg3:
                                        ::std::option::Option<extern "C" fn()
                                                                  -> VALUE>,
                                    arg4: ::std::os::raw::c_int);
    pub fn rb_define_singleton_method(arg1: VALUE,
                                      arg2: *const ::std::os::raw::c_char,
                                      arg3:
                                          ::std::option::Option<extern "C" fn()
                                                                    -> VALUE>,
                                      arg4: ::std::os::raw::c_int);
    pub fn rb_singleton_class(arg1: VALUE) -> VALUE;
    pub fn rb_cmpint(arg1: VALUE, arg2: VALUE, arg3: VALUE)
     -> ::std::os::raw::c_int;
    pub fn rb_cmperr(arg1: VALUE, arg2: VALUE);
    pub fn rb_fiber_new(arg1: ::std::option::Option<extern "C" fn() -> VALUE>,
                        arg2: VALUE) -> VALUE;
    pub fn rb_fiber_resume(fib: VALUE, argc: ::std::os::raw::c_int,
                           args: *mut VALUE) -> VALUE;
    pub fn rb_fiber_yield(argc: ::std::os::raw::c_int, args: *mut VALUE)
     -> VALUE;
    pub fn rb_fiber_current() -> VALUE;
    pub fn rb_fiber_alive_p(arg1: VALUE) -> VALUE;
    pub fn rb_enum_values_pack(arg1: ::std::os::raw::c_int,
                               arg2: *const VALUE) -> VALUE;
    pub fn rb_enumeratorize(arg1: VALUE, arg2: VALUE,
                            arg3: ::std::os::raw::c_int, arg4: *mut VALUE)
     -> VALUE;
    pub fn rb_enumeratorize_with_size(arg1: VALUE, arg2: VALUE,
                                      arg3: ::std::os::raw::c_int,
                                      arg4: *mut VALUE,
                                      arg5:
                                          *mut ::std::option::Option<extern "C" fn()
                                                                         ->
                                                                             VALUE>)
     -> VALUE;
    pub fn rb_exc_new(arg1: VALUE, arg2: *const ::std::os::raw::c_char,
                      arg3: ::std::os::raw::c_long) -> VALUE;
    pub fn rb_exc_new_cstr(arg1: VALUE, arg2: *const ::std::os::raw::c_char)
     -> VALUE;
    pub fn rb_exc_new_str(arg1: VALUE, arg2: VALUE) -> VALUE;
    pub fn rb_loaderror(arg1: *const ::std::os::raw::c_char, ...);
    pub fn rb_loaderror_with_path(path: VALUE,
                                  arg1: *const ::std::os::raw::c_char, ...);
    pub fn rb_name_error(arg1: ID, arg2: *const ::std::os::raw::c_char, ...);
    pub fn rb_name_error_str(arg1: VALUE,
                             arg2: *const ::std::os::raw::c_char, ...);
    pub fn rb_invalid_str(arg1: *const ::std::os::raw::c_char,
                          arg2: *const ::std::os::raw::c_char);
    pub fn rb_compile_error(arg1: *const ::std::os::raw::c_char,
                            arg2: ::std::os::raw::c_int,
                            arg3: *const ::std::os::raw::c_char, ...);
    pub fn rb_compile_error_with_enc(arg1: *const ::std::os::raw::c_char,
                                     arg2: ::std::os::raw::c_int,
                                     arg3: *mut ::std::os::raw::c_void,
                                     arg4:
                                         *const ::std::os::raw::c_char, ...);
    pub fn rb_compile_error_append(arg1: *const ::std::os::raw::c_char, ...);
    pub fn rb_error_frozen(arg1: *const ::std::os::raw::c_char);
    pub fn rb_error_untrusted(arg1: VALUE);
    pub fn rb_check_frozen(arg1: VALUE);
    pub fn rb_check_trusted(arg1: VALUE);
    pub fn rb_check_copyable(obj: VALUE, orig: VALUE);
    pub fn rb_sourceline() -> ::std::os::raw::c_int;
    pub fn rb_sourcefile() -> *const ::std::os::raw::c_char;
    pub fn rb_check_funcall(arg1: VALUE, arg2: ID,
                            arg3: ::std::os::raw::c_int, arg4: *const VALUE)
     -> VALUE;
    pub fn rb_error_arity(arg1: ::std::os::raw::c_int,
                          arg2: ::std::os::raw::c_int,
                          arg3: ::std::os::raw::c_int);
    pub fn rb_fd_init(arg1: *mut rb_fdset_t);
    pub fn rb_fd_term(arg1: *mut rb_fdset_t);
    pub fn rb_fd_zero(arg1: *mut rb_fdset_t);
    pub fn rb_fd_set(arg1: ::std::os::raw::c_int, arg2: *mut rb_fdset_t);
    pub fn rb_fd_clr(arg1: ::std::os::raw::c_int, arg2: *mut rb_fdset_t);
    pub fn rb_fd_isset(arg1: ::std::os::raw::c_int, arg2: *const rb_fdset_t)
     -> ::std::os::raw::c_int;
    pub fn rb_fd_copy(arg1: *mut rb_fdset_t, arg2: *const fd_set,
                      arg3: ::std::os::raw::c_int);
    pub fn rb_fd_dup(dst: *mut rb_fdset_t, src: *const rb_fdset_t);
    pub fn rb_fd_select(arg1: ::std::os::raw::c_int, arg2: *mut rb_fdset_t,
                        arg3: *mut rb_fdset_t, arg4: *mut rb_fdset_t,
                        arg5: *mut Struct_timeval) -> ::std::os::raw::c_int;
    pub fn rb_exc_raise(arg1: VALUE);
    pub fn rb_exc_fatal(arg1: VALUE);
    pub fn rb_f_exit(arg1: ::std::os::raw::c_int, arg2: *mut VALUE) -> VALUE;
    pub fn rb_f_abort(arg1: ::std::os::raw::c_int, arg2: *mut VALUE) -> VALUE;
    pub fn rb_remove_method(arg1: VALUE, arg2: *const ::std::os::raw::c_char);
    pub fn rb_remove_method_id(arg1: VALUE, arg2: ID);
    pub fn rb_define_alloc_func(arg1: VALUE, arg2: rb_alloc_func_t);
    pub fn rb_undef_alloc_func(arg1: VALUE);
    pub fn rb_get_alloc_func(arg1: VALUE) -> rb_alloc_func_t;
    pub fn rb_clear_cache();
    pub fn rb_clear_constant_cache();
    pub fn rb_clear_method_cache_by_class(arg1: VALUE);
    pub fn rb_alias(arg1: VALUE, arg2: ID, arg3: ID);
    pub fn rb_attr(arg1: VALUE, arg2: ID, arg3: ::std::os::raw::c_int,
                   arg4: ::std::os::raw::c_int, arg5: ::std::os::raw::c_int);
    pub fn rb_method_boundp(arg1: VALUE, arg2: ID,
                            arg3: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
    pub fn rb_method_basic_definition_p(arg1: VALUE, arg2: ID)
     -> ::std::os::raw::c_int;
    pub fn rb_eval_cmd(arg1: VALUE, arg2: VALUE, arg3: ::std::os::raw::c_int)
     -> VALUE;
    pub fn rb_obj_respond_to(arg1: VALUE, arg2: ID,
                             arg3: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
    pub fn rb_respond_to(arg1: VALUE, arg2: ID) -> ::std::os::raw::c_int;
    pub fn rb_f_notimplement(argc: ::std::os::raw::c_int, argv: *mut VALUE,
                             obj: VALUE) -> VALUE;
    pub fn rb_interrupt();
    pub fn rb_apply(arg1: VALUE, arg2: ID, arg3: VALUE) -> VALUE;
    pub fn rb_backtrace();
    pub fn rb_frame_this_func() -> ID;
    pub fn rb_obj_instance_eval(arg1: ::std::os::raw::c_int, arg2: *mut VALUE,
                                arg3: VALUE) -> VALUE;
    pub fn rb_obj_instance_exec(arg1: ::std::os::raw::c_int, arg2: *mut VALUE,
                                arg3: VALUE) -> VALUE;
    pub fn rb_mod_module_eval(arg1: ::std::os::raw::c_int, arg2: *mut VALUE,
                              arg3: VALUE) -> VALUE;
    pub fn rb_mod_module_exec(arg1: ::std::os::raw::c_int, arg2: *mut VALUE,
                              arg3: VALUE) -> VALUE;
    pub fn rb_load(arg1: VALUE, arg2: ::std::os::raw::c_int);
    pub fn rb_load_protect(arg1: VALUE, arg2: ::std::os::raw::c_int,
                           arg3: *mut ::std::os::raw::c_int);
    pub fn rb_jump_tag(arg1: ::std::os::raw::c_int);
    pub fn rb_provided(arg1: *const ::std::os::raw::c_char)
     -> ::std::os::raw::c_int;
    pub fn rb_feature_provided(arg1: *const ::std::os::raw::c_char,
                               arg2: *mut *const ::std::os::raw::c_char)
     -> ::std::os::raw::c_int;
    pub fn rb_provide(arg1: *const ::std::os::raw::c_char);
    pub fn rb_f_require(arg1: VALUE, arg2: VALUE) -> VALUE;
    pub fn rb_require_safe(arg1: VALUE, arg2: ::std::os::raw::c_int) -> VALUE;
    pub fn rb_obj_call_init(arg1: VALUE, arg2: ::std::os::raw::c_int,
                            arg3: *mut VALUE);
    pub fn rb_class_new_instance(arg1: ::std::os::raw::c_int,
                                 arg2: *mut VALUE, arg3: VALUE) -> VALUE;
    pub fn rb_block_proc() -> VALUE;
    pub fn rb_block_lambda() -> VALUE;
    pub fn rb_proc_new(arg1: ::std::option::Option<extern "C" fn() -> VALUE>,
                       arg2: VALUE) -> VALUE;
    pub fn rb_obj_is_proc(arg1: VALUE) -> VALUE;
    pub fn rb_proc_call(arg1: VALUE, arg2: VALUE) -> VALUE;
    pub fn rb_proc_call_with_block(arg1: VALUE, argc: ::std::os::raw::c_int,
                                   argv: *const VALUE, arg2: VALUE) -> VALUE;
    pub fn rb_proc_arity(arg1: VALUE) -> ::std::os::raw::c_int;
    pub fn rb_proc_lambda_p(arg1: VALUE) -> VALUE;
    pub fn rb_binding_new() -> VALUE;
    pub fn rb_obj_method(arg1: VALUE, arg2: VALUE) -> VALUE;
    pub fn rb_obj_is_method(arg1: VALUE) -> VALUE;
    pub fn rb_method_call(arg1: ::std::os::raw::c_int, arg2: *mut VALUE,
                          arg3: VALUE) -> VALUE;
    pub fn rb_method_call_with_block(arg1: ::std::os::raw::c_int,
                                     arg2: *mut VALUE, arg3: VALUE,
                                     arg4: VALUE) -> VALUE;
    pub fn rb_mod_method_arity(arg1: VALUE, arg2: ID)
     -> ::std::os::raw::c_int;
    pub fn rb_obj_method_arity(arg1: VALUE, arg2: ID)
     -> ::std::os::raw::c_int;
    pub fn rb_protect(arg1:
                          ::std::option::Option<extern "C" fn(arg1: VALUE)
                                                    -> VALUE>, arg2: VALUE,
                      arg3: *mut ::std::os::raw::c_int) -> VALUE;
    pub fn rb_set_end_proc(arg1:
                               ::std::option::Option<extern "C" fn(arg1:
                                                                       VALUE)>,
                           arg2: VALUE);
    pub fn rb_exec_end_proc();
    pub fn rb_thread_schedule();
    pub fn rb_thread_wait_fd(arg1: ::std::os::raw::c_int);
    pub fn rb_thread_fd_writable(arg1: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
    pub fn rb_thread_fd_close(arg1: ::std::os::raw::c_int);
    pub fn rb_thread_alone() -> ::std::os::raw::c_int;
    pub fn rb_thread_polling();
    pub fn rb_thread_sleep(arg1: ::std::os::raw::c_int);
    pub fn rb_thread_sleep_forever();
    pub fn rb_thread_sleep_deadly();
    pub fn rb_thread_stop() -> VALUE;
    pub fn rb_thread_wakeup(arg1: VALUE) -> VALUE;
    pub fn rb_thread_wakeup_alive(arg1: VALUE) -> VALUE;
    pub fn rb_thread_run(arg1: VALUE) -> VALUE;
    pub fn rb_thread_kill(arg1: VALUE) -> VALUE;
    pub fn rb_thread_create(arg1:
                                ::std::option::Option<extern "C" fn()
                                                          -> VALUE>,
                            arg2: *mut ::std::os::raw::c_void) -> VALUE;
    pub fn rb_thread_select(arg1: ::std::os::raw::c_int, arg2: *mut fd_set,
                            arg3: *mut fd_set, arg4: *mut fd_set,
                            arg5: *mut Struct_timeval)
     -> ::std::os::raw::c_int;
    pub fn rb_thread_fd_select(arg1: ::std::os::raw::c_int,
                               arg2: *mut rb_fdset_t, arg3: *mut rb_fdset_t,
                               arg4: *mut rb_fdset_t,
                               arg5: *mut Struct_timeval)
     -> ::std::os::raw::c_int;
    pub fn rb_thread_wait_for(arg1: Struct_timeval);
    pub fn rb_thread_current() -> VALUE;
    pub fn rb_thread_main() -> VALUE;
    pub fn rb_thread_local_aref(arg1: VALUE, arg2: ID) -> VALUE;
    pub fn rb_thread_local_aset(arg1: VALUE, arg2: ID, arg3: VALUE) -> VALUE;
    pub fn rb_thread_atfork();
    pub fn rb_thread_atfork_before_exec();
    pub fn rb_exec_recursive(arg1:
                                 ::std::option::Option<extern "C" fn(arg1:
                                                                         VALUE,
                                                                     arg2:
                                                                         VALUE,
                                                                     arg3:
                                                                         ::std::os::raw::c_int)
                                                           -> VALUE>,
                             arg2: VALUE, arg3: VALUE) -> VALUE;
    pub fn rb_exec_recursive_paired(arg1:
                                        ::std::option::Option<extern "C" fn(arg1:
                                                                                VALUE,
                                                                            arg2:
                                                                                VALUE,
                                                                            arg3:
                                                                                ::std::os::raw::c_int)
                                                                  -> VALUE>,
                                    arg2: VALUE, arg3: VALUE, arg4: VALUE)
     -> VALUE;
    pub fn rb_exec_recursive_outer(arg1:
                                       ::std::option::Option<extern "C" fn(arg1:
                                                                               VALUE,
                                                                           arg2:
                                                                               VALUE,
                                                                           arg3:
                                                                               ::std::os::raw::c_int)
                                                                 -> VALUE>,
                                   arg2: VALUE, arg3: VALUE) -> VALUE;
    pub fn rb_exec_recursive_paired_outer(arg1:
                                              ::std::option::Option<extern "C" fn(arg1:
                                                                                      VALUE,
                                                                                  arg2:
                                                                                      VALUE,
                                                                                  arg3:
                                                                                      ::std::os::raw::c_int)
                                                                        ->
                                                                            VALUE>,
                                          arg2: VALUE, arg3: VALUE,
                                          arg4: VALUE) -> VALUE;
    pub fn rb_dir_getwd() -> VALUE;
    pub fn rb_file_s_expand_path(arg1: ::std::os::raw::c_int,
                                 arg2: *mut VALUE) -> VALUE;
    pub fn rb_file_expand_path(arg1: VALUE, arg2: VALUE) -> VALUE;
    pub fn rb_file_s_absolute_path(arg1: ::std::os::raw::c_int,
                                   arg2: *mut VALUE) -> VALUE;
    pub fn rb_file_absolute_path(arg1: VALUE, arg2: VALUE) -> VALUE;
    pub fn rb_file_dirname(fname: VALUE) -> VALUE;
    pub fn rb_find_file_ext_safe(arg1: *mut VALUE,
                                 arg2: *const *const ::std::os::raw::c_char,
                                 arg3: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
    pub fn rb_find_file_safe(arg1: VALUE, arg2: ::std::os::raw::c_int)
     -> VALUE;
    pub fn rb_find_file_ext(arg1: *mut VALUE,
                            arg2: *const *const ::std::os::raw::c_char)
     -> ::std::os::raw::c_int;
    pub fn rb_find_file(arg1: VALUE) -> VALUE;
    pub fn rb_file_directory_p(arg1: VALUE, arg2: VALUE) -> VALUE;
    pub fn rb_str_encode_ospath(arg1: VALUE) -> VALUE;
    pub fn rb_is_absolute_path(arg1: *const ::std::os::raw::c_char)
     -> ::std::os::raw::c_int;
    pub fn rb_memerror();
    pub fn rb_during_gc() -> ::std::os::raw::c_int;
    pub fn rb_gc_mark_locations(arg1: *mut VALUE, arg2: *mut VALUE);
    pub fn rb_mark_tbl(arg1: *mut Struct_st_table);
    pub fn rb_mark_set(arg1: *mut Struct_st_table);
    pub fn rb_mark_hash(arg1: *mut Struct_st_table);
    pub fn rb_gc_mark_maybe(arg1: VALUE);
    pub fn rb_gc_mark(arg1: VALUE);
    pub fn rb_gc_force_recycle(arg1: VALUE);
    pub fn rb_gc();
    pub fn rb_gc_copy_finalizer(arg1: VALUE, arg2: VALUE);
    pub fn rb_gc_finalize_deferred();
    pub fn rb_gc_call_finalizer_at_exit();
    pub fn rb_gc_enable() -> VALUE;
    pub fn rb_gc_disable() -> VALUE;
    pub fn rb_gc_start() -> VALUE;
    pub fn rb_gc_set_params();
    pub fn rb_define_finalizer(arg1: VALUE, arg2: VALUE) -> VALUE;
    pub fn rb_undefine_finalizer(arg1: VALUE) -> VALUE;
    pub fn rb_gc_count() -> size_t;
    pub fn rb_gc_stat(arg1: VALUE) -> size_t;
    pub fn rb_gc_latest_gc_info(arg1: VALUE) -> VALUE;
    pub fn st_foreach_safe(arg1: *mut Struct_st_table,
                           arg2:
                               ::std::option::Option<extern "C" fn()
                                                         ->
                                                             ::std::os::raw::c_int>,
                           arg3: st_data_t);
    pub fn rb_check_hash_type(arg1: VALUE) -> VALUE;
    pub fn rb_hash_foreach(arg1: VALUE,
                           arg2:
                               ::std::option::Option<extern "C" fn()
                                                         ->
                                                             ::std::os::raw::c_int>,
                           arg3: VALUE);
    pub fn rb_hash(arg1: VALUE) -> VALUE;
    pub fn rb_hash_new() -> VALUE;
    pub fn rb_hash_dup(arg1: VALUE) -> VALUE;
    pub fn rb_hash_freeze(arg1: VALUE) -> VALUE;
    pub fn rb_hash_aref(arg1: VALUE, arg2: VALUE) -> VALUE;
    pub fn rb_hash_lookup(arg1: VALUE, arg2: VALUE) -> VALUE;
    pub fn rb_hash_lookup2(arg1: VALUE, arg2: VALUE, arg3: VALUE) -> VALUE;
    pub fn rb_hash_fetch(arg1: VALUE, arg2: VALUE) -> VALUE;
    pub fn rb_hash_aset(arg1: VALUE, arg2: VALUE, arg3: VALUE) -> VALUE;
    pub fn rb_hash_clear(arg1: VALUE) -> VALUE;
    pub fn rb_hash_delete_if(arg1: VALUE) -> VALUE;
    pub fn rb_hash_delete(arg1: VALUE, arg2: VALUE) -> VALUE;
    pub fn rb_hash_set_ifnone(hash: VALUE, ifnone: VALUE) -> VALUE;
    pub fn rb_hash_update_by(hash1: VALUE, hash2: VALUE,
                             func:
                                 *mut ::std::option::Option<extern "C" fn()
                                                                -> VALUE>)
     -> VALUE;
    pub fn rb_hash_tbl(arg1: VALUE) -> *mut Struct_st_table;
    pub fn rb_path_check(arg1: *const ::std::os::raw::c_char)
     -> ::std::os::raw::c_int;
    pub fn rb_env_path_tainted() -> ::std::os::raw::c_int;
    pub fn rb_env_clear() -> VALUE;
    pub fn rb_io_write(arg1: VALUE, arg2: VALUE) -> VALUE;
    pub fn rb_io_gets(arg1: VALUE) -> VALUE;
    pub fn rb_io_getbyte(arg1: VALUE) -> VALUE;
    pub fn rb_io_ungetc(arg1: VALUE, arg2: VALUE) -> VALUE;
    pub fn rb_io_ungetbyte(arg1: VALUE, arg2: VALUE) -> VALUE;
    pub fn rb_io_close(arg1: VALUE) -> VALUE;
    pub fn rb_io_flush(arg1: VALUE) -> VALUE;
    pub fn rb_io_eof(arg1: VALUE) -> VALUE;
    pub fn rb_io_binmode(arg1: VALUE) -> VALUE;
    pub fn rb_io_ascii8bit_binmode(arg1: VALUE) -> VALUE;
    pub fn rb_io_addstr(arg1: VALUE, arg2: VALUE) -> VALUE;
    pub fn rb_io_printf(arg1: ::std::os::raw::c_int, arg2: *mut VALUE,
                        arg3: VALUE) -> VALUE;
    pub fn rb_io_print(arg1: ::std::os::raw::c_int, arg2: *mut VALUE,
                       arg3: VALUE) -> VALUE;
    pub fn rb_io_puts(arg1: ::std::os::raw::c_int, arg2: *mut VALUE,
                      arg3: VALUE) -> VALUE;
    pub fn rb_io_fdopen(arg1: ::std::os::raw::c_int,
                        arg2: ::std::os::raw::c_int,
                        arg3: *const ::std::os::raw::c_char) -> VALUE;
    pub fn rb_io_get_io(arg1: VALUE) -> VALUE;
    pub fn rb_file_open(arg1: *const ::std::os::raw::c_char,
                        arg2: *const ::std::os::raw::c_char) -> VALUE;
    pub fn rb_file_open_str(arg1: VALUE, arg2: *const ::std::os::raw::c_char)
     -> VALUE;
    pub fn rb_gets() -> VALUE;
    pub fn rb_write_error(arg1: *const ::std::os::raw::c_char);
    pub fn rb_write_error2(arg1: *const ::std::os::raw::c_char,
                           arg2: ::std::os::raw::c_long);
    pub fn rb_close_before_exec(lowfd: ::std::os::raw::c_int,
                                maxhint: ::std::os::raw::c_int,
                                noclose_fds: VALUE);
    pub fn rb_pipe(pipes: *mut ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
    pub fn rb_reserved_fd_p(fd: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
    pub fn rb_cloexec_open(pathname: *const ::std::os::raw::c_char,
                           flags: ::std::os::raw::c_int, mode: mode_t)
     -> ::std::os::raw::c_int;
    pub fn rb_cloexec_dup(oldfd: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
    pub fn rb_cloexec_dup2(oldfd: ::std::os::raw::c_int,
                           newfd: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
    pub fn rb_cloexec_pipe(fildes: *mut ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
    pub fn rb_cloexec_fcntl_dupfd(fd: ::std::os::raw::c_int,
                                  minfd: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
    pub fn rb_update_max_fd(fd: ::std::os::raw::c_int);
    pub fn rb_fd_fix_cloexec(fd: ::std::os::raw::c_int);
    pub fn rb_marshal_dump(arg1: VALUE, arg2: VALUE) -> VALUE;
    pub fn rb_marshal_load(arg1: VALUE) -> VALUE;
    pub fn rb_marshal_define_compat(newclass: VALUE, oldclass: VALUE,
                                    dumper:
                                        ::std::option::Option<extern "C" fn(arg1:
                                                                                VALUE)
                                                                  -> VALUE>,
                                    loader:
                                        ::std::option::Option<extern "C" fn(arg1:
                                                                                VALUE,
                                                                            arg2:
                                                                                VALUE)
                                                                  -> VALUE>);
    pub fn rb_num_zerodiv();
    pub fn rb_num_coerce_bin(arg1: VALUE, arg2: VALUE, arg3: ID) -> VALUE;
    pub fn rb_num_coerce_cmp(arg1: VALUE, arg2: VALUE, arg3: ID) -> VALUE;
    pub fn rb_num_coerce_relop(arg1: VALUE, arg2: VALUE, arg3: ID) -> VALUE;
    pub fn rb_num_coerce_bit(arg1: VALUE, arg2: VALUE, arg3: ID) -> VALUE;
    pub fn rb_num2fix(arg1: VALUE) -> VALUE;
    pub fn rb_fix2str(arg1: VALUE, arg2: ::std::os::raw::c_int) -> VALUE;
    pub fn rb_dbl_cmp(arg1: ::std::os::raw::c_double,
                      arg2: ::std::os::raw::c_double) -> VALUE;
    pub fn rb_eql(arg1: VALUE, arg2: VALUE) -> ::std::os::raw::c_int;
    pub fn rb_any_to_s(arg1: VALUE) -> VALUE;
    pub fn rb_inspect(arg1: VALUE) -> VALUE;
    pub fn rb_obj_is_instance_of(arg1: VALUE, arg2: VALUE) -> VALUE;
    pub fn rb_obj_is_kind_of(arg1: VALUE, arg2: VALUE) -> VALUE;
    pub fn rb_obj_alloc(arg1: VALUE) -> VALUE;
    pub fn rb_obj_clone(arg1: VALUE) -> VALUE;
    pub fn rb_obj_dup(arg1: VALUE) -> VALUE;
    pub fn rb_obj_init_copy(arg1: VALUE, arg2: VALUE) -> VALUE;
    pub fn rb_obj_taint(arg1: VALUE) -> VALUE;
    pub fn rb_obj_tainted(arg1: VALUE) -> VALUE;
    pub fn rb_obj_untaint(arg1: VALUE) -> VALUE;
    pub fn rb_obj_untrust(arg1: VALUE) -> VALUE;
    pub fn rb_obj_untrusted(arg1: VALUE) -> VALUE;
    pub fn rb_obj_trust(arg1: VALUE) -> VALUE;
    pub fn rb_obj_freeze(arg1: VALUE) -> VALUE;
    pub fn rb_obj_frozen_p(arg1: VALUE) -> VALUE;
    pub fn rb_obj_id(arg1: VALUE) -> VALUE;
    pub fn rb_obj_class(arg1: VALUE) -> VALUE;
    pub fn rb_class_real(arg1: VALUE) -> VALUE;
    pub fn rb_class_inherited_p(arg1: VALUE, arg2: VALUE) -> VALUE;
    pub fn rb_class_superclass(arg1: VALUE) -> VALUE;
    pub fn rb_class_get_superclass(arg1: VALUE) -> VALUE;
    pub fn rb_convert_type(arg1: VALUE, arg2: ::std::os::raw::c_int,
                           arg3: *const ::std::os::raw::c_char,
                           arg4: *const ::std::os::raw::c_char) -> VALUE;
    pub fn rb_check_convert_type(arg1: VALUE, arg2: ::std::os::raw::c_int,
                                 arg3: *const ::std::os::raw::c_char,
                                 arg4: *const ::std::os::raw::c_char)
     -> VALUE;
    pub fn rb_check_to_integer(arg1: VALUE,
                               arg2: *const ::std::os::raw::c_char) -> VALUE;
    pub fn rb_check_to_float(arg1: VALUE) -> VALUE;
    pub fn rb_to_int(arg1: VALUE) -> VALUE;
    pub fn rb_check_to_int(arg1: VALUE) -> VALUE;
    pub fn rb_Integer(arg1: VALUE) -> VALUE;
    pub fn rb_to_float(arg1: VALUE) -> VALUE;
    pub fn rb_Float(arg1: VALUE) -> VALUE;
    pub fn rb_String(arg1: VALUE) -> VALUE;
    pub fn rb_Array(arg1: VALUE) -> VALUE;
    pub fn rb_Hash(arg1: VALUE) -> VALUE;
    pub fn rb_cstr_to_dbl(arg1: *const ::std::os::raw::c_char,
                          arg2: ::std::os::raw::c_int)
     -> ::std::os::raw::c_double;
    pub fn rb_str_to_dbl(arg1: VALUE, arg2: ::std::os::raw::c_int)
     -> ::std::os::raw::c_double;
    pub fn rb_id_attrset(arg1: ID) -> ID;
    pub fn rb_is_const_id(arg1: ID) -> ::std::os::raw::c_int;
    pub fn rb_is_global_id(arg1: ID) -> ::std::os::raw::c_int;
    pub fn rb_is_instance_id(arg1: ID) -> ::std::os::raw::c_int;
    pub fn rb_is_attrset_id(arg1: ID) -> ::std::os::raw::c_int;
    pub fn rb_is_class_id(arg1: ID) -> ::std::os::raw::c_int;
    pub fn rb_is_local_id(arg1: ID) -> ::std::os::raw::c_int;
    pub fn rb_is_junk_id(arg1: ID) -> ::std::os::raw::c_int;
    pub fn rb_symname_p(arg1: *const ::std::os::raw::c_char)
     -> ::std::os::raw::c_int;
    pub fn rb_sym_interned_p(arg1: VALUE) -> ::std::os::raw::c_int;
    pub fn rb_backref_get() -> VALUE;
    pub fn rb_backref_set(arg1: VALUE);
    pub fn rb_lastline_get() -> VALUE;
    pub fn rb_lastline_set(arg1: VALUE);
    pub fn rb_sym_all_symbols() -> VALUE;
    pub fn rb_last_status_set(status: ::std::os::raw::c_int, pid: pid_t);
    pub fn rb_last_status_get() -> VALUE;
    pub fn rb_proc_exec_n(arg1: ::std::os::raw::c_int, arg2: *mut VALUE,
                          arg3: *const ::std::os::raw::c_char)
     -> ::std::os::raw::c_int;
    pub fn rb_proc_exec(arg1: *const ::std::os::raw::c_char)
     -> ::std::os::raw::c_int;
    pub fn rb_exec_arg_init(argc: ::std::os::raw::c_int, argv: *mut VALUE,
                            accept_shell: ::std::os::raw::c_int,
                            e: *mut Struct_rb_exec_arg) -> VALUE;
    pub fn rb_exec_arg_addopt(e: *mut Struct_rb_exec_arg, key: VALUE,
                              val: VALUE) -> ::std::os::raw::c_int;
    pub fn rb_exec_arg_fixup(e: *mut Struct_rb_exec_arg);
    pub fn rb_run_exec_options(e: *const Struct_rb_exec_arg,
                               s: *mut Struct_rb_exec_arg)
     -> ::std::os::raw::c_int;
    pub fn rb_run_exec_options_err(e: *const Struct_rb_exec_arg,
                                   s: *mut Struct_rb_exec_arg,
                                   arg1: *mut ::std::os::raw::c_char,
                                   arg2: size_t) -> ::std::os::raw::c_int;
    pub fn rb_exec(arg1: *const Struct_rb_exec_arg) -> ::std::os::raw::c_int;
    pub fn rb_exec_err(arg1: *const Struct_rb_exec_arg,
                       arg2: *mut ::std::os::raw::c_char, arg3: size_t)
     -> ::std::os::raw::c_int;
    pub fn rb_fork(arg1: *mut ::std::os::raw::c_int,
                   arg2:
                       ::std::option::Option<unsafe extern "C" fn(arg1:
                                                                      *mut ::std::os::raw::c_void)
                                                 -> ::std::os::raw::c_int>,
                   arg3: *mut ::std::os::raw::c_void, arg4: VALUE) -> pid_t;
    pub fn rb_fork_err(arg1: *mut ::std::os::raw::c_int,
                       arg2:
                           ::std::option::Option<unsafe extern "C" fn(arg1:
                                                                          *mut ::std::os::raw::c_void,
                                                                      arg2:
                                                                          *mut ::std::os::raw::c_char,
                                                                      arg3:
                                                                          size_t)
                                                     ->
                                                         ::std::os::raw::c_int>,
                       arg3: *mut ::std::os::raw::c_void, arg4: VALUE,
                       arg5: *mut ::std::os::raw::c_char, arg6: size_t)
     -> pid_t;
    pub fn rb_f_exec(arg1: ::std::os::raw::c_int, arg2: *mut VALUE) -> VALUE;
    pub fn rb_waitpid(pid: pid_t, status: *mut ::std::os::raw::c_int,
                      flags: ::std::os::raw::c_int) -> pid_t;
    pub fn rb_syswait(pid: pid_t);
    pub fn rb_spawn(arg1: ::std::os::raw::c_int, arg2: *mut VALUE) -> pid_t;
    pub fn rb_spawn_err(arg1: ::std::os::raw::c_int, arg2: *mut VALUE,
                        arg3: *mut ::std::os::raw::c_char, arg4: size_t)
     -> pid_t;
    pub fn rb_proc_times(arg1: VALUE) -> VALUE;
    pub fn rb_detach_process(pid: pid_t) -> VALUE;
    pub fn rb_range_new(arg1: VALUE, arg2: VALUE, arg3: ::std::os::raw::c_int)
     -> VALUE;
    pub fn rb_range_beg_len(arg1: VALUE, arg2: *mut ::std::os::raw::c_long,
                            arg3: *mut ::std::os::raw::c_long,
                            arg4: ::std::os::raw::c_long,
                            arg5: ::std::os::raw::c_int) -> VALUE;
    pub fn rb_range_values(range: VALUE, begp: *mut VALUE, endp: *mut VALUE,
                           exclp: *mut ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
    pub fn rb_genrand_int32() -> ::std::os::raw::c_uint;
    pub fn rb_genrand_real() -> ::std::os::raw::c_double;
    pub fn rb_reset_random_seed();
    pub fn rb_random_bytes(rnd: VALUE, n: ::std::os::raw::c_long) -> VALUE;
    pub fn rb_random_int(rnd: VALUE, max: VALUE) -> VALUE;
    pub fn rb_random_int32(rnd: VALUE) -> ::std::os::raw::c_uint;
    pub fn rb_random_real(rnd: VALUE) -> ::std::os::raw::c_double;
    pub fn rb_random_ulong_limited(rnd: VALUE, limit: ::std::os::raw::c_ulong)
     -> ::std::os::raw::c_ulong;
    pub fn rb_genrand_ulong_limited(i: ::std::os::raw::c_ulong)
     -> ::std::os::raw::c_ulong;
    pub fn rb_memcicmp(arg1: *const ::std::os::raw::c_void,
                       arg2: *const ::std::os::raw::c_void,
                       arg3: ::std::os::raw::c_long) -> ::std::os::raw::c_int;
    pub fn rb_match_busy(arg1: VALUE);
    pub fn rb_reg_nth_defined(arg1: ::std::os::raw::c_int, arg2: VALUE)
     -> VALUE;
    pub fn rb_reg_nth_match(arg1: ::std::os::raw::c_int, arg2: VALUE)
     -> VALUE;
    pub fn rb_reg_backref_number(_match: VALUE, backref: VALUE)
     -> ::std::os::raw::c_int;
    pub fn rb_reg_last_match(arg1: VALUE) -> VALUE;
    pub fn rb_reg_match_pre(arg1: VALUE) -> VALUE;
    pub fn rb_reg_match_post(arg1: VALUE) -> VALUE;
    pub fn rb_reg_match_last(arg1: VALUE) -> VALUE;
    pub fn rb_reg_new_str(arg1: VALUE, arg2: ::std::os::raw::c_int) -> VALUE;
    pub fn rb_reg_new(arg1: *const ::std::os::raw::c_char,
                      arg2: ::std::os::raw::c_long,
                      arg3: ::std::os::raw::c_int) -> VALUE;
    pub fn rb_reg_alloc() -> VALUE;
    pub fn rb_reg_init_str(re: VALUE, s: VALUE,
                           options: ::std::os::raw::c_int) -> VALUE;
    pub fn rb_reg_match(arg1: VALUE, arg2: VALUE) -> VALUE;
    pub fn rb_reg_match2(arg1: VALUE) -> VALUE;
    pub fn rb_reg_options(arg1: VALUE) -> ::std::os::raw::c_int;
    pub fn rb_get_argv() -> VALUE;
    pub fn rb_load_file(arg1: *const ::std::os::raw::c_char)
     -> *mut ::std::os::raw::c_void;
    pub fn rb_load_file_str(arg1: VALUE) -> *mut ::std::os::raw::c_void;
    pub fn rb_f_kill(arg1: ::std::os::raw::c_int, arg2: *mut VALUE) -> VALUE;
    pub fn ruby_posix_signal(arg1: ::std::os::raw::c_int,
                             arg2:
                                 ::std::option::Option<extern "C" fn(arg1:
                                                                         ::std::os::raw::c_int)>)
     ->
         ::std::option::Option<extern "C" fn(arg1: ::std::os::raw::c_int,
                                             arg2:
                                                 ::std::option::Option<extern "C" fn(arg1:
                                                                                         ::std::os::raw::c_int)>)>;
    pub fn rb_trap_exit();
    pub fn rb_trap_exec();
    pub fn ruby_signal_name(arg1: ::std::os::raw::c_int)
     -> *const ::std::os::raw::c_char;
    pub fn ruby_default_signal(arg1: ::std::os::raw::c_int);
    pub fn rb_f_sprintf(arg1: ::std::os::raw::c_int, arg2: *const VALUE)
     -> VALUE;
    pub fn rb_sprintf(arg1: *const ::std::os::raw::c_char, ...) -> VALUE;
    pub fn rb_vsprintf(arg1: *const ::std::os::raw::c_char, arg2: va_list)
     -> VALUE;
    pub fn rb_str_catf(arg1: VALUE, arg2: *const ::std::os::raw::c_char, ...)
     -> VALUE;
    pub fn rb_str_vcatf(arg1: VALUE, arg2: *const ::std::os::raw::c_char,
                        arg3: va_list) -> VALUE;
    pub fn rb_str_format(arg1: ::std::os::raw::c_int, arg2: *const VALUE,
                         arg3: VALUE) -> VALUE;
    pub fn rb_str_new(arg1: *const ::std::os::raw::c_char,
                      arg2: ::std::os::raw::c_long) -> VALUE;
    pub fn rb_str_new_cstr(arg1: *const ::std::os::raw::c_char) -> VALUE;
    pub fn rb_str_new_shared(arg1: VALUE) -> VALUE;
    pub fn rb_str_new_frozen(arg1: VALUE) -> VALUE;
    pub fn rb_str_new_with_class(arg1: VALUE,
                                 arg2: *const ::std::os::raw::c_char,
                                 arg3: ::std::os::raw::c_long) -> VALUE;
    pub fn rb_tainted_str_new_cstr(arg1: *const ::std::os::raw::c_char)
     -> VALUE;
    pub fn rb_tainted_str_new(arg1: *const ::std::os::raw::c_char,
                              arg2: ::std::os::raw::c_long) -> VALUE;
    pub fn rb_external_str_new(arg1: *const ::std::os::raw::c_char,
                               arg2: ::std::os::raw::c_long) -> VALUE;
    pub fn rb_external_str_new_cstr(arg1: *const ::std::os::raw::c_char)
     -> VALUE;
    pub fn rb_locale_str_new(arg1: *const ::std::os::raw::c_char,
                             arg2: ::std::os::raw::c_long) -> VALUE;
    pub fn rb_locale_str_new_cstr(arg1: *const ::std::os::raw::c_char)
     -> VALUE;
    pub fn rb_filesystem_str_new(arg1: *const ::std::os::raw::c_char,
                                 arg2: ::std::os::raw::c_long) -> VALUE;
    pub fn rb_filesystem_str_new_cstr(arg1: *const ::std::os::raw::c_char)
     -> VALUE;
    pub fn rb_str_buf_new(arg1: ::std::os::raw::c_long) -> VALUE;
    pub fn rb_str_buf_new_cstr(arg1: *const ::std::os::raw::c_char) -> VALUE;
    pub fn rb_str_buf_new2(arg1: *const ::std::os::raw::c_char) -> VALUE;
    pub fn rb_str_tmp_new(arg1: ::std::os::raw::c_long) -> VALUE;
    pub fn rb_usascii_str_new(arg1: *const ::std::os::raw::c_char,
                              arg2: ::std::os::raw::c_long) -> VALUE;
    pub fn rb_usascii_str_new_cstr(arg1: *const ::std::os::raw::c_char)
     -> VALUE;
    pub fn rb_str_free(arg1: VALUE);
    pub fn rb_str_shared_replace(arg1: VALUE, arg2: VALUE);
    pub fn rb_str_buf_append(arg1: VALUE, arg2: VALUE) -> VALUE;
    pub fn rb_str_buf_cat(arg1: VALUE, arg2: *const ::std::os::raw::c_char,
                          arg3: ::std::os::raw::c_long) -> VALUE;
    pub fn rb_str_buf_cat2(arg1: VALUE, arg2: *const ::std::os::raw::c_char)
     -> VALUE;
    pub fn rb_str_buf_cat_ascii(arg1: VALUE,
                                arg2: *const ::std::os::raw::c_char) -> VALUE;
    pub fn rb_obj_as_string(arg1: VALUE) -> VALUE;
    pub fn rb_check_string_type(arg1: VALUE) -> VALUE;
    pub fn rb_must_asciicompat(arg1: VALUE);
    pub fn rb_str_dup(arg1: VALUE) -> VALUE;
    pub fn rb_str_resurrect(str: VALUE) -> VALUE;
    pub fn rb_str_locktmp(arg1: VALUE) -> VALUE;
    pub fn rb_str_unlocktmp(arg1: VALUE) -> VALUE;
    pub fn rb_str_dup_frozen(arg1: VALUE) -> VALUE;
    pub fn rb_str_plus(arg1: VALUE, arg2: VALUE) -> VALUE;
    pub fn rb_str_times(arg1: VALUE, arg2: VALUE) -> VALUE;
    pub fn rb_str_sublen(arg1: VALUE, arg2: ::std::os::raw::c_long)
     -> ::std::os::raw::c_long;
    pub fn rb_str_substr(arg1: VALUE, arg2: ::std::os::raw::c_long,
                         arg3: ::std::os::raw::c_long) -> VALUE;
    pub fn rb_str_subseq(arg1: VALUE, arg2: ::std::os::raw::c_long,
                         arg3: ::std::os::raw::c_long) -> VALUE;
    pub fn rb_str_subpos(arg1: VALUE, arg2: ::std::os::raw::c_long,
                         arg3: *mut ::std::os::raw::c_long)
     -> *mut ::std::os::raw::c_char;
    pub fn rb_str_modify(arg1: VALUE);
    pub fn rb_str_modify_expand(arg1: VALUE, arg2: ::std::os::raw::c_long);
    pub fn rb_str_freeze(arg1: VALUE) -> VALUE;
    pub fn rb_str_set_len(arg1: VALUE, arg2: ::std::os::raw::c_long);
    pub fn rb_str_resize(arg1: VALUE, arg2: ::std::os::raw::c_long) -> VALUE;
    pub fn rb_str_cat(arg1: VALUE, arg2: *const ::std::os::raw::c_char,
                      arg3: ::std::os::raw::c_long) -> VALUE;
    pub fn rb_str_cat2(arg1: VALUE, arg2: *const ::std::os::raw::c_char)
     -> VALUE;
    pub fn rb_str_append(arg1: VALUE, arg2: VALUE) -> VALUE;
    pub fn rb_str_concat(arg1: VALUE, arg2: VALUE) -> VALUE;
    pub fn rb_memhash(ptr: *const ::std::os::raw::c_void,
                      len: ::std::os::raw::c_long) -> st_index_t;
    pub fn rb_hash_start(arg1: st_index_t) -> st_index_t;
    pub fn rb_hash_uint32(arg1: st_index_t, arg2: uint32_t) -> st_index_t;
    pub fn rb_hash_uint(arg1: st_index_t, arg2: st_index_t) -> st_index_t;
    pub fn rb_hash_end(arg1: st_index_t) -> st_index_t;
    pub fn rb_str_hash(arg1: VALUE) -> st_index_t;
    pub fn rb_str_hash_cmp(arg1: VALUE, arg2: VALUE) -> ::std::os::raw::c_int;
    pub fn rb_str_comparable(arg1: VALUE, arg2: VALUE)
     -> ::std::os::raw::c_int;
    pub fn rb_str_cmp(arg1: VALUE, arg2: VALUE) -> ::std::os::raw::c_int;
    pub fn rb_str_equal(str1: VALUE, str2: VALUE) -> VALUE;
    pub fn rb_str_drop_bytes(arg1: VALUE, arg2: ::std::os::raw::c_long)
     -> VALUE;
    pub fn rb_str_update(arg1: VALUE, arg2: ::std::os::raw::c_long,
                         arg3: ::std::os::raw::c_long, arg4: VALUE);
    pub fn rb_str_replace(arg1: VALUE, arg2: VALUE) -> VALUE;
    pub fn rb_str_inspect(arg1: VALUE) -> VALUE;
    pub fn rb_str_dump(arg1: VALUE) -> VALUE;
    pub fn rb_str_split(arg1: VALUE, arg2: *const ::std::os::raw::c_char)
     -> VALUE;
    pub fn rb_str_associate(arg1: VALUE, arg2: VALUE);
    pub fn rb_str_associated(arg1: VALUE) -> VALUE;
    pub fn rb_str_setter(arg1: VALUE, arg2: ID, arg3: *mut VALUE);
    pub fn rb_str_intern(arg1: VALUE) -> VALUE;
    pub fn rb_sym_to_s(arg1: VALUE) -> VALUE;
    pub fn rb_str_strlen(arg1: VALUE) -> ::std::os::raw::c_long;
    pub fn rb_str_length(arg1: VALUE) -> VALUE;
    pub fn rb_str_offset(arg1: VALUE, arg2: ::std::os::raw::c_long)
     -> ::std::os::raw::c_long;
    pub fn rb_str_capacity(arg1: VALUE) -> size_t;
    pub fn rb_str_ellipsize(arg1: VALUE, arg2: ::std::os::raw::c_long)
     -> VALUE;
    pub fn rb_str_scrub(arg1: VALUE, arg2: VALUE) -> VALUE;
    pub fn rb_struct_new(arg1: VALUE, ...) -> VALUE;
    pub fn rb_struct_define(arg1: *const ::std::os::raw::c_char, ...)
     -> VALUE;
    pub fn rb_struct_define_under(arg1: VALUE,
                                  arg2: *const ::std::os::raw::c_char, ...)
     -> VALUE;
    pub fn rb_struct_alloc(arg1: VALUE, arg2: VALUE) -> VALUE;
    pub fn rb_struct_initialize(arg1: VALUE, arg2: VALUE) -> VALUE;
    pub fn rb_struct_aref(arg1: VALUE, arg2: VALUE) -> VALUE;
    pub fn rb_struct_aset(arg1: VALUE, arg2: VALUE, arg3: VALUE) -> VALUE;
    pub fn rb_struct_getmember(arg1: VALUE, arg2: ID) -> VALUE;
    pub fn rb_struct_iv_get(arg1: VALUE, arg2: *const ::std::os::raw::c_char)
     -> VALUE;
    pub fn rb_struct_s_members(arg1: VALUE) -> VALUE;
    pub fn rb_struct_members(arg1: VALUE) -> VALUE;
    pub fn rb_struct_alloc_noinit(arg1: VALUE) -> VALUE;
    pub fn rb_struct_define_without_accessor(arg1:
                                                 *const ::std::os::raw::c_char,
                                             arg2: VALUE,
                                             arg3: rb_alloc_func_t, ...)
     -> VALUE;
    pub fn rb_struct_define_without_accessor_under(outer: VALUE,
                                                   class_name:
                                                       *const ::std::os::raw::c_char,
                                                   _super: VALUE,
                                                   alloc:
                                                       rb_alloc_func_t, ...)
     -> VALUE;
    pub fn rb_thread_check_ints();
    pub fn rb_thread_interrupted(thval: VALUE) -> ::std::os::raw::c_int;
    pub fn rb_thread_blocking_region(func:
                                         *mut ::std::option::Option<extern "C" fn()
                                                                        ->
                                                                            VALUE>,
                                     data1: *mut ::std::os::raw::c_void,
                                     ubf:
                                         *mut ::std::option::Option<extern "C" fn()>,
                                     data2: *mut ::std::os::raw::c_void)
     -> VALUE;
    pub fn rb_mutex_new() -> VALUE;
    pub fn rb_mutex_locked_p(mutex: VALUE) -> VALUE;
    pub fn rb_mutex_trylock(mutex: VALUE) -> VALUE;
    pub fn rb_mutex_lock(mutex: VALUE) -> VALUE;
    pub fn rb_mutex_unlock(mutex: VALUE) -> VALUE;
    pub fn rb_mutex_sleep(_self: VALUE, timeout: VALUE) -> VALUE;
    pub fn rb_mutex_synchronize(mutex: VALUE,
                                func:
                                    ::std::option::Option<extern "C" fn(arg:
                                                                            VALUE)
                                                              -> VALUE>,
                                arg: VALUE) -> VALUE;
    pub fn rb_time_new(arg1: time_t, arg2: ::std::os::raw::c_long) -> VALUE;
    pub fn rb_time_nano_new(arg1: time_t, arg2: ::std::os::raw::c_long)
     -> VALUE;
    pub fn rb_time_num_new(arg1: VALUE, arg2: VALUE) -> VALUE;
    pub fn rb_time_interval(num: VALUE) -> Struct_timeval;
    pub fn rb_time_timeval(arg1: VALUE) -> Struct_timeval;
    pub fn rb_time_timespec(time: VALUE) -> Struct_timespec;
    pub fn rb_mod_name(arg1: VALUE) -> VALUE;
    pub fn rb_class_path(arg1: VALUE) -> VALUE;
    pub fn rb_class_path_cached(arg1: VALUE) -> VALUE;
    pub fn rb_set_class_path(arg1: VALUE, arg2: VALUE,
                             arg3: *const ::std::os::raw::c_char);
    pub fn rb_set_class_path_string(arg1: VALUE, arg2: VALUE, arg3: VALUE);
    pub fn rb_path_to_class(arg1: VALUE) -> VALUE;
    pub fn rb_path2class(arg1: *const ::std::os::raw::c_char) -> VALUE;
    pub fn rb_name_class(arg1: VALUE, arg2: ID);
    pub fn rb_class_name(arg1: VALUE) -> VALUE;
    pub fn rb_autoload(arg1: VALUE, arg2: ID,
                       arg3: *const ::std::os::raw::c_char);
    pub fn rb_autoload_load(arg1: VALUE, arg2: ID) -> VALUE;
    pub fn rb_autoload_p(arg1: VALUE, arg2: ID) -> VALUE;
    pub fn rb_f_trace_var(arg1: ::std::os::raw::c_int, arg2: *mut VALUE)
     -> VALUE;
    pub fn rb_f_untrace_var(arg1: ::std::os::raw::c_int, arg2: *mut VALUE)
     -> VALUE;
    pub fn rb_f_global_variables() -> VALUE;
    pub fn rb_alias_variable(arg1: ID, arg2: ID);
    pub fn rb_generic_ivar_table(arg1: VALUE) -> *mut Struct_st_table;
    pub fn rb_copy_generic_ivar(arg1: VALUE, arg2: VALUE);
    pub fn rb_free_generic_ivar(arg1: VALUE);
    pub fn rb_ivar_get(arg1: VALUE, arg2: ID) -> VALUE;
    pub fn rb_ivar_set(arg1: VALUE, arg2: ID, arg3: VALUE) -> VALUE;
    pub fn rb_ivar_defined(arg1: VALUE, arg2: ID) -> VALUE;
    pub fn rb_ivar_foreach(arg1: VALUE,
                           arg2:
                               ::std::option::Option<extern "C" fn()
                                                         ->
                                                             ::std::os::raw::c_int>,
                           arg3: st_data_t);
    pub fn rb_ivar_count(arg1: VALUE) -> st_index_t;
    pub fn rb_attr_get(arg1: VALUE, arg2: ID) -> VALUE;
    pub fn rb_obj_instance_variables(arg1: VALUE) -> VALUE;
    pub fn rb_obj_remove_instance_variable(arg1: VALUE, arg2: VALUE) -> VALUE;
    pub fn rb_mod_const_at(arg1: VALUE, arg2: *mut ::std::os::raw::c_void)
     -> *mut ::std::os::raw::c_void;
    pub fn rb_mod_const_of(arg1: VALUE, arg2: *mut ::std::os::raw::c_void)
     -> *mut ::std::os::raw::c_void;
    pub fn rb_const_list(arg1: *mut ::std::os::raw::c_void) -> VALUE;
    pub fn rb_mod_constants(arg1: ::std::os::raw::c_int, arg2: *mut VALUE,
                            arg3: VALUE) -> VALUE;
    pub fn rb_mod_remove_const(arg1: VALUE, arg2: VALUE) -> VALUE;
    pub fn rb_const_defined(arg1: VALUE, arg2: ID) -> ::std::os::raw::c_int;
    pub fn rb_const_defined_at(arg1: VALUE, arg2: ID)
     -> ::std::os::raw::c_int;
    pub fn rb_const_defined_from(arg1: VALUE, arg2: ID)
     -> ::std::os::raw::c_int;
    pub fn rb_const_get(arg1: VALUE, arg2: ID) -> VALUE;
    pub fn rb_const_get_at(arg1: VALUE, arg2: ID) -> VALUE;
    pub fn rb_const_get_from(arg1: VALUE, arg2: ID) -> VALUE;
    pub fn rb_const_set(arg1: VALUE, arg2: ID, arg3: VALUE);
    pub fn rb_const_remove(arg1: VALUE, arg2: ID) -> VALUE;
    pub fn rb_mod_const_missing(arg1: VALUE, arg2: VALUE) -> VALUE;
    pub fn rb_cvar_defined(arg1: VALUE, arg2: ID) -> VALUE;
    pub fn rb_cvar_set(arg1: VALUE, arg2: ID, arg3: VALUE);
    pub fn rb_cvar_get(arg1: VALUE, arg2: ID) -> VALUE;
    pub fn rb_cv_set(arg1: VALUE, arg2: *const ::std::os::raw::c_char,
                     arg3: VALUE);
    pub fn rb_cv_get(arg1: VALUE, arg2: *const ::std::os::raw::c_char)
     -> VALUE;
    pub fn rb_define_class_variable(arg1: VALUE,
                                    arg2: *const ::std::os::raw::c_char,
                                    arg3: VALUE);
    pub fn rb_mod_class_variables(arg1: ::std::os::raw::c_int,
                                  arg2: *mut VALUE, arg3: VALUE) -> VALUE;
    pub fn rb_mod_remove_cvar(arg1: VALUE, arg2: VALUE) -> VALUE;
    pub fn rb_frame_callee() -> ID;
    pub fn rb_str_succ(arg1: VALUE) -> VALUE;
    pub fn rb_time_succ(arg1: VALUE) -> VALUE;
    pub fn rb_frame_method_id_and_class(idp: *mut ID, klassp: *mut VALUE)
     -> ::std::os::raw::c_int;
    pub fn rb_make_backtrace() -> VALUE;
    pub fn rb_make_exception(arg1: ::std::os::raw::c_int, arg2: *mut VALUE)
     -> VALUE;
    pub fn rb_frame_pop();
    pub fn ruby_native_thread_p() -> ::std::os::raw::c_int;
    pub fn rb_add_event_hook(func: rb_event_hook_func_t,
                             events: rb_event_flag_t, data: VALUE);
    pub fn rb_remove_event_hook(func: rb_event_hook_func_t)
     -> ::std::os::raw::c_int;
    pub fn rb_isalnum(c: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
    pub fn rb_isalpha(c: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
    pub fn rb_isblank(c: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
    pub fn rb_iscntrl(c: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
    pub fn rb_isdigit(c: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
    pub fn rb_isgraph(c: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
    pub fn rb_islower(c: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
    pub fn rb_isprint(c: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
    pub fn rb_ispunct(c: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
    pub fn rb_isspace(c: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
    pub fn rb_isupper(c: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
    pub fn rb_isxdigit(c: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
    pub fn rb_tolower(c: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
    pub fn rb_toupper(c: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
    pub fn ruby_strtoul(str: *const ::std::os::raw::c_char,
                        endptr: *mut *mut ::std::os::raw::c_char,
                        base: ::std::os::raw::c_int)
     -> ::std::os::raw::c_ulong;
    pub fn ruby_snprintf(str: *mut ::std::os::raw::c_char, n: size_t,
                         fmt: *const ::std::os::raw::c_char, ...)
     -> ::std::os::raw::c_int;
    pub fn ruby_vsnprintf(str: *mut ::std::os::raw::c_char, n: size_t,
                          fmt: *const ::std::os::raw::c_char, ap: va_list)
     -> ::std::os::raw::c_int;
    pub fn ruby_sysinit(argc: *mut ::std::os::raw::c_int,
                        argv: *mut *mut *mut ::std::os::raw::c_char);
    pub fn ruby_init();
    pub fn ruby_options(argc: ::std::os::raw::c_int,
                        argv: *mut *mut ::std::os::raw::c_char)
     -> *mut ::std::os::raw::c_void;
    pub fn ruby_executable_node(n: *mut ::std::os::raw::c_void,
                                status: *mut ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
    pub fn ruby_run_node(n: *mut ::std::os::raw::c_void)
     -> ::std::os::raw::c_int;
    pub fn ruby_show_version();
    pub fn ruby_show_copyright();
    pub fn ruby_init_stack(arg1: *mut VALUE);
    pub fn ruby_setup() -> ::std::os::raw::c_int;
    pub fn ruby_cleanup(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
    pub fn ruby_finalize();
    pub fn ruby_stop(arg1: ::std::os::raw::c_int);
    pub fn ruby_set_stack_size(arg1: size_t);
    pub fn ruby_stack_check() -> ::std::os::raw::c_int;
    pub fn ruby_stack_length(arg1: *mut *mut VALUE) -> size_t;
    pub fn ruby_exec_node(n: *mut ::std::os::raw::c_void)
     -> ::std::os::raw::c_int;
    pub fn ruby_script(name: *const ::std::os::raw::c_char);
    pub fn ruby_set_script_name(name: VALUE);
    pub fn ruby_prog_init();
    pub fn ruby_set_argv(arg1: ::std::os::raw::c_int,
                         arg2: *mut *mut ::std::os::raw::c_char);
    pub fn ruby_process_options(arg1: ::std::os::raw::c_int,
                                arg2: *mut *mut ::std::os::raw::c_char)
     -> *mut ::std::os::raw::c_void;
    pub fn ruby_init_loadpath();
    pub fn ruby_incpush(arg1: *const ::std::os::raw::c_char);
    pub fn ruby_sig_finalize();
    pub fn rb_parser_new() -> VALUE;
    pub fn rb_parser_end_seen_p(arg1: VALUE) -> VALUE;
    pub fn rb_parser_encoding(arg1: VALUE) -> VALUE;
    pub fn rb_parser_get_yydebug(arg1: VALUE) -> VALUE;
    pub fn rb_parser_set_yydebug(arg1: VALUE, arg2: VALUE) -> VALUE;
    pub fn rb_parser_dump_tree(node: *mut NODE,
                               comment: ::std::os::raw::c_int) -> VALUE;
    pub fn rb_parser_append_print(arg1: VALUE, arg2: *mut NODE) -> *mut NODE;
    pub fn rb_parser_while_loop(arg1: VALUE, arg2: *mut NODE,
                                arg3: ::std::os::raw::c_int,
                                arg4: ::std::os::raw::c_int) -> *mut NODE;
    pub fn rb_parser_compile_cstr(arg1: VALUE,
                                  arg2: *const ::std::os::raw::c_char,
                                  arg3: *const ::std::os::raw::c_char,
                                  arg4: ::std::os::raw::c_int,
                                  arg5: ::std::os::raw::c_int) -> *mut NODE;
    pub fn rb_parser_compile_string(arg1: VALUE,
                                    arg2: *const ::std::os::raw::c_char,
                                    arg3: VALUE, arg4: ::std::os::raw::c_int)
     -> *mut NODE;
    pub fn rb_parser_compile_file(arg1: VALUE,
                                  arg2: *const ::std::os::raw::c_char,
                                  arg3: VALUE, arg4: ::std::os::raw::c_int)
     -> *mut NODE;
    pub fn rb_parser_compile_string_path(vparser: VALUE, fname: VALUE,
                                         src: VALUE,
                                         line: ::std::os::raw::c_int)
     -> *mut NODE;
    pub fn rb_parser_compile_file_path(vparser: VALUE, fname: VALUE,
                                       input: VALUE,
                                       line: ::std::os::raw::c_int)
     -> *mut NODE;
    pub fn rb_compile_cstr(arg1: *const ::std::os::raw::c_char,
                           arg2: *const ::std::os::raw::c_char,
                           arg3: ::std::os::raw::c_int,
                           arg4: ::std::os::raw::c_int) -> *mut NODE;
    pub fn rb_compile_string(arg1: *const ::std::os::raw::c_char, arg2: VALUE,
                             arg3: ::std::os::raw::c_int) -> *mut NODE;
    pub fn rb_compile_file(arg1: *const ::std::os::raw::c_char, arg2: VALUE,
                           arg3: ::std::os::raw::c_int) -> *mut NODE;
    pub fn rb_node_newnode(arg1: Enum_node_type, arg2: VALUE, arg3: VALUE,
                           arg4: VALUE) -> *mut NODE;
    pub fn rb_node_newnode_longlife(arg1: Enum_node_type, arg2: VALUE,
                                    arg3: VALUE, arg4: VALUE) -> *mut NODE;
    pub fn rb_global_entry(arg1: ID) -> *mut Struct_rb_global_entry;
    pub fn rb_gvar_get(arg1: *mut Struct_rb_global_entry) -> VALUE;
    pub fn rb_gvar_set(arg1: *mut Struct_rb_global_entry, arg2: VALUE)
     -> VALUE;
    pub fn rb_gvar_defined(arg1: *mut Struct_rb_global_entry) -> VALUE;
    pub fn rb_reserved_word(arg1: *const ::std::os::raw::c_char,
                            arg2: ::std::os::raw::c_uint)
     -> *const Struct_kwtable;
    pub fn rb_parser_malloc(arg1: *mut Struct_parser_params, arg2: size_t)
     -> *mut ::std::os::raw::c_void;
    pub fn rb_parser_realloc(arg1: *mut Struct_parser_params,
                             arg2: *mut ::std::os::raw::c_void, arg3: size_t)
     -> *mut ::std::os::raw::c_void;
    pub fn rb_parser_calloc(arg1: *mut Struct_parser_params, arg2: size_t,
                            arg3: size_t) -> *mut ::std::os::raw::c_void;
    pub fn rb_parser_free(arg1: *mut Struct_parser_params,
                          arg2: *mut ::std::os::raw::c_void);
    pub fn ruby_debug_print_value(level: ::std::os::raw::c_int,
                                  debug_level: ::std::os::raw::c_int,
                                  header: *const ::std::os::raw::c_char,
                                  v: VALUE) -> VALUE;
    pub fn ruby_debug_print_id(level: ::std::os::raw::c_int,
                               debug_level: ::std::os::raw::c_int,
                               header: *const ::std::os::raw::c_char, id: ID)
     -> ID;
    pub fn ruby_debug_print_node(level: ::std::os::raw::c_int,
                                 debug_level: ::std::os::raw::c_int,
                                 header: *const ::std::os::raw::c_char,
                                 node: *const NODE) -> *mut NODE;
    pub fn ruby_debug_print_indent(level: ::std::os::raw::c_int,
                                   debug_level: ::std::os::raw::c_int,
                                   indent_level: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
    pub fn ruby_debug_breakpoint();
    pub fn ruby_debug_gc_check_func();
    pub fn ruby_set_debug_option(str: *const ::std::os::raw::c_char);
    pub fn rb_class_subclass_add(_super: VALUE, klass: VALUE);
    pub fn rb_class_remove_from_super_subclasses(arg1: VALUE);
    pub fn rb_ary_last(arg1: ::std::os::raw::c_int, arg2: *mut VALUE,
                       arg3: VALUE) -> VALUE;
    pub fn rb_ary_set_len(arg1: VALUE, arg2: ::std::os::raw::c_long);
    pub fn rb_ary_delete_same(arg1: VALUE, arg2: VALUE);
    pub fn rb_big_fdiv(x: VALUE, y: VALUE) -> VALUE;
    pub fn rb_big_uminus(x: VALUE) -> VALUE;
    pub fn rb_integer_float_cmp(x: VALUE, y: VALUE) -> VALUE;
    pub fn rb_integer_float_eq(x: VALUE, y: VALUE) -> VALUE;
    pub fn rb_class_foreach_subclass(klass: VALUE,
                                     f:
                                         ::std::option::Option<extern "C" fn(arg1:
                                                                                 VALUE)>);
    pub fn rb_class_detach_subclasses(arg1: VALUE);
    pub fn rb_class_detach_module_subclasses(arg1: VALUE);
    pub fn rb_class_remove_from_module_subclasses(arg1: VALUE);
    pub fn rb_obj_methods(argc: ::std::os::raw::c_int, argv: *mut VALUE,
                          obj: VALUE) -> VALUE;
    pub fn rb_obj_protected_methods(argc: ::std::os::raw::c_int,
                                    argv: *mut VALUE, obj: VALUE) -> VALUE;
    pub fn rb_obj_private_methods(argc: ::std::os::raw::c_int,
                                  argv: *mut VALUE, obj: VALUE) -> VALUE;
    pub fn rb_obj_public_methods(argc: ::std::os::raw::c_int,
                                 argv: *mut VALUE, obj: VALUE) -> VALUE;
    pub fn rb_obj_basic_to_s_p(arg1: VALUE) -> ::std::os::raw::c_int;
    pub fn rb_special_singleton_class(arg1: VALUE) -> VALUE;
    pub fn rb_singleton_class_clone_and_attach(obj: VALUE, attach: VALUE)
     -> VALUE;
    pub fn rb_singleton_class_get(obj: VALUE) -> VALUE;
    pub fn Init_class_hierarchy();
    pub fn rb_invcmp(arg1: VALUE, arg2: VALUE) -> VALUE;
    pub fn rb_dvar_defined(arg1: ID) -> ::std::os::raw::c_int;
    pub fn rb_local_defined(arg1: ID) -> ::std::os::raw::c_int;
    pub fn rb_parse_in_eval() -> ::std::os::raw::c_int;
    pub fn rb_parse_in_main() -> ::std::os::raw::c_int;
    pub fn rb_insns_name(i: ::std::os::raw::c_int)
     -> *const ::std::os::raw::c_char;
    pub fn rb_insns_name_array() -> VALUE;
    pub fn rb_obj_is_fiber(arg1: VALUE) -> VALUE;
    pub fn rb_fiber_reset_root_local_storage(arg1: VALUE);
    pub fn ruby_register_rollback_func_for_ensure(ensure_func:
                                                      ::std::option::Option<extern "C" fn()
                                                                                ->
                                                                                    VALUE>,
                                                  rollback_func:
                                                      ::std::option::Option<extern "C" fn()
                                                                                ->
                                                                                    VALUE>);
    pub fn ruby_debug_printf(arg1: *const ::std::os::raw::c_char, ...);
    pub fn Init_ext();
    pub fn rb_id_encoding() -> ID;
    pub fn rb_gc_mark_encodings();
    pub fn rb_compile_bug(arg1: *const ::std::os::raw::c_char,
                          arg2: ::std::os::raw::c_int,
                          arg3: *const ::std::os::raw::c_char, ...);
    pub fn rb_check_backtrace(arg1: VALUE) -> VALUE;
    pub fn rb_async_bug_errno(arg1: *const ::std::os::raw::c_char,
                              arg2: ::std::os::raw::c_int);
    pub fn rb_builtin_type_name(t: ::std::os::raw::c_int)
     -> *const ::std::os::raw::c_char;
    pub fn rb_builtin_class_name(x: VALUE) -> *const ::std::os::raw::c_char;
    pub fn rb_refinement_module_get_refined_class(module: VALUE) -> VALUE;
    pub fn ruby_error_print();
    pub fn rb_get_backtrace(info: VALUE) -> VALUE;
    pub fn rb_call_end_proc(data: VALUE);
    pub fn rb_mark_end_proc();
    pub fn rb_home_dir_of(user: VALUE, result: VALUE) -> VALUE;
    pub fn rb_default_home_dir(result: VALUE) -> VALUE;
    pub fn rb_realpath_internal(basedir: VALUE, path: VALUE,
                                strict: ::std::os::raw::c_int) -> VALUE;
    pub fn rb_file_const(arg1: *const ::std::os::raw::c_char, arg2: VALUE);
    pub fn rb_file_load_ok(arg1: *const ::std::os::raw::c_char)
     -> ::std::os::raw::c_int;
    pub fn rb_file_expand_path_fast(arg1: VALUE, arg2: VALUE) -> VALUE;
    pub fn rb_file_expand_path_internal(arg1: VALUE, arg2: VALUE,
                                        arg3: ::std::os::raw::c_int,
                                        arg4: ::std::os::raw::c_int,
                                        arg5: VALUE) -> VALUE;
    pub fn rb_get_path_check_to_string(arg1: VALUE,
                                       arg2: ::std::os::raw::c_int) -> VALUE;
    pub fn rb_get_path_check_convert(arg1: VALUE, arg2: VALUE,
                                     arg3: ::std::os::raw::c_int) -> VALUE;
    pub fn Init_File();
    pub fn rb_sys_fail_path_in(func_name: *const ::std::os::raw::c_char,
                               path: VALUE);
    pub fn rb_syserr_fail_path_in(func_name: *const ::std::os::raw::c_char,
                                  err: ::std::os::raw::c_int, path: VALUE);
    pub fn Init_heap();
    pub fn ruby_mimmalloc(size: size_t) -> *mut ::std::os::raw::c_void;
    pub fn ruby_mimfree(ptr: *mut ::std::os::raw::c_void);
    pub fn rb_objspace_set_event_hook(event: rb_event_flag_t);
    pub fn rb_gc_writebarrier_remember_promoted(obj: VALUE);
    pub fn ruby_gc_set_params(safe_level: ::std::os::raw::c_int);
    pub fn rb_gc_resurrect(ptr: VALUE);
    pub fn rb_hash_tbl_raw(hash: VALUE) -> *mut Struct_st_table;
    pub fn rb_hash_keys(hash: VALUE) -> VALUE;
    pub fn rb_hash_values(hash: VALUE) -> VALUE;
    pub fn rb_call_inits();
    pub fn ruby_get_inplace_mode() -> *const ::std::os::raw::c_char;
    pub fn ruby_set_inplace_mode(arg1: *const ::std::os::raw::c_char);
    pub fn rb_io_bufread(io: VALUE, buf: *mut ::std::os::raw::c_void,
                         size: size_t) -> ssize_t;
    pub fn rb_stdio_set_default_encoding();
    pub fn rb_write_error_str(mesg: VALUE);
    pub fn rb_io_flush_raw(arg1: VALUE, arg2: ::std::os::raw::c_int) -> VALUE;
    pub fn rb_iseq_clone(iseqval: VALUE, newcbase: VALUE) -> VALUE;
    pub fn rb_iseq_path(iseqval: VALUE) -> VALUE;
    pub fn rb_iseq_absolute_path(iseqval: VALUE) -> VALUE;
    pub fn rb_iseq_label(iseqval: VALUE) -> VALUE;
    pub fn rb_iseq_base_label(iseqval: VALUE) -> VALUE;
    pub fn rb_iseq_first_lineno(iseqval: VALUE) -> VALUE;
    pub fn rb_iseq_klass(iseqval: VALUE) -> VALUE;
    pub fn rb_iseq_method_name(_self: VALUE) -> VALUE;
    pub fn rb_get_load_path() -> VALUE;
    pub fn rb_get_expanded_load_path() -> VALUE;
    pub fn rb_load_fail(arg1: VALUE, arg2: *const ::std::os::raw::c_char);
    pub fn rb_math_atan2(arg1: VALUE, arg2: VALUE) -> VALUE;
    pub fn rb_math_cos(arg1: VALUE) -> VALUE;
    pub fn rb_math_cosh(arg1: VALUE) -> VALUE;
    pub fn rb_math_exp(arg1: VALUE) -> VALUE;
    pub fn rb_math_hypot(arg1: VALUE, arg2: VALUE) -> VALUE;
    pub fn rb_math_log(argc: ::std::os::raw::c_int, argv: *mut VALUE)
     -> VALUE;
    pub fn rb_math_sin(arg1: VALUE) -> VALUE;
    pub fn rb_math_sinh(arg1: VALUE) -> VALUE;
    pub fn rb_math_sqrt(arg1: VALUE) -> VALUE;
    pub fn Init_newline();
    pub fn rb_num_to_uint(val: VALUE, ret: *mut ::std::os::raw::c_uint)
     -> ::std::os::raw::c_int;
    pub fn ruby_num_interval_step_size(from: VALUE, to: VALUE, step: VALUE,
                                       excl: ::std::os::raw::c_int) -> VALUE;
    pub fn ruby_float_step(from: VALUE, to: VALUE, step: VALUE,
                           excl: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
    pub fn ruby_float_mod(x: ::std::os::raw::c_double,
                          y: ::std::os::raw::c_double)
     -> ::std::os::raw::c_double;
    pub fn rb_num_negative_p(arg1: VALUE) -> ::std::os::raw::c_int;
    pub fn rb_int_succ(num: VALUE) -> VALUE;
    pub fn rb_int_pred(num: VALUE) -> VALUE;
    pub fn rb_dbl_hash(d: ::std::os::raw::c_double) -> VALUE;
    pub fn rb_obj_copy_ivar(dest: VALUE, obj: VALUE);
    pub fn rb_obj_equal(obj1: VALUE, obj2: VALUE) -> VALUE;
    pub fn rb_class_search_ancestor(klass: VALUE, _super: VALUE) -> VALUE;
    pub fn rb_undefined_alloc(klass: VALUE);
    pub fn rb_is_const_name(name: VALUE) -> ::std::os::raw::c_int;
    pub fn rb_is_class_name(name: VALUE) -> ::std::os::raw::c_int;
    pub fn rb_is_global_name(name: VALUE) -> ::std::os::raw::c_int;
    pub fn rb_is_instance_name(name: VALUE) -> ::std::os::raw::c_int;
    pub fn rb_is_attrset_name(name: VALUE) -> ::std::os::raw::c_int;
    pub fn rb_is_local_name(name: VALUE) -> ::std::os::raw::c_int;
    pub fn rb_is_method_name(name: VALUE) -> ::std::os::raw::c_int;
    pub fn rb_is_junk_name(name: VALUE) -> ::std::os::raw::c_int;
    pub fn rb_gc_mark_parser();
    pub fn rb_gc_mark_symbols(full_mark: ::std::os::raw::c_int);
    pub fn rb_proc_location(_self: VALUE) -> VALUE;
    pub fn rb_hash_proc(hash: st_index_t, _proc: VALUE) -> st_index_t;
    pub fn rb_block_arity() -> ::std::os::raw::c_int;
    pub fn rb_block_clear_env_self(_proc: VALUE) -> VALUE;
    pub fn rb_fork_ruby(status: *mut ::std::os::raw::c_int) -> pid_t;
    pub fn rb_last_status_clear();
    pub fn rb_lcm(x: VALUE, y: VALUE) -> VALUE;
    pub fn rb_rational_reciprocal(x: VALUE) -> VALUE;
    pub fn rb_reg_compile(str: VALUE, options: ::std::os::raw::c_int,
                          sourcefile: *const ::std::os::raw::c_char,
                          sourceline: ::std::os::raw::c_int) -> VALUE;
    pub fn rb_reg_check_preprocess(arg1: VALUE) -> VALUE;
    pub fn rb_get_next_signal() -> ::std::os::raw::c_int;
    pub fn rb_sigaltstack_size() -> ::std::os::raw::c_int;
    pub fn rb_fstring(arg1: VALUE) -> VALUE;
    pub fn rb_str_buf_cat_escaped_char(result: VALUE,
                                       c: ::std::os::raw::c_uint,
                                       unicode_p: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
    pub fn rb_str_symname_p(arg1: VALUE) -> ::std::os::raw::c_int;
    pub fn rb_str_quote_unprintable(arg1: VALUE) -> VALUE;
    pub fn rb_id_quote_unprintable(arg1: ID) -> VALUE;
    pub fn rb_str_fill_terminator(str: VALUE, termlen: ::std::os::raw::c_int);
    pub fn rb_str_locktmp_ensure(str: VALUE,
                                 func:
                                     ::std::option::Option<extern "C" fn(arg1:
                                                                             VALUE)
                                                               -> VALUE>,
                                 arg: VALUE) -> VALUE;
    pub fn rb_struct_init_copy(copy: VALUE, s: VALUE) -> VALUE;
    pub fn rb_obj_is_mutex(obj: VALUE) -> VALUE;
    pub fn rb_suppress_tracing(func:
                                   ::std::option::Option<extern "C" fn(arg1:
                                                                           VALUE)
                                                             -> VALUE>,
                               arg: VALUE) -> VALUE;
    pub fn rb_thread_execute_interrupts(th: VALUE);
    pub fn rb_clear_trace_func();
    pub fn rb_get_coverages() -> VALUE;
    pub fn rb_thread_shield_new() -> VALUE;
    pub fn rb_thread_shield_wait(_self: VALUE) -> VALUE;
    pub fn rb_thread_shield_release(_self: VALUE) -> VALUE;
    pub fn rb_thread_shield_destroy(_self: VALUE) -> VALUE;
    pub fn rb_mutex_allow_trap(_self: VALUE, val: ::std::os::raw::c_int);
    pub fn rb_uninterruptible(b_proc:
                                  ::std::option::Option<extern "C" fn()
                                                            -> VALUE>,
                              data: VALUE) -> VALUE;
    pub fn rb_mutex_owned_p(_self: VALUE) -> VALUE;
    pub fn ruby_kill(pid: pid_t, sig: ::std::os::raw::c_int);
    pub fn Init_native_thread();
    pub fn rb_next_class_serial() -> rb_serial_t;
    pub fn rb_obj_is_thread(obj: VALUE) -> VALUE;
    pub fn rb_vm_mark(ptr: *mut ::std::os::raw::c_void);
    pub fn Init_BareVM();
    pub fn rb_vm_top_self() -> VALUE;
    pub fn rb_thread_recycle_stack_release(arg1: *mut VALUE);
    pub fn rb_vm_change_state();
    pub fn rb_vm_inc_const_missing_count();
    pub fn rb_thread_mark(th: *mut ::std::os::raw::c_void);
    pub fn rb_vm_get_insns_address_table()
     -> *mut *const ::std::os::raw::c_void;
    pub fn rb_sourcefilename() -> VALUE;
    pub fn rb_vm_pop_cfunc_frame();
    pub fn rb_vm_bugreport();
    pub fn rb_print_backtrace();
    pub fn Init_vm_eval();
    pub fn rb_current_realfilepath() -> VALUE;
    pub fn rb_check_block_call(arg1: VALUE, arg2: ID,
                               arg3: ::std::os::raw::c_int,
                               arg4: *const VALUE, arg5: rb_block_call_func_t,
                               arg6: VALUE) -> VALUE;
    pub fn rb_check_funcall_with_hook(recv: VALUE, mid: ID,
                                      argc: ::std::os::raw::c_int,
                                      argv: *const VALUE,
                                      hook:
                                          *mut ::std::option::Option<extern "C" fn()>,
                                      arg: VALUE) -> VALUE;
    pub fn rb_catch_protect(t: VALUE,
                            func:
                                *mut ::std::option::Option<extern "C" fn()
                                                               -> VALUE>,
                            data: VALUE, stateptr: *mut ::std::os::raw::c_int)
     -> VALUE;
    pub fn rb_equal_opt(obj1: VALUE, obj2: VALUE) -> VALUE;
    pub fn rb_get_kwargs(keyword_hash: VALUE, table: *const ID,
                         required: ::std::os::raw::c_int,
                         optional: ::std::os::raw::c_int, arg1: *mut VALUE)
     -> ::std::os::raw::c_int;
    pub fn rb_extract_keywords(orighash: *mut VALUE) -> VALUE;
    pub fn Init_eval_method();
    pub fn rb_method_defined_by(obj: VALUE, mid: ID,
                                cfunc:
                                    ::std::option::Option<extern "C" fn()
                                                              -> VALUE>)
     -> ::std::os::raw::c_int;
    pub fn Init_prelude();
    pub fn Init_vm_backtrace();
    pub fn rb_vm_thread_backtrace(argc: ::std::os::raw::c_int,
                                  argv: *mut VALUE, thval: VALUE) -> VALUE;
    pub fn rb_vm_thread_backtrace_locations(argc: ::std::os::raw::c_int,
                                            argv: *mut VALUE, thval: VALUE)
     -> VALUE;
    pub fn rb_backtrace_print_as_bugreport();
    pub fn rb_backtrace_p(obj: VALUE) -> ::std::os::raw::c_int;
    pub fn rb_backtrace_to_str_ary(obj: VALUE) -> VALUE;
    pub fn rb_backtrace_to_location_ary(obj: VALUE) -> VALUE;
    pub fn rb_backtrace_print_to(output: VALUE);
    pub fn rb_vm_backtrace_object() -> VALUE;
    pub fn rb_objspace_data_type_name(obj: VALUE)
     -> *const ::std::os::raw::c_char;
    pub fn rb_thread_io_blocking_region(func:
                                            *mut ::std::option::Option<extern "C" fn()
                                                                           ->
                                                                               VALUE>,
                                        data1: *mut ::std::os::raw::c_void,
                                        fd: ::std::os::raw::c_int) -> VALUE;
    pub fn rb_big_mul_normal(x: VALUE, y: VALUE) -> VALUE;
    pub fn rb_big_mul_balance(x: VALUE, y: VALUE) -> VALUE;
    pub fn rb_big_mul_karatsuba(x: VALUE, y: VALUE) -> VALUE;
    pub fn rb_big_mul_toom3(x: VALUE, y: VALUE) -> VALUE;
    pub fn rb_big_sq_fast(x: VALUE) -> VALUE;
    pub fn rb_big_divrem_normal(x: VALUE, y: VALUE) -> VALUE;
    pub fn rb_big2str_poweroftwo(x: VALUE, base: ::std::os::raw::c_int)
     -> VALUE;
    pub fn rb_big2str_generic(x: VALUE, base: ::std::os::raw::c_int) -> VALUE;
    pub fn rb_str2big_poweroftwo(arg: VALUE, base: ::std::os::raw::c_int,
                                 badcheck: ::std::os::raw::c_int) -> VALUE;
    pub fn rb_str2big_normal(arg: VALUE, base: ::std::os::raw::c_int,
                             badcheck: ::std::os::raw::c_int) -> VALUE;
    pub fn rb_str2big_karatsuba(arg: VALUE, base: ::std::os::raw::c_int,
                                badcheck: ::std::os::raw::c_int) -> VALUE;
    pub fn rb_big_mul_gmp(x: VALUE, y: VALUE) -> VALUE;
    pub fn rb_big_divrem_gmp(x: VALUE, y: VALUE) -> VALUE;
    pub fn rb_big2str_gmp(x: VALUE, base: ::std::os::raw::c_int) -> VALUE;
    pub fn rb_str2big_gmp(arg: VALUE, base: ::std::os::raw::c_int,
                          badcheck: ::std::os::raw::c_int) -> VALUE;
    pub fn rb_bug_reporter_add(func:
                                   ::std::option::Option<unsafe extern "C" fn(arg1:
                                                                                  *mut FILE,
                                                                              arg2:
                                                                                  *mut ::std::os::raw::c_void)>,
                               data: *mut ::std::os::raw::c_void)
     -> ::std::os::raw::c_int;
    pub fn rb_maygvl_fd_fix_cloexec(fd: ::std::os::raw::c_int);
    pub fn rb_int_positive_pow(x: ::std::os::raw::c_long,
                               y: ::std::os::raw::c_ulong) -> VALUE;
    pub fn rb_exec_async_signal_safe(e: *const Struct_rb_execarg,
                                     errmsg: *mut ::std::os::raw::c_char,
                                     errmsg_buflen: size_t)
     -> ::std::os::raw::c_int;
    pub fn rb_fork_async_signal_safe(status: *mut ::std::os::raw::c_int,
                                     chfunc:
                                         ::std::option::Option<unsafe extern "C" fn(arg1:
                                                                                        *mut ::std::os::raw::c_void,
                                                                                    arg2:
                                                                                        *mut ::std::os::raw::c_char,
                                                                                    arg3:
                                                                                        size_t)
                                                                   ->
                                                                       ::std::os::raw::c_int>,
                                     charg: *mut ::std::os::raw::c_void,
                                     fds: VALUE,
                                     errmsg: *mut ::std::os::raw::c_char,
                                     errmsg_buflen: size_t) -> pid_t;
    pub fn rb_execarg_new(argc: ::std::os::raw::c_int, argv: *mut VALUE,
                          accept_shell: ::std::os::raw::c_int) -> VALUE;
    pub fn rb_execarg_get(execarg_obj: VALUE) -> *mut Struct_rb_execarg;
    pub fn rb_execarg_init(argc: ::std::os::raw::c_int, argv: *mut VALUE,
                           accept_shell: ::std::os::raw::c_int,
                           execarg_obj: VALUE) -> VALUE;
    pub fn rb_execarg_addopt(execarg_obj: VALUE, key: VALUE, val: VALUE)
     -> ::std::os::raw::c_int;
    pub fn rb_execarg_fixup(execarg_obj: VALUE);
    pub fn rb_execarg_run_options(e: *const Struct_rb_execarg,
                                  s: *mut Struct_rb_execarg,
                                  errmsg: *mut ::std::os::raw::c_char,
                                  errmsg_buflen: size_t)
     -> ::std::os::raw::c_int;
    pub fn rb_execarg_extract_options(execarg_obj: VALUE, opthash: VALUE)
     -> VALUE;
    pub fn rb_execarg_setenv(execarg_obj: VALUE, env: VALUE);
    pub fn rb_gcd_normal(_self: VALUE, other: VALUE) -> VALUE;
    pub fn rb_gcd_gmp(x: VALUE, y: VALUE) -> VALUE;
    pub fn ruby_scan_digits(str: *const ::std::os::raw::c_char, len: ssize_t,
                            base: ::std::os::raw::c_int, retlen: *mut size_t,
                            overflow: *mut ::std::os::raw::c_int)
     -> ::std::os::raw::c_ulong;
    pub fn rb_gc_mark_global_tbl();
    pub fn rb_mark_generic_ivar(arg1: VALUE);
    pub fn rb_mark_generic_ivar_tbl();
    pub fn rb_st_insert_id_and_value(obj: VALUE, tbl: *mut st_table, key: ID,
                                     value: VALUE) -> ::std::os::raw::c_int;
    pub fn rb_st_copy(obj: VALUE, orig_tbl: *mut Struct_st_table)
     -> *mut st_table;
    pub fn rb_obj_memsize_of(arg1: VALUE) -> size_t;
    pub fn rb_obj_gc_flags(arg1: VALUE, arg2: *mut ID, arg3: size_t)
     -> size_t;
    pub fn rb_add_method_cfunc(klass: VALUE, mid: ID,
                               func:
                                   ::std::option::Option<extern "C" fn()
                                                             -> VALUE>,
                               argc: ::std::os::raw::c_int,
                               noex: rb_method_flag_t);
    pub fn rb_add_method(klass: VALUE, mid: ID, _type: rb_method_type_t,
                         option: *mut ::std::os::raw::c_void,
                         noex: rb_method_flag_t) -> *mut rb_method_entry_t;
    pub fn rb_method_entry(klass: VALUE, id: ID, define_class_ptr: *mut VALUE)
     -> *mut rb_method_entry_t;
    pub fn rb_method_entry_at(obj: VALUE, id: ID) -> *mut rb_method_entry_t;
    pub fn rb_add_refined_method_entry(refined_class: VALUE, mid: ID);
    pub fn rb_resolve_refined_method(refinements: VALUE,
                                     me: *const rb_method_entry_t,
                                     defined_class_ptr: *mut VALUE)
     -> *mut rb_method_entry_t;
    pub fn rb_method_entry_with_refinements(klass: VALUE, id: ID,
                                            defined_class_ptr: *mut VALUE)
     -> *mut rb_method_entry_t;
    pub fn rb_method_entry_without_refinements(klass: VALUE, id: ID,
                                               defined_class_ptr: *mut VALUE)
     -> *mut rb_method_entry_t;
    pub fn rb_method_entry_get_without_cache(klass: VALUE, id: ID,
                                             define_class_ptr: *mut VALUE)
     -> *mut rb_method_entry_t;
    pub fn rb_method_entry_set(klass: VALUE, mid: ID,
                               arg1: *const rb_method_entry_t,
                               noex: rb_method_flag_t)
     -> *mut rb_method_entry_t;
    pub fn rb_method_entry_arity(me: *const rb_method_entry_t)
     -> ::std::os::raw::c_int;
    pub fn rb_method_entry_eq(m1: *const rb_method_entry_t,
                              m2: *const rb_method_entry_t)
     -> ::std::os::raw::c_int;
    pub fn rb_hash_method_entry(hash: st_index_t,
                                me: *const rb_method_entry_t) -> st_index_t;
    pub fn rb_method_entry_location(me: *mut rb_method_entry_t) -> VALUE;
    pub fn rb_mod_method_location(_mod: VALUE, id: ID) -> VALUE;
    pub fn rb_obj_method_location(obj: VALUE, id: ID) -> VALUE;
    pub fn rb_mark_method_entry(me: *const rb_method_entry_t);
    pub fn rb_free_method_entry(me: *mut rb_method_entry_t);
    pub fn rb_sweep_method_entry(vm: *mut ::std::os::raw::c_void);
    pub fn rb_free_m_tbl(tbl: *mut st_table);
    pub fn rb_free_m_tbl_wrapper(wrapper: *mut Struct_method_table_wrapper);
    pub fn rb_nativethread_self() -> rb_nativethread_id_t;
    pub fn rb_nativethread_lock_initialize(lock: *mut rb_nativethread_lock_t);
    pub fn rb_nativethread_lock_destroy(lock: *mut rb_nativethread_lock_t);
    pub fn rb_nativethread_lock_lock(lock: *mut rb_nativethread_lock_t);
    pub fn rb_nativethread_lock_unlock(lock: *mut rb_nativethread_lock_t);
    pub fn rb_objspace_free(arg1: *mut Struct_rb_objspace);
    pub fn rb_iseq_new(arg1: *mut NODE, arg2: VALUE, arg3: VALUE, arg4: VALUE,
                       arg5: VALUE, arg6: Enum_iseq_type) -> VALUE;
    pub fn rb_iseq_new_top(node: *mut NODE, name: VALUE, path: VALUE,
                           absolute_path: VALUE, parent: VALUE) -> VALUE;
    pub fn rb_iseq_new_main(node: *mut NODE, path: VALUE,
                            absolute_path: VALUE) -> VALUE;
    pub fn rb_iseq_new_with_bopt(arg1: *mut NODE, arg2: VALUE, arg3: VALUE,
                                 arg4: VALUE, arg5: VALUE, arg6: VALUE,
                                 arg7: Enum_iseq_type, arg8: VALUE) -> VALUE;
    pub fn rb_iseq_new_with_opt(arg1: *mut NODE, arg2: VALUE, arg3: VALUE,
                                arg4: VALUE, arg5: VALUE, arg6: VALUE,
                                arg7: Enum_iseq_type,
                                arg8: *const rb_compile_option_t) -> VALUE;
    pub fn rb_iseq_compile(src: VALUE, file: VALUE, line: VALUE) -> VALUE;
    pub fn rb_iseq_compile_on_base(src: VALUE, file: VALUE, line: VALUE,
                                   base_block: *mut rb_block_t) -> VALUE;
    pub fn rb_iseq_compile_with_option(src: VALUE, file: VALUE,
                                       absolute_path: VALUE, line: VALUE,
                                       base_block: *mut rb_block_t,
                                       opt: VALUE) -> VALUE;
    pub fn rb_iseq_disasm(_self: VALUE) -> VALUE;
    pub fn rb_iseq_disasm_insn(str: VALUE, iseqval: *mut VALUE, pos: size_t,
                               iseq: *mut rb_iseq_t, child: VALUE)
     -> ::std::os::raw::c_int;
    pub fn ruby_node_name(node: ::std::os::raw::c_int)
     -> *const ::std::os::raw::c_char;
    pub fn rb_vm_ep_local_ep(ep: *mut VALUE) -> *mut VALUE;
    pub fn rb_vm_control_frame_block_ptr(cfp: *mut rb_control_frame_t)
     -> *mut rb_block_t;
    pub fn rb_thread_alloc(klass: VALUE) -> VALUE;
    pub fn rb_proc_alloc(klass: VALUE) -> VALUE;
    pub fn rb_binding_alloc(klass: VALUE) -> VALUE;
    pub fn rb_vmdebug_stack_dump_raw(arg1: *mut rb_thread_t,
                                     arg2: *mut rb_control_frame_t);
    pub fn rb_vmdebug_debug_print_pre(th: *mut rb_thread_t,
                                      cfp: *mut rb_control_frame_t,
                                      _pc: *mut VALUE);
    pub fn rb_vmdebug_debug_print_post(th: *mut rb_thread_t,
                                       cfp: *mut rb_control_frame_t);
    pub fn rb_iseq_eval(iseqval: VALUE) -> VALUE;
    pub fn rb_iseq_eval_main(iseqval: VALUE) -> VALUE;
    pub fn rb_thread_method_id_and_class(th: *mut rb_thread_t, idp: *mut ID,
                                         klassp: *mut VALUE)
     -> ::std::os::raw::c_int;
    pub fn rb_vm_invoke_proc(th: *mut rb_thread_t, _proc: *mut rb_proc_t,
                             argc: ::std::os::raw::c_int, argv: *const VALUE,
                             blockptr: *const rb_block_t) -> VALUE;
    pub fn rb_vm_make_proc(th: *mut rb_thread_t, block: *const rb_block_t,
                           klass: VALUE) -> VALUE;
    pub fn rb_vm_make_binding(th: *mut rb_thread_t,
                              src_cfp: *const rb_control_frame_t) -> VALUE;
    pub fn rb_vm_make_env_object(th: *mut rb_thread_t,
                                 cfp: *mut rb_control_frame_t) -> VALUE;
    pub fn rb_binding_new_with_cfp(th: *mut rb_thread_t,
                                   src_cfp: *const rb_control_frame_t)
     -> VALUE;
    pub fn rb_binding_add_dynavars(bind: *mut rb_binding_t,
                                   dyncount: ::std::os::raw::c_int,
                                   dynvars: *const ID) -> *mut VALUE;
    pub fn rb_vm_gvl_destroy(vm: *mut rb_vm_t);
    pub fn rb_vm_call(th: *mut rb_thread_t, recv: VALUE, id: VALUE,
                      argc: ::std::os::raw::c_int, argv: *const VALUE,
                      me: *const rb_method_entry_t, defined_class: VALUE)
     -> VALUE;
    pub fn rb_unlink_method_entry(me: *mut rb_method_entry_t);
    pub fn rb_gc_mark_unlinked_live_method_entries(pvm:
                                                       *mut ::std::os::raw::c_void);
    pub fn rb_thread_start_timer_thread();
    pub fn rb_thread_stop_timer_thread(arg1: ::std::os::raw::c_int);
    pub fn rb_thread_reset_timer_thread();
    pub fn rb_thread_wakeup_timer_thread();
    pub fn ruby_thread_has_gvl_p() -> ::std::os::raw::c_int;
    pub fn rb_vm_get_ruby_level_next_cfp(th: *mut rb_thread_t,
                                         cfp: *const rb_control_frame_t)
     -> *mut rb_control_frame_t;
    pub fn rb_vm_get_binding_creatable_next_cfp(th: *mut rb_thread_t,
                                                cfp:
                                                    *const rb_control_frame_t)
     -> *mut rb_control_frame_t;
    pub fn rb_vm_get_sourceline(arg1: *const rb_control_frame_t)
     -> ::std::os::raw::c_int;
    pub fn rb_name_err_mesg_new(obj: VALUE, mesg: VALUE, recv: VALUE,
                                method: VALUE) -> VALUE;
    pub fn rb_vm_stack_to_heap(th: *mut rb_thread_t);
    pub fn ruby_thread_init_stack(th: *mut rb_thread_t);
    pub fn rb_vm_control_frame_id_and_class(cfp: *const rb_control_frame_t,
                                            idp: *mut ID, klassp: *mut VALUE)
     -> ::std::os::raw::c_int;
    pub fn rb_vm_rewind_cfp(th: *mut rb_thread_t,
                            cfp: *mut rb_control_frame_t);
    pub fn rb_gc_mark_machine_stack(th: *mut rb_thread_t);
    pub fn rb_autoloading_value(_mod: VALUE, id: ID, value: *mut VALUE)
     -> ::std::os::raw::c_int;
    pub fn rb_vm_rewrite_cref_stack(node: *mut NODE, old_klass: VALUE,
                                    new_klass: VALUE,
                                    new_cref_ptr: *mut *mut NODE);
    pub fn rb_signal_buff_size() -> ::std::os::raw::c_int;
    pub fn rb_signal_exec(th: *mut rb_thread_t, sig: ::std::os::raw::c_int);
    pub fn rb_threadptr_check_signal(mth: *mut rb_thread_t);
    pub fn rb_threadptr_signal_raise(th: *mut rb_thread_t,
                                     sig: ::std::os::raw::c_int);
    pub fn rb_threadptr_signal_exit(th: *mut rb_thread_t);
    pub fn rb_threadptr_execute_interrupts(arg1: *mut rb_thread_t,
                                           arg2: ::std::os::raw::c_int);
    pub fn rb_threadptr_interrupt(th: *mut rb_thread_t);
    pub fn rb_threadptr_unlock_all_locking_mutexes(th: *mut rb_thread_t);
    pub fn rb_threadptr_pending_interrupt_clear(th: *mut rb_thread_t);
    pub fn rb_threadptr_pending_interrupt_enque(th: *mut rb_thread_t,
                                                v: VALUE);
    pub fn rb_threadptr_pending_interrupt_active_p(th: *mut rb_thread_t)
     -> ::std::os::raw::c_int;
    pub fn rb_threadptr_exec_event_hooks(trace_arg:
                                             *mut Struct_rb_trace_arg_struct);
    pub fn rb_threadptr_exec_event_hooks_and_pop_frame(trace_arg:
                                                           *mut Struct_rb_trace_arg_struct);
    pub fn rb_threadptr_reset_recursive_data(th: *mut rb_thread_t) -> VALUE;
    pub fn rb_threadptr_restore_recursive_data(th: *mut rb_thread_t,
                                               old: VALUE);
    pub fn rb_thread_check_trap_pending() -> ::std::os::raw::c_int;
    pub fn rb_set_coverages(arg1: VALUE);
    pub fn rb_reset_coverages();
    pub fn rb_postponed_job_flush(vm: *mut rb_vm_t);
}
