/* automatically generated by rust-bindgen */
#![allow(warnings)]

pub type __int128_t = ::std::os::raw::c_void;
pub type __uint128_t = ::std::os::raw::c_void;
pub type __builtin_va_list = [__va_list_tag; 1usize];
pub type ptrdiff_t = ::std::os::raw::c_long;
pub type size_t = ::std::os::raw::c_ulong;
pub type wchar_t = ::std::os::raw::c_int;
pub type __u_char = ::std::os::raw::c_uchar;
pub type __u_short = ::std::os::raw::c_ushort;
pub type __u_int = ::std::os::raw::c_uint;
pub type __u_long = ::std::os::raw::c_ulong;
pub type __int8_t = ::std::os::raw::c_char;
pub type __uint8_t = ::std::os::raw::c_uchar;
pub type __int16_t = ::std::os::raw::c_short;
pub type __uint16_t = ::std::os::raw::c_ushort;
pub type __int32_t = ::std::os::raw::c_int;
pub type __uint32_t = ::std::os::raw::c_uint;
pub type __int64_t = ::std::os::raw::c_long;
pub type __uint64_t = ::std::os::raw::c_ulong;
pub type __quad_t = ::std::os::raw::c_long;
pub type __u_quad_t = ::std::os::raw::c_ulong;
pub type __dev_t = ::std::os::raw::c_ulong;
pub type __uid_t = ::std::os::raw::c_uint;
pub type __gid_t = ::std::os::raw::c_uint;
pub type __ino_t = ::std::os::raw::c_ulong;
pub type __ino64_t = ::std::os::raw::c_ulong;
pub type __mode_t = ::std::os::raw::c_uint;
pub type __nlink_t = ::std::os::raw::c_ulong;
pub type __off_t = ::std::os::raw::c_long;
pub type __off64_t = ::std::os::raw::c_long;
pub type __pid_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_Unnamed1 {
    pub __val: [::std::os::raw::c_int; 2usize],
}
impl ::std::clone::Clone for Struct_Unnamed1 {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_Unnamed1 {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type __fsid_t = Struct_Unnamed1;
pub type __clock_t = ::std::os::raw::c_long;
pub type __rlim_t = ::std::os::raw::c_ulong;
pub type __rlim64_t = ::std::os::raw::c_ulong;
pub type __id_t = ::std::os::raw::c_uint;
pub type __time_t = ::std::os::raw::c_long;
pub type __useconds_t = ::std::os::raw::c_uint;
pub type __suseconds_t = ::std::os::raw::c_long;
pub type __daddr_t = ::std::os::raw::c_int;
pub type __swblk_t = ::std::os::raw::c_long;
pub type __key_t = ::std::os::raw::c_int;
pub type __clockid_t = ::std::os::raw::c_int;
pub type __timer_t = *mut ::std::os::raw::c_void;
pub type __blksize_t = ::std::os::raw::c_long;
pub type __blkcnt_t = ::std::os::raw::c_long;
pub type __blkcnt64_t = ::std::os::raw::c_long;
pub type __fsblkcnt_t = ::std::os::raw::c_ulong;
pub type __fsblkcnt64_t = ::std::os::raw::c_ulong;
pub type __fsfilcnt_t = ::std::os::raw::c_ulong;
pub type __fsfilcnt64_t = ::std::os::raw::c_ulong;
pub type __ssize_t = ::std::os::raw::c_long;
pub type __loff_t = __off64_t;
pub type __qaddr_t = *mut __quad_t;
pub type __caddr_t = *mut ::std::os::raw::c_char;
pub type __intptr_t = ::std::os::raw::c_long;
pub type __socklen_t = ::std::os::raw::c_uint;
pub type FILE = Struct__IO_FILE;
pub type __FILE = Struct__IO_FILE;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_Unnamed2 {
    pub __count: ::std::os::raw::c_int,
    pub __value: Union_Unnamed3,
}
impl ::std::clone::Clone for Struct_Unnamed2 {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_Unnamed2 {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub struct Union_Unnamed3 {
    pub _bindgen_data_: [u32; 1usize],
}
impl Union_Unnamed3 {
    pub unsafe fn __wch(&mut self) -> *mut ::std::os::raw::c_uint {
        let raw: *mut u8 = ::std::mem::transmute(&self._bindgen_data_);
        ::std::mem::transmute(raw.offset(0))
    }
    pub unsafe fn __wchb(&mut self) -> *mut [::std::os::raw::c_char; 4usize] {
        let raw: *mut u8 = ::std::mem::transmute(&self._bindgen_data_);
        ::std::mem::transmute(raw.offset(0))
    }
}
impl ::std::clone::Clone for Union_Unnamed3 {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Union_Unnamed3 {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type __mbstate_t = Struct_Unnamed2;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_Unnamed4 {
    pub __pos: __off_t,
    pub __state: __mbstate_t,
}
impl ::std::clone::Clone for Struct_Unnamed4 {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_Unnamed4 {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type _G_fpos_t = Struct_Unnamed4;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_Unnamed5 {
    pub __pos: __off64_t,
    pub __state: __mbstate_t,
}
impl ::std::clone::Clone for Struct_Unnamed5 {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_Unnamed5 {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type _G_fpos64_t = Struct_Unnamed5;
pub type _G_int16_t = ::std::os::raw::c_short;
pub type _G_int32_t = ::std::os::raw::c_int;
pub type _G_uint16_t = ::std::os::raw::c_ushort;
pub type _G_uint32_t = ::std::os::raw::c_uint;
pub type va_list = __gnuc_va_list;
pub type __gnuc_va_list = __builtin_va_list;
pub enum Struct__IO_jump_t { }
pub type _IO_lock_t = ::std::os::raw::c_void;
#[repr(C)]
#[derive(Copy)]
pub struct Struct__IO_marker {
    pub _next: *mut Struct__IO_marker,
    pub _sbuf: *mut Struct__IO_FILE,
    pub _pos: ::std::os::raw::c_int,
}
impl ::std::clone::Clone for Struct__IO_marker {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct__IO_marker {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[derive(Clone, Copy)]
#[repr(u32)]
pub enum Enum___codecvt_result {
    __codecvt_ok = 0,
    __codecvt_partial = 1,
    __codecvt_error = 2,
    __codecvt_noconv = 3,
}
#[repr(C)]
#[derive(Copy)]
pub struct Struct__IO_FILE {
    pub _flags: ::std::os::raw::c_int,
    pub _IO_read_ptr: *mut ::std::os::raw::c_char,
    pub _IO_read_end: *mut ::std::os::raw::c_char,
    pub _IO_read_base: *mut ::std::os::raw::c_char,
    pub _IO_write_base: *mut ::std::os::raw::c_char,
    pub _IO_write_ptr: *mut ::std::os::raw::c_char,
    pub _IO_write_end: *mut ::std::os::raw::c_char,
    pub _IO_buf_base: *mut ::std::os::raw::c_char,
    pub _IO_buf_end: *mut ::std::os::raw::c_char,
    pub _IO_save_base: *mut ::std::os::raw::c_char,
    pub _IO_backup_base: *mut ::std::os::raw::c_char,
    pub _IO_save_end: *mut ::std::os::raw::c_char,
    pub _markers: *mut Struct__IO_marker,
    pub _chain: *mut Struct__IO_FILE,
    pub _fileno: ::std::os::raw::c_int,
    pub _flags2: ::std::os::raw::c_int,
    pub _old_offset: __off_t,
    pub _cur_column: ::std::os::raw::c_ushort,
    pub _vtable_offset: ::std::os::raw::c_char,
    pub _shortbuf: [::std::os::raw::c_char; 1usize],
    pub _lock: *mut _IO_lock_t,
    pub _offset: __off64_t,
    pub __pad1: *mut ::std::os::raw::c_void,
    pub __pad2: *mut ::std::os::raw::c_void,
    pub __pad3: *mut ::std::os::raw::c_void,
    pub __pad4: *mut ::std::os::raw::c_void,
    pub __pad5: size_t,
    pub _mode: ::std::os::raw::c_int,
    pub _unused2: [::std::os::raw::c_char; 20usize],
}
impl ::std::clone::Clone for Struct__IO_FILE {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct__IO_FILE {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type _IO_FILE = Struct__IO_FILE;
pub enum Struct__IO_FILE_plus { }
pub type __io_read_fn =
    unsafe extern "C" fn(__cookie: *mut ::std::os::raw::c_void,
                         __buf: *mut ::std::os::raw::c_char, __nbytes: size_t)
        -> __ssize_t;
pub type __io_write_fn =
    unsafe extern "C" fn(__cookie: *mut ::std::os::raw::c_void,
                         __buf: *const ::std::os::raw::c_char, __n: size_t)
        -> __ssize_t;
pub type __io_seek_fn =
    unsafe extern "C" fn(__cookie: *mut ::std::os::raw::c_void,
                         __pos: *mut __off64_t, __w: ::std::os::raw::c_int)
        -> ::std::os::raw::c_int;
pub type __io_close_fn =
    unsafe extern "C" fn(__cookie: *mut ::std::os::raw::c_void)
        -> ::std::os::raw::c_int;
pub type cookie_read_function_t = __io_read_fn;
pub type cookie_write_function_t = __io_write_fn;
pub type cookie_seek_function_t = __io_seek_fn;
pub type cookie_close_function_t = __io_close_fn;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_Unnamed6 {
    pub read: *mut ::std::option::Option<extern "C" fn() -> __ssize_t>,
    pub write: *mut ::std::option::Option<extern "C" fn() -> __ssize_t>,
    pub seek: *mut ::std::option::Option<extern "C" fn()
                                             -> ::std::os::raw::c_int>,
    pub close: *mut ::std::option::Option<extern "C" fn()
                                              -> ::std::os::raw::c_int>,
}
impl ::std::clone::Clone for Struct_Unnamed6 {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_Unnamed6 {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type _IO_cookie_io_functions_t = Struct_Unnamed6;
pub type cookie_io_functions_t = _IO_cookie_io_functions_t;
pub enum Struct__IO_cookie_file { }
pub type off_t = __off_t;
pub type off64_t = __off64_t;
pub type ssize_t = __ssize_t;
pub type fpos_t = _G_fpos_t;
pub type fpos64_t = _G_fpos64_t;
pub enum Struct_obstack { }
pub type u_char = __u_char;
pub type u_short = __u_short;
pub type u_int = __u_int;
pub type u_long = __u_long;
pub type quad_t = __quad_t;
pub type u_quad_t = __u_quad_t;
pub type fsid_t = __fsid_t;
pub type loff_t = __loff_t;
pub type ino_t = __ino_t;
pub type ino64_t = __ino64_t;
pub type dev_t = __dev_t;
pub type gid_t = __gid_t;
pub type mode_t = __mode_t;
pub type nlink_t = __nlink_t;
pub type uid_t = __uid_t;
pub type pid_t = __pid_t;
pub type id_t = __id_t;
pub type daddr_t = __daddr_t;
pub type caddr_t = __caddr_t;
pub type key_t = __key_t;
pub type clock_t = __clock_t;
pub type time_t = __time_t;
pub type clockid_t = __clockid_t;
pub type timer_t = __timer_t;
pub type useconds_t = __useconds_t;
pub type suseconds_t = __suseconds_t;
pub type ulong = ::std::os::raw::c_ulong;
pub type ushort = ::std::os::raw::c_ushort;
pub type _uint = ::std::os::raw::c_uint;
pub type int8_t = ::std::os::raw::c_char;
pub type int16_t = ::std::os::raw::c_short;
pub type int32_t = ::std::os::raw::c_int;
pub type int64_t = ::std::os::raw::c_long;
pub type u_int8_t = ::std::os::raw::c_uchar;
pub type u_int16_t = ::std::os::raw::c_ushort;
pub type u_int32_t = ::std::os::raw::c_uint;
pub type u_int64_t = ::std::os::raw::c_ulong;
pub type register_t = ::std::os::raw::c_long;
pub type __sig_atomic_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_Unnamed7 {
    pub __val: [::std::os::raw::c_ulong; 16usize],
}
impl ::std::clone::Clone for Struct_Unnamed7 {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_Unnamed7 {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type __sigset_t = Struct_Unnamed7;
pub type sigset_t = __sigset_t;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_timespec {
    pub tv_sec: __time_t,
    pub tv_nsec: ::std::os::raw::c_long,
}
impl ::std::clone::Clone for Struct_timespec {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_timespec {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub struct Struct_timeval {
    pub tv_sec: __time_t,
    pub tv_usec: __suseconds_t,
}
impl ::std::clone::Clone for Struct_timeval {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_timeval {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type __fd_mask = ::std::os::raw::c_long;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_Unnamed8 {
    pub fds_bits: [__fd_mask; 16usize],
}
impl ::std::clone::Clone for Struct_Unnamed8 {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_Unnamed8 {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type fd_set = Struct_Unnamed8;
pub type fd_mask = __fd_mask;
pub type blksize_t = __blksize_t;
pub type blkcnt_t = __blkcnt_t;
pub type fsblkcnt_t = __fsblkcnt_t;
pub type fsfilcnt_t = __fsfilcnt_t;
pub type blkcnt64_t = __blkcnt64_t;
pub type fsblkcnt64_t = __fsblkcnt64_t;
pub type fsfilcnt64_t = __fsfilcnt64_t;
pub type pthread_t = ::std::os::raw::c_ulong;
#[repr(C)]
#[derive(Copy)]
pub struct Union_Unnamed9 {
    pub _bindgen_data_: [u64; 7usize],
}
impl Union_Unnamed9 {
    pub unsafe fn __size(&mut self)
     -> *mut [::std::os::raw::c_char; 56usize] {
        let raw: *mut u8 = ::std::mem::transmute(&self._bindgen_data_);
        ::std::mem::transmute(raw.offset(0))
    }
    pub unsafe fn __align(&mut self) -> *mut ::std::os::raw::c_long {
        let raw: *mut u8 = ::std::mem::transmute(&self._bindgen_data_);
        ::std::mem::transmute(raw.offset(0))
    }
}
impl ::std::clone::Clone for Union_Unnamed9 {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Union_Unnamed9 {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type pthread_attr_t = Union_Unnamed9;
#[repr(C)]
#[derive(Copy)]
pub struct Struct___pthread_internal_list {
    pub __prev: *mut Struct___pthread_internal_list,
    pub __next: *mut Struct___pthread_internal_list,
}
impl ::std::clone::Clone for Struct___pthread_internal_list {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct___pthread_internal_list {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type __pthread_list_t = Struct___pthread_internal_list;
#[repr(C)]
#[derive(Copy)]
pub struct Union_Unnamed10 {
    pub _bindgen_data_: [u64; 5usize],
}
impl Union_Unnamed10 {
    pub unsafe fn __data(&mut self) -> *mut Struct___pthread_mutex_s {
        let raw: *mut u8 = ::std::mem::transmute(&self._bindgen_data_);
        ::std::mem::transmute(raw.offset(0))
    }
    pub unsafe fn __size(&mut self)
     -> *mut [::std::os::raw::c_char; 40usize] {
        let raw: *mut u8 = ::std::mem::transmute(&self._bindgen_data_);
        ::std::mem::transmute(raw.offset(0))
    }
    pub unsafe fn __align(&mut self) -> *mut ::std::os::raw::c_long {
        let raw: *mut u8 = ::std::mem::transmute(&self._bindgen_data_);
        ::std::mem::transmute(raw.offset(0))
    }
}
impl ::std::clone::Clone for Union_Unnamed10 {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Union_Unnamed10 {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub struct Struct___pthread_mutex_s {
    pub __lock: ::std::os::raw::c_int,
    pub __count: ::std::os::raw::c_uint,
    pub __owner: ::std::os::raw::c_int,
    pub __nusers: ::std::os::raw::c_uint,
    pub __kind: ::std::os::raw::c_int,
    pub __spins: ::std::os::raw::c_int,
    pub __list: __pthread_list_t,
}
impl ::std::clone::Clone for Struct___pthread_mutex_s {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct___pthread_mutex_s {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type pthread_mutex_t = Union_Unnamed10;
#[repr(C)]
#[derive(Copy)]
pub struct Union_Unnamed11 {
    pub _bindgen_data_: [u32; 1usize],
}
impl Union_Unnamed11 {
    pub unsafe fn __size(&mut self) -> *mut [::std::os::raw::c_char; 4usize] {
        let raw: *mut u8 = ::std::mem::transmute(&self._bindgen_data_);
        ::std::mem::transmute(raw.offset(0))
    }
    pub unsafe fn __align(&mut self) -> *mut ::std::os::raw::c_int {
        let raw: *mut u8 = ::std::mem::transmute(&self._bindgen_data_);
        ::std::mem::transmute(raw.offset(0))
    }
}
impl ::std::clone::Clone for Union_Unnamed11 {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Union_Unnamed11 {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type pthread_mutexattr_t = Union_Unnamed11;
#[repr(C)]
#[derive(Copy)]
pub struct Union_Unnamed12 {
    pub _bindgen_data_: [u64; 6usize],
}
impl Union_Unnamed12 {
    pub unsafe fn __data(&mut self) -> *mut Struct_Unnamed13 {
        let raw: *mut u8 = ::std::mem::transmute(&self._bindgen_data_);
        ::std::mem::transmute(raw.offset(0))
    }
    pub unsafe fn __size(&mut self)
     -> *mut [::std::os::raw::c_char; 48usize] {
        let raw: *mut u8 = ::std::mem::transmute(&self._bindgen_data_);
        ::std::mem::transmute(raw.offset(0))
    }
    pub unsafe fn __align(&mut self) -> *mut ::std::os::raw::c_longlong {
        let raw: *mut u8 = ::std::mem::transmute(&self._bindgen_data_);
        ::std::mem::transmute(raw.offset(0))
    }
}
impl ::std::clone::Clone for Union_Unnamed12 {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Union_Unnamed12 {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub struct Struct_Unnamed13 {
    pub __lock: ::std::os::raw::c_int,
    pub __futex: ::std::os::raw::c_uint,
    pub __total_seq: ::std::os::raw::c_ulonglong,
    pub __wakeup_seq: ::std::os::raw::c_ulonglong,
    pub __woken_seq: ::std::os::raw::c_ulonglong,
    pub __mutex: *mut ::std::os::raw::c_void,
    pub __nwaiters: ::std::os::raw::c_uint,
    pub __broadcast_seq: ::std::os::raw::c_uint,
}
impl ::std::clone::Clone for Struct_Unnamed13 {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_Unnamed13 {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type pthread_cond_t = Union_Unnamed12;
#[repr(C)]
#[derive(Copy)]
pub struct Union_Unnamed14 {
    pub _bindgen_data_: [u32; 1usize],
}
impl Union_Unnamed14 {
    pub unsafe fn __size(&mut self) -> *mut [::std::os::raw::c_char; 4usize] {
        let raw: *mut u8 = ::std::mem::transmute(&self._bindgen_data_);
        ::std::mem::transmute(raw.offset(0))
    }
    pub unsafe fn __align(&mut self) -> *mut ::std::os::raw::c_int {
        let raw: *mut u8 = ::std::mem::transmute(&self._bindgen_data_);
        ::std::mem::transmute(raw.offset(0))
    }
}
impl ::std::clone::Clone for Union_Unnamed14 {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Union_Unnamed14 {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type pthread_condattr_t = Union_Unnamed14;
pub type pthread_key_t = ::std::os::raw::c_uint;
pub type pthread_once_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Copy)]
pub struct Union_Unnamed15 {
    pub _bindgen_data_: [u64; 7usize],
}
impl Union_Unnamed15 {
    pub unsafe fn __data(&mut self) -> *mut Struct_Unnamed16 {
        let raw: *mut u8 = ::std::mem::transmute(&self._bindgen_data_);
        ::std::mem::transmute(raw.offset(0))
    }
    pub unsafe fn __size(&mut self)
     -> *mut [::std::os::raw::c_char; 56usize] {
        let raw: *mut u8 = ::std::mem::transmute(&self._bindgen_data_);
        ::std::mem::transmute(raw.offset(0))
    }
    pub unsafe fn __align(&mut self) -> *mut ::std::os::raw::c_long {
        let raw: *mut u8 = ::std::mem::transmute(&self._bindgen_data_);
        ::std::mem::transmute(raw.offset(0))
    }
}
impl ::std::clone::Clone for Union_Unnamed15 {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Union_Unnamed15 {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub struct Struct_Unnamed16 {
    pub __lock: ::std::os::raw::c_int,
    pub __nr_readers: ::std::os::raw::c_uint,
    pub __readers_wakeup: ::std::os::raw::c_uint,
    pub __writer_wakeup: ::std::os::raw::c_uint,
    pub __nr_readers_queued: ::std::os::raw::c_uint,
    pub __nr_writers_queued: ::std::os::raw::c_uint,
    pub __writer: ::std::os::raw::c_int,
    pub __shared: ::std::os::raw::c_int,
    pub __pad1: ::std::os::raw::c_ulong,
    pub __pad2: ::std::os::raw::c_ulong,
    pub __flags: ::std::os::raw::c_uint,
}
impl ::std::clone::Clone for Struct_Unnamed16 {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_Unnamed16 {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type pthread_rwlock_t = Union_Unnamed15;
#[repr(C)]
#[derive(Copy)]
pub struct Union_Unnamed17 {
    pub _bindgen_data_: [u64; 1usize],
}
impl Union_Unnamed17 {
    pub unsafe fn __size(&mut self) -> *mut [::std::os::raw::c_char; 8usize] {
        let raw: *mut u8 = ::std::mem::transmute(&self._bindgen_data_);
        ::std::mem::transmute(raw.offset(0))
    }
    pub unsafe fn __align(&mut self) -> *mut ::std::os::raw::c_long {
        let raw: *mut u8 = ::std::mem::transmute(&self._bindgen_data_);
        ::std::mem::transmute(raw.offset(0))
    }
}
impl ::std::clone::Clone for Union_Unnamed17 {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Union_Unnamed17 {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type pthread_rwlockattr_t = Union_Unnamed17;
pub type pthread_spinlock_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Copy)]
pub struct Union_Unnamed18 {
    pub _bindgen_data_: [u64; 4usize],
}
impl Union_Unnamed18 {
    pub unsafe fn __size(&mut self)
     -> *mut [::std::os::raw::c_char; 32usize] {
        let raw: *mut u8 = ::std::mem::transmute(&self._bindgen_data_);
        ::std::mem::transmute(raw.offset(0))
    }
    pub unsafe fn __align(&mut self) -> *mut ::std::os::raw::c_long {
        let raw: *mut u8 = ::std::mem::transmute(&self._bindgen_data_);
        ::std::mem::transmute(raw.offset(0))
    }
}
impl ::std::clone::Clone for Union_Unnamed18 {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Union_Unnamed18 {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type pthread_barrier_t = Union_Unnamed18;
#[repr(C)]
#[derive(Copy)]
pub struct Union_Unnamed19 {
    pub _bindgen_data_: [u32; 1usize],
}
impl Union_Unnamed19 {
    pub unsafe fn __size(&mut self) -> *mut [::std::os::raw::c_char; 4usize] {
        let raw: *mut u8 = ::std::mem::transmute(&self._bindgen_data_);
        ::std::mem::transmute(raw.offset(0))
    }
    pub unsafe fn __align(&mut self) -> *mut ::std::os::raw::c_int {
        let raw: *mut u8 = ::std::mem::transmute(&self._bindgen_data_);
        ::std::mem::transmute(raw.offset(0))
    }
}
impl ::std::clone::Clone for Union_Unnamed19 {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Union_Unnamed19 {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type pthread_barrierattr_t = Union_Unnamed19;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_stat {
    pub st_dev: __dev_t,
    pub st_ino: __ino_t,
    pub st_nlink: __nlink_t,
    pub st_mode: __mode_t,
    pub st_uid: __uid_t,
    pub st_gid: __gid_t,
    pub __pad0: ::std::os::raw::c_int,
    pub st_rdev: __dev_t,
    pub st_size: __off_t,
    pub st_blksize: __blksize_t,
    pub st_blocks: __blkcnt_t,
    pub st_atim: Struct_timespec,
    pub st_mtim: Struct_timespec,
    pub st_ctim: Struct_timespec,
    pub __unused: [::std::os::raw::c_long; 3usize],
}
impl ::std::clone::Clone for Struct_stat {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_stat {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub struct Struct_stat64 {
    pub st_dev: __dev_t,
    pub st_ino: __ino64_t,
    pub st_nlink: __nlink_t,
    pub st_mode: __mode_t,
    pub st_uid: __uid_t,
    pub st_gid: __gid_t,
    pub __pad0: ::std::os::raw::c_int,
    pub st_rdev: __dev_t,
    pub st_size: __off_t,
    pub st_blksize: __blksize_t,
    pub st_blocks: __blkcnt64_t,
    pub st_atim: Struct_timespec,
    pub st_mtim: Struct_timespec,
    pub st_ctim: Struct_timespec,
    pub __unused: [::std::os::raw::c_long; 3usize],
}
impl ::std::clone::Clone for Struct_stat64 {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_stat64 {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub struct Union_wait {
    pub _bindgen_data_: [u32; 1usize],
}
impl Union_wait {
    pub unsafe fn w_status(&mut self) -> *mut ::std::os::raw::c_int {
        let raw: *mut u8 = ::std::mem::transmute(&self._bindgen_data_);
        ::std::mem::transmute(raw.offset(0))
    }
    pub unsafe fn __wait_terminated(&mut self) -> *mut Struct_Unnamed20 {
        let raw: *mut u8 = ::std::mem::transmute(&self._bindgen_data_);
        ::std::mem::transmute(raw.offset(0))
    }
    pub unsafe fn __wait_stopped(&mut self) -> *mut Struct_Unnamed21 {
        let raw: *mut u8 = ::std::mem::transmute(&self._bindgen_data_);
        ::std::mem::transmute(raw.offset(0))
    }
}
impl ::std::clone::Clone for Union_wait {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Union_wait {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub struct Struct_Unnamed20 {
    pub _bindgen_bitfield_1_: ::std::os::raw::c_uint,
}
impl ::std::clone::Clone for Struct_Unnamed20 {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_Unnamed20 {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub struct Struct_Unnamed21 {
    pub _bindgen_bitfield_1_: ::std::os::raw::c_uint,
}
impl ::std::clone::Clone for Struct_Unnamed21 {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_Unnamed21 {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub struct Union_Unnamed22 {
    pub _bindgen_data_: [u64; 1usize],
}
impl Union_Unnamed22 {
    pub unsafe fn __uptr(&mut self) -> *mut *mut Union_wait {
        let raw: *mut u8 = ::std::mem::transmute(&self._bindgen_data_);
        ::std::mem::transmute(raw.offset(0))
    }
    pub unsafe fn __iptr(&mut self) -> *mut *mut ::std::os::raw::c_int {
        let raw: *mut u8 = ::std::mem::transmute(&self._bindgen_data_);
        ::std::mem::transmute(raw.offset(0))
    }
}
impl ::std::clone::Clone for Union_Unnamed22 {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Union_Unnamed22 {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type __WAIT_STATUS = Union_Unnamed22;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_Unnamed23 {
    pub quot: ::std::os::raw::c_int,
    pub rem: ::std::os::raw::c_int,
}
impl ::std::clone::Clone for Struct_Unnamed23 {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_Unnamed23 {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type div_t = Struct_Unnamed23;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_Unnamed24 {
    pub quot: ::std::os::raw::c_long,
    pub rem: ::std::os::raw::c_long,
}
impl ::std::clone::Clone for Struct_Unnamed24 {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_Unnamed24 {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type ldiv_t = Struct_Unnamed24;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_Unnamed25 {
    pub quot: ::std::os::raw::c_longlong,
    pub rem: ::std::os::raw::c_longlong,
}
impl ::std::clone::Clone for Struct_Unnamed25 {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_Unnamed25 {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type lldiv_t = Struct_Unnamed25;
pub enum Struct___locale_data { }
#[repr(C)]
#[derive(Copy)]
pub struct Struct___locale_struct {
    pub __locales: [*mut Struct___locale_data; 13usize],
    pub __ctype_b: *const ::std::os::raw::c_ushort,
    pub __ctype_tolower: *const ::std::os::raw::c_int,
    pub __ctype_toupper: *const ::std::os::raw::c_int,
    pub __names: [*const ::std::os::raw::c_char; 13usize],
}
impl ::std::clone::Clone for Struct___locale_struct {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct___locale_struct {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type __locale_t = *mut Struct___locale_struct;
pub type locale_t = __locale_t;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_random_data {
    pub fptr: *mut int32_t,
    pub rptr: *mut int32_t,
    pub state: *mut int32_t,
    pub rand_type: ::std::os::raw::c_int,
    pub rand_deg: ::std::os::raw::c_int,
    pub rand_sep: ::std::os::raw::c_int,
    pub end_ptr: *mut int32_t,
}
impl ::std::clone::Clone for Struct_random_data {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_random_data {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub struct Struct_drand48_data {
    pub __x: [::std::os::raw::c_ushort; 3usize],
    pub __old_x: [::std::os::raw::c_ushort; 3usize],
    pub __c: ::std::os::raw::c_ushort,
    pub __init: ::std::os::raw::c_ushort,
    pub __a: ::std::os::raw::c_ulonglong,
}
impl ::std::clone::Clone for Struct_drand48_data {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_drand48_data {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type __compar_fn_t =
    ::std::option::Option<unsafe extern "C" fn(arg1:
                                                   *const ::std::os::raw::c_void,
                                               arg2:
                                                   *const ::std::os::raw::c_void)
                              -> ::std::os::raw::c_int>;
pub type comparison_fn_t = __compar_fn_t;
pub type __compar_d_fn_t =
    ::std::option::Option<unsafe extern "C" fn(arg1:
                                                   *const ::std::os::raw::c_void,
                                               arg2:
                                                   *const ::std::os::raw::c_void,
                                               arg3:
                                                   *mut ::std::os::raw::c_void)
                              -> ::std::os::raw::c_int>;
pub type uint8_t = ::std::os::raw::c_uchar;
pub type uint16_t = ::std::os::raw::c_ushort;
pub type uint32_t = ::std::os::raw::c_uint;
pub type uint64_t = ::std::os::raw::c_ulong;
pub type int_least8_t = ::std::os::raw::c_char;
pub type int_least16_t = ::std::os::raw::c_short;
pub type int_least32_t = ::std::os::raw::c_int;
pub type int_least64_t = ::std::os::raw::c_long;
pub type uint_least8_t = ::std::os::raw::c_uchar;
pub type uint_least16_t = ::std::os::raw::c_ushort;
pub type uint_least32_t = ::std::os::raw::c_uint;
pub type uint_least64_t = ::std::os::raw::c_ulong;
pub type int_fast8_t = ::std::os::raw::c_char;
pub type int_fast16_t = ::std::os::raw::c_long;
pub type int_fast32_t = ::std::os::raw::c_long;
pub type int_fast64_t = ::std::os::raw::c_long;
pub type uint_fast8_t = ::std::os::raw::c_uchar;
pub type uint_fast16_t = ::std::os::raw::c_ulong;
pub type uint_fast32_t = ::std::os::raw::c_ulong;
pub type uint_fast64_t = ::std::os::raw::c_ulong;
pub type intptr_t = ::std::os::raw::c_long;
pub type uintptr_t = ::std::os::raw::c_ulong;
pub type intmax_t = ::std::os::raw::c_long;
pub type uintmax_t = ::std::os::raw::c_ulong;
pub type __gwchar_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_Unnamed26 {
    pub quot: ::std::os::raw::c_long,
    pub rem: ::std::os::raw::c_long,
}
impl ::std::clone::Clone for Struct_Unnamed26 {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_Unnamed26 {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type imaxdiv_t = Struct_Unnamed26;
pub type socklen_t = __socklen_t;
#[derive(Clone, Copy)]
#[repr(u32)]
pub enum Enum_Unnamed27 {
    _PC_LINK_MAX = 0,
    _PC_MAX_CANON = 1,
    _PC_MAX_INPUT = 2,
    _PC_NAME_MAX = 3,
    _PC_PATH_MAX = 4,
    _PC_PIPE_BUF = 5,
    _PC_CHOWN_RESTRICTED = 6,
    _PC_NO_TRUNC = 7,
    _PC_VDISABLE = 8,
    _PC_SYNC_IO = 9,
    _PC_ASYNC_IO = 10,
    _PC_PRIO_IO = 11,
    _PC_SOCK_MAXBUF = 12,
    _PC_FILESIZEBITS = 13,
    _PC_REC_INCR_XFER_SIZE = 14,
    _PC_REC_MAX_XFER_SIZE = 15,
    _PC_REC_MIN_XFER_SIZE = 16,
    _PC_REC_XFER_ALIGN = 17,
    _PC_ALLOC_SIZE_MIN = 18,
    _PC_SYMLINK_MAX = 19,
    _PC_2_SYMLINKS = 20,
}
pub const _SC_IOV_MAX: Enum_Unnamed28 = Enum_Unnamed28::_SC_UIO_MAXIOV;
#[derive(Clone, Copy)]
#[repr(u32)]
pub enum Enum_Unnamed28 {
    _SC_ARG_MAX = 0,
    _SC_CHILD_MAX = 1,
    _SC_CLK_TCK = 2,
    _SC_NGROUPS_MAX = 3,
    _SC_OPEN_MAX = 4,
    _SC_STREAM_MAX = 5,
    _SC_TZNAME_MAX = 6,
    _SC_JOB_CONTROL = 7,
    _SC_SAVED_IDS = 8,
    _SC_REALTIME_SIGNALS = 9,
    _SC_PRIORITY_SCHEDULING = 10,
    _SC_TIMERS = 11,
    _SC_ASYNCHRONOUS_IO = 12,
    _SC_PRIORITIZED_IO = 13,
    _SC_SYNCHRONIZED_IO = 14,
    _SC_FSYNC = 15,
    _SC_MAPPED_FILES = 16,
    _SC_MEMLOCK = 17,
    _SC_MEMLOCK_RANGE = 18,
    _SC_MEMORY_PROTECTION = 19,
    _SC_MESSAGE_PASSING = 20,
    _SC_SEMAPHORES = 21,
    _SC_SHARED_MEMORY_OBJECTS = 22,
    _SC_AIO_LISTIO_MAX = 23,
    _SC_AIO_MAX = 24,
    _SC_AIO_PRIO_DELTA_MAX = 25,
    _SC_DELAYTIMER_MAX = 26,
    _SC_MQ_OPEN_MAX = 27,
    _SC_MQ_PRIO_MAX = 28,
    _SC_VERSION = 29,
    _SC_PAGESIZE = 30,
    _SC_RTSIG_MAX = 31,
    _SC_SEM_NSEMS_MAX = 32,
    _SC_SEM_VALUE_MAX = 33,
    _SC_SIGQUEUE_MAX = 34,
    _SC_TIMER_MAX = 35,
    _SC_BC_BASE_MAX = 36,
    _SC_BC_DIM_MAX = 37,
    _SC_BC_SCALE_MAX = 38,
    _SC_BC_STRING_MAX = 39,
    _SC_COLL_WEIGHTS_MAX = 40,
    _SC_EQUIV_CLASS_MAX = 41,
    _SC_EXPR_NEST_MAX = 42,
    _SC_LINE_MAX = 43,
    _SC_RE_DUP_MAX = 44,
    _SC_CHARCLASS_NAME_MAX = 45,
    _SC_2_VERSION = 46,
    _SC_2_C_BIND = 47,
    _SC_2_C_DEV = 48,
    _SC_2_FORT_DEV = 49,
    _SC_2_FORT_RUN = 50,
    _SC_2_SW_DEV = 51,
    _SC_2_LOCALEDEF = 52,
    _SC_PII = 53,
    _SC_PII_XTI = 54,
    _SC_PII_SOCKET = 55,
    _SC_PII_INTERNET = 56,
    _SC_PII_OSI = 57,
    _SC_POLL = 58,
    _SC_SELECT = 59,
    _SC_UIO_MAXIOV = 60,
    _SC_PII_INTERNET_STREAM = 61,
    _SC_PII_INTERNET_DGRAM = 62,
    _SC_PII_OSI_COTS = 63,
    _SC_PII_OSI_CLTS = 64,
    _SC_PII_OSI_M = 65,
    _SC_T_IOV_MAX = 66,
    _SC_THREADS = 67,
    _SC_THREAD_SAFE_FUNCTIONS = 68,
    _SC_GETGR_R_SIZE_MAX = 69,
    _SC_GETPW_R_SIZE_MAX = 70,
    _SC_LOGIN_NAME_MAX = 71,
    _SC_TTY_NAME_MAX = 72,
    _SC_THREAD_DESTRUCTOR_ITERATIONS = 73,
    _SC_THREAD_KEYS_MAX = 74,
    _SC_THREAD_STACK_MIN = 75,
    _SC_THREAD_THREADS_MAX = 76,
    _SC_THREAD_ATTR_STACKADDR = 77,
    _SC_THREAD_ATTR_STACKSIZE = 78,
    _SC_THREAD_PRIORITY_SCHEDULING = 79,
    _SC_THREAD_PRIO_INHERIT = 80,
    _SC_THREAD_PRIO_PROTECT = 81,
    _SC_THREAD_PROCESS_SHARED = 82,
    _SC_NPROCESSORS_CONF = 83,
    _SC_NPROCESSORS_ONLN = 84,
    _SC_PHYS_PAGES = 85,
    _SC_AVPHYS_PAGES = 86,
    _SC_ATEXIT_MAX = 87,
    _SC_PASS_MAX = 88,
    _SC_XOPEN_VERSION = 89,
    _SC_XOPEN_XCU_VERSION = 90,
    _SC_XOPEN_UNIX = 91,
    _SC_XOPEN_CRYPT = 92,
    _SC_XOPEN_ENH_I18N = 93,
    _SC_XOPEN_SHM = 94,
    _SC_2_CHAR_TERM = 95,
    _SC_2_C_VERSION = 96,
    _SC_2_UPE = 97,
    _SC_XOPEN_XPG2 = 98,
    _SC_XOPEN_XPG3 = 99,
    _SC_XOPEN_XPG4 = 100,
    _SC_CHAR_BIT = 101,
    _SC_CHAR_MAX = 102,
    _SC_CHAR_MIN = 103,
    _SC_INT_MAX = 104,
    _SC_INT_MIN = 105,
    _SC_LONG_BIT = 106,
    _SC_WORD_BIT = 107,
    _SC_MB_LEN_MAX = 108,
    _SC_NZERO = 109,
    _SC_SSIZE_MAX = 110,
    _SC_SCHAR_MAX = 111,
    _SC_SCHAR_MIN = 112,
    _SC_SHRT_MAX = 113,
    _SC_SHRT_MIN = 114,
    _SC_UCHAR_MAX = 115,
    _SC_UINT_MAX = 116,
    _SC_ULONG_MAX = 117,
    _SC_USHRT_MAX = 118,
    _SC_NL_ARGMAX = 119,
    _SC_NL_LANGMAX = 120,
    _SC_NL_MSGMAX = 121,
    _SC_NL_NMAX = 122,
    _SC_NL_SETMAX = 123,
    _SC_NL_TEXTMAX = 124,
    _SC_XBS5_ILP32_OFF32 = 125,
    _SC_XBS5_ILP32_OFFBIG = 126,
    _SC_XBS5_LP64_OFF64 = 127,
    _SC_XBS5_LPBIG_OFFBIG = 128,
    _SC_XOPEN_LEGACY = 129,
    _SC_XOPEN_REALTIME = 130,
    _SC_XOPEN_REALTIME_THREADS = 131,
    _SC_ADVISORY_INFO = 132,
    _SC_BARRIERS = 133,
    _SC_BASE = 134,
    _SC_C_LANG_SUPPORT = 135,
    _SC_C_LANG_SUPPORT_R = 136,
    _SC_CLOCK_SELECTION = 137,
    _SC_CPUTIME = 138,
    _SC_THREAD_CPUTIME = 139,
    _SC_DEVICE_IO = 140,
    _SC_DEVICE_SPECIFIC = 141,
    _SC_DEVICE_SPECIFIC_R = 142,
    _SC_FD_MGMT = 143,
    _SC_FIFO = 144,
    _SC_PIPE = 145,
    _SC_FILE_ATTRIBUTES = 146,
    _SC_FILE_LOCKING = 147,
    _SC_FILE_SYSTEM = 148,
    _SC_MONOTONIC_CLOCK = 149,
    _SC_MULTI_PROCESS = 150,
    _SC_SINGLE_PROCESS = 151,
    _SC_NETWORKING = 152,
    _SC_READER_WRITER_LOCKS = 153,
    _SC_SPIN_LOCKS = 154,
    _SC_REGEXP = 155,
    _SC_REGEX_VERSION = 156,
    _SC_SHELL = 157,
    _SC_SIGNALS = 158,
    _SC_SPAWN = 159,
    _SC_SPORADIC_SERVER = 160,
    _SC_THREAD_SPORADIC_SERVER = 161,
    _SC_SYSTEM_DATABASE = 162,
    _SC_SYSTEM_DATABASE_R = 163,
    _SC_TIMEOUTS = 164,
    _SC_TYPED_MEMORY_OBJECTS = 165,
    _SC_USER_GROUPS = 166,
    _SC_USER_GROUPS_R = 167,
    _SC_2_PBS = 168,
    _SC_2_PBS_ACCOUNTING = 169,
    _SC_2_PBS_LOCATE = 170,
    _SC_2_PBS_MESSAGE = 171,
    _SC_2_PBS_TRACK = 172,
    _SC_SYMLOOP_MAX = 173,
    _SC_STREAMS = 174,
    _SC_2_PBS_CHECKPOINT = 175,
    _SC_V6_ILP32_OFF32 = 176,
    _SC_V6_ILP32_OFFBIG = 177,
    _SC_V6_LP64_OFF64 = 178,
    _SC_V6_LPBIG_OFFBIG = 179,
    _SC_HOST_NAME_MAX = 180,
    _SC_TRACE = 181,
    _SC_TRACE_EVENT_FILTER = 182,
    _SC_TRACE_INHERIT = 183,
    _SC_TRACE_LOG = 184,
    _SC_LEVEL1_ICACHE_SIZE = 185,
    _SC_LEVEL1_ICACHE_ASSOC = 186,
    _SC_LEVEL1_ICACHE_LINESIZE = 187,
    _SC_LEVEL1_DCACHE_SIZE = 188,
    _SC_LEVEL1_DCACHE_ASSOC = 189,
    _SC_LEVEL1_DCACHE_LINESIZE = 190,
    _SC_LEVEL2_CACHE_SIZE = 191,
    _SC_LEVEL2_CACHE_ASSOC = 192,
    _SC_LEVEL2_CACHE_LINESIZE = 193,
    _SC_LEVEL3_CACHE_SIZE = 194,
    _SC_LEVEL3_CACHE_ASSOC = 195,
    _SC_LEVEL3_CACHE_LINESIZE = 196,
    _SC_LEVEL4_CACHE_SIZE = 197,
    _SC_LEVEL4_CACHE_ASSOC = 198,
    _SC_LEVEL4_CACHE_LINESIZE = 199,
    _SC_IPV6 = 235,
    _SC_RAW_SOCKETS = 236,
    _SC_V7_ILP32_OFF32 = 237,
    _SC_V7_ILP32_OFFBIG = 238,
    _SC_V7_LP64_OFF64 = 239,
    _SC_V7_LPBIG_OFFBIG = 240,
    _SC_SS_REPL_MAX = 241,
    _SC_TRACE_EVENT_NAME_MAX = 242,
    _SC_TRACE_NAME_MAX = 243,
    _SC_TRACE_SYS_MAX = 244,
    _SC_TRACE_USER_EVENT_MAX = 245,
    _SC_XOPEN_STREAMS = 246,
    _SC_THREAD_ROBUST_PRIO_INHERIT = 247,
    _SC_THREAD_ROBUST_PRIO_PROTECT = 248,
}
#[derive(Clone, Copy)]
#[repr(u32)]
pub enum Enum_Unnamed29 {
    _CS_PATH = 0,
    _CS_V6_WIDTH_RESTRICTED_ENVS = 1,
    _CS_GNU_LIBC_VERSION = 2,
    _CS_GNU_LIBPTHREAD_VERSION = 3,
    _CS_V5_WIDTH_RESTRICTED_ENVS = 4,
    _CS_V7_WIDTH_RESTRICTED_ENVS = 5,
    _CS_LFS_CFLAGS = 1000,
    _CS_LFS_LDFLAGS = 1001,
    _CS_LFS_LIBS = 1002,
    _CS_LFS_LINTFLAGS = 1003,
    _CS_LFS64_CFLAGS = 1004,
    _CS_LFS64_LDFLAGS = 1005,
    _CS_LFS64_LIBS = 1006,
    _CS_LFS64_LINTFLAGS = 1007,
    _CS_XBS5_ILP32_OFF32_CFLAGS = 1100,
    _CS_XBS5_ILP32_OFF32_LDFLAGS = 1101,
    _CS_XBS5_ILP32_OFF32_LIBS = 1102,
    _CS_XBS5_ILP32_OFF32_LINTFLAGS = 1103,
    _CS_XBS5_ILP32_OFFBIG_CFLAGS = 1104,
    _CS_XBS5_ILP32_OFFBIG_LDFLAGS = 1105,
    _CS_XBS5_ILP32_OFFBIG_LIBS = 1106,
    _CS_XBS5_ILP32_OFFBIG_LINTFLAGS = 1107,
    _CS_XBS5_LP64_OFF64_CFLAGS = 1108,
    _CS_XBS5_LP64_OFF64_LDFLAGS = 1109,
    _CS_XBS5_LP64_OFF64_LIBS = 1110,
    _CS_XBS5_LP64_OFF64_LINTFLAGS = 1111,
    _CS_XBS5_LPBIG_OFFBIG_CFLAGS = 1112,
    _CS_XBS5_LPBIG_OFFBIG_LDFLAGS = 1113,
    _CS_XBS5_LPBIG_OFFBIG_LIBS = 1114,
    _CS_XBS5_LPBIG_OFFBIG_LINTFLAGS = 1115,
    _CS_POSIX_V6_ILP32_OFF32_CFLAGS = 1116,
    _CS_POSIX_V6_ILP32_OFF32_LDFLAGS = 1117,
    _CS_POSIX_V6_ILP32_OFF32_LIBS = 1118,
    _CS_POSIX_V6_ILP32_OFF32_LINTFLAGS = 1119,
    _CS_POSIX_V6_ILP32_OFFBIG_CFLAGS = 1120,
    _CS_POSIX_V6_ILP32_OFFBIG_LDFLAGS = 1121,
    _CS_POSIX_V6_ILP32_OFFBIG_LIBS = 1122,
    _CS_POSIX_V6_ILP32_OFFBIG_LINTFLAGS = 1123,
    _CS_POSIX_V6_LP64_OFF64_CFLAGS = 1124,
    _CS_POSIX_V6_LP64_OFF64_LDFLAGS = 1125,
    _CS_POSIX_V6_LP64_OFF64_LIBS = 1126,
    _CS_POSIX_V6_LP64_OFF64_LINTFLAGS = 1127,
    _CS_POSIX_V6_LPBIG_OFFBIG_CFLAGS = 1128,
    _CS_POSIX_V6_LPBIG_OFFBIG_LDFLAGS = 1129,
    _CS_POSIX_V6_LPBIG_OFFBIG_LIBS = 1130,
    _CS_POSIX_V6_LPBIG_OFFBIG_LINTFLAGS = 1131,
    _CS_POSIX_V7_ILP32_OFF32_CFLAGS = 1132,
    _CS_POSIX_V7_ILP32_OFF32_LDFLAGS = 1133,
    _CS_POSIX_V7_ILP32_OFF32_LIBS = 1134,
    _CS_POSIX_V7_ILP32_OFF32_LINTFLAGS = 1135,
    _CS_POSIX_V7_ILP32_OFFBIG_CFLAGS = 1136,
    _CS_POSIX_V7_ILP32_OFFBIG_LDFLAGS = 1137,
    _CS_POSIX_V7_ILP32_OFFBIG_LIBS = 1138,
    _CS_POSIX_V7_ILP32_OFFBIG_LINTFLAGS = 1139,
    _CS_POSIX_V7_LP64_OFF64_CFLAGS = 1140,
    _CS_POSIX_V7_LP64_OFF64_LDFLAGS = 1141,
    _CS_POSIX_V7_LP64_OFF64_LIBS = 1142,
    _CS_POSIX_V7_LP64_OFF64_LINTFLAGS = 1143,
    _CS_POSIX_V7_LPBIG_OFFBIG_CFLAGS = 1144,
    _CS_POSIX_V7_LPBIG_OFFBIG_LDFLAGS = 1145,
    _CS_POSIX_V7_LPBIG_OFFBIG_LIBS = 1146,
    _CS_POSIX_V7_LPBIG_OFFBIG_LINTFLAGS = 1147,
    _CS_V6_ENV = 1148,
    _CS_V7_ENV = 1149,
}
pub type float_t = ::std::os::raw::c_float;
pub type double_t = ::std::os::raw::c_double;
#[derive(Clone, Copy)]
#[repr(u32)]
pub enum Enum_Unnamed30 {
    FP_NAN = 0,
    FP_INFINITE = 1,
    FP_ZERO = 2,
    FP_SUBNORMAL = 3,
    FP_NORMAL = 4,
}
#[derive(Clone, Copy)]
#[repr(i32)]
pub enum Enum_Unnamed31 {
    _IEEE_ = -1,
    _SVID_ = 0,
    _XOPEN_ = 1,
    _POSIX_ = 2,
    _ISOC_ = 3,
}
pub type _LIB_VERSION_TYPE = Enum_Unnamed31;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_exception {
    pub _type: ::std::os::raw::c_int,
    pub name: *mut ::std::os::raw::c_char,
    pub arg1: ::std::os::raw::c_double,
    pub arg2: ::std::os::raw::c_double,
    pub retval: ::std::os::raw::c_double,
}
impl ::std::clone::Clone for Struct_exception {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_exception {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type VALUE = ::std::os::raw::c_ulong;
pub type ID = ::std::os::raw::c_ulong;
pub type ruby_check_sizeof_int = [::std::os::raw::c_char; 1usize];
pub type ruby_check_sizeof_long = [::std::os::raw::c_char; 1usize];
pub type ruby_check_sizeof_long_long = [::std::os::raw::c_char; 1usize];
pub type ruby_check_sizeof_voidp = [::std::os::raw::c_char; 1usize];
pub const RUBY_SPECIAL_SHIFT: Enum_ruby_special_consts =
    Enum_ruby_special_consts::RUBY_Qnil;
#[derive(Clone, Copy)]
#[repr(u32)]
pub enum Enum_ruby_special_consts {
    RUBY_Qfalse = 0,
    RUBY_Qtrue = 20,
    RUBY_Qnil = 8,
    RUBY_Qundef = 52,
    RUBY_IMMEDIATE_MASK = 7,
    RUBY_FIXNUM_FLAG = 1,
    RUBY_FLONUM_MASK = 3,
    RUBY_FLONUM_FLAG = 2,
    RUBY_SYMBOL_FLAG = 12,
}
#[derive(Clone, Copy)]
#[repr(u32)]
pub enum Enum_ruby_value_type {
    RUBY_T_NONE = 0,
    RUBY_T_OBJECT = 1,
    RUBY_T_CLASS = 2,
    RUBY_T_MODULE = 3,
    RUBY_T_FLOAT = 4,
    RUBY_T_STRING = 5,
    RUBY_T_REGEXP = 6,
    RUBY_T_ARRAY = 7,
    RUBY_T_HASH = 8,
    RUBY_T_STRUCT = 9,
    RUBY_T_BIGNUM = 10,
    RUBY_T_FILE = 11,
    RUBY_T_DATA = 12,
    RUBY_T_MATCH = 13,
    RUBY_T_COMPLEX = 14,
    RUBY_T_RATIONAL = 15,
    RUBY_T_NIL = 17,
    RUBY_T_TRUE = 18,
    RUBY_T_FALSE = 19,
    RUBY_T_SYMBOL = 20,
    RUBY_T_FIXNUM = 21,
    RUBY_T_UNDEF = 27,
    RUBY_T_NODE = 28,
    RUBY_T_ICLASS = 29,
    RUBY_T_ZOMBIE = 30,
    RUBY_T_MASK = 31,
}
#[repr(C)]
#[derive(Copy)]
pub struct Struct_RBasic {
    pub flags: VALUE,
    pub klass: VALUE,
}
impl ::std::clone::Clone for Struct_RBasic {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_RBasic {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub struct Struct_RObject {
    pub basic: Struct_RBasic,
    pub _as: Union_Unnamed32,
}
impl ::std::clone::Clone for Struct_RObject {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_RObject {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub struct Union_Unnamed32 {
    pub _bindgen_data_: [u64; 3usize],
}
impl Union_Unnamed32 {
    pub unsafe fn heap(&mut self) -> *mut Struct_Unnamed33 {
        let raw: *mut u8 = ::std::mem::transmute(&self._bindgen_data_);
        ::std::mem::transmute(raw.offset(0))
    }
    pub unsafe fn ary(&mut self) -> *mut [VALUE; 3usize] {
        let raw: *mut u8 = ::std::mem::transmute(&self._bindgen_data_);
        ::std::mem::transmute(raw.offset(0))
    }
}
impl ::std::clone::Clone for Union_Unnamed32 {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Union_Unnamed32 {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub struct Struct_Unnamed33 {
    pub numiv: ::std::os::raw::c_long,
    pub ivptr: *mut VALUE,
    pub iv_index_tbl: *mut Struct_st_table,
}
impl ::std::clone::Clone for Struct_Unnamed33 {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_Unnamed33 {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type rb_classext_t = Struct_rb_classext_struct;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_RClass {
    pub basic: Struct_RBasic,
    pub _super: VALUE,
    pub ptr: *mut rb_classext_t,
    pub m_tbl_wrapper: *mut Struct_method_table_wrapper,
}
impl ::std::clone::Clone for Struct_RClass {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_RClass {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub struct Struct_RFloat {
    pub basic: Struct_RBasic,
    pub float_value: ::std::os::raw::c_double,
}
impl ::std::clone::Clone for Struct_RFloat {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_RFloat {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub struct Struct_RString {
    pub basic: Struct_RBasic,
    pub _as: Union_Unnamed34,
}
impl ::std::clone::Clone for Struct_RString {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_RString {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub struct Union_Unnamed34 {
    pub _bindgen_data_: [u64; 3usize],
}
impl Union_Unnamed34 {
    pub unsafe fn heap(&mut self) -> *mut Struct_Unnamed35 {
        let raw: *mut u8 = ::std::mem::transmute(&self._bindgen_data_);
        ::std::mem::transmute(raw.offset(0))
    }
    pub unsafe fn ary(&mut self) -> *mut [::std::os::raw::c_char; 24usize] {
        let raw: *mut u8 = ::std::mem::transmute(&self._bindgen_data_);
        ::std::mem::transmute(raw.offset(0))
    }
}
impl ::std::clone::Clone for Union_Unnamed34 {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Union_Unnamed34 {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub struct Struct_Unnamed35 {
    pub len: ::std::os::raw::c_long,
    pub ptr: *mut ::std::os::raw::c_char,
    pub aux: Union_Unnamed36,
}
impl ::std::clone::Clone for Struct_Unnamed35 {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_Unnamed35 {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub struct Union_Unnamed36 {
    pub _bindgen_data_: [u64; 1usize],
}
impl Union_Unnamed36 {
    pub unsafe fn capa(&mut self) -> *mut ::std::os::raw::c_long {
        let raw: *mut u8 = ::std::mem::transmute(&self._bindgen_data_);
        ::std::mem::transmute(raw.offset(0))
    }
    pub unsafe fn shared(&mut self) -> *mut VALUE {
        let raw: *mut u8 = ::std::mem::transmute(&self._bindgen_data_);
        ::std::mem::transmute(raw.offset(0))
    }
}
impl ::std::clone::Clone for Union_Unnamed36 {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Union_Unnamed36 {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub struct Struct_RArray {
    pub basic: Struct_RBasic,
    pub _as: Union_Unnamed37,
}
impl ::std::clone::Clone for Struct_RArray {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_RArray {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub struct Union_Unnamed37 {
    pub _bindgen_data_: [u64; 3usize],
}
impl Union_Unnamed37 {
    pub unsafe fn heap(&mut self) -> *mut Struct_Unnamed38 {
        let raw: *mut u8 = ::std::mem::transmute(&self._bindgen_data_);
        ::std::mem::transmute(raw.offset(0))
    }
    pub unsafe fn ary(&mut self) -> *mut [VALUE; 3usize] {
        let raw: *mut u8 = ::std::mem::transmute(&self._bindgen_data_);
        ::std::mem::transmute(raw.offset(0))
    }
}
impl ::std::clone::Clone for Union_Unnamed37 {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Union_Unnamed37 {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub struct Struct_Unnamed38 {
    pub len: ::std::os::raw::c_long,
    pub aux: Union_Unnamed39,
    pub ptr: *const VALUE,
}
impl ::std::clone::Clone for Struct_Unnamed38 {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_Unnamed38 {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub struct Union_Unnamed39 {
    pub _bindgen_data_: [u64; 1usize],
}
impl Union_Unnamed39 {
    pub unsafe fn capa(&mut self) -> *mut ::std::os::raw::c_long {
        let raw: *mut u8 = ::std::mem::transmute(&self._bindgen_data_);
        ::std::mem::transmute(raw.offset(0))
    }
    pub unsafe fn shared(&mut self) -> *mut VALUE {
        let raw: *mut u8 = ::std::mem::transmute(&self._bindgen_data_);
        ::std::mem::transmute(raw.offset(0))
    }
}
impl ::std::clone::Clone for Union_Unnamed39 {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Union_Unnamed39 {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub enum Struct_re_pattern_buffer { }
#[repr(C)]
#[derive(Copy)]
pub struct Struct_RRegexp {
    pub basic: Struct_RBasic,
    pub ptr: *mut Struct_re_pattern_buffer,
    pub src: VALUE,
    pub usecnt: ::std::os::raw::c_ulong,
}
impl ::std::clone::Clone for Struct_RRegexp {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_RRegexp {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub struct Struct_RHash {
    pub basic: Struct_RBasic,
    pub ntbl: *mut Struct_st_table,
    pub iter_lev: ::std::os::raw::c_int,
    pub ifnone: VALUE,
}
impl ::std::clone::Clone for Struct_RHash {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_RHash {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub enum Struct_rb_io_t { }
#[repr(C)]
#[derive(Copy)]
pub struct Struct_RFile {
    pub basic: Struct_RBasic,
    pub fptr: *mut Struct_rb_io_t,
}
impl ::std::clone::Clone for Struct_RFile {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_RFile {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub struct Struct_RRational {
    pub basic: Struct_RBasic,
    pub num: VALUE,
    pub den: VALUE,
}
impl ::std::clone::Clone for Struct_RRational {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_RRational {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub struct Struct_RComplex {
    pub basic: Struct_RBasic,
    pub real: VALUE,
    pub imag: VALUE,
}
impl ::std::clone::Clone for Struct_RComplex {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_RComplex {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub struct Struct_RData {
    pub basic: Struct_RBasic,
    pub dmark: ::std::option::Option<unsafe extern "C" fn(arg1:
                                                              *mut ::std::os::raw::c_void)>,
    pub dfree: ::std::option::Option<unsafe extern "C" fn(arg1:
                                                              *mut ::std::os::raw::c_void)>,
    pub data: *mut ::std::os::raw::c_void,
}
impl ::std::clone::Clone for Struct_RData {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_RData {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type rb_data_type_t = Struct_rb_data_type_struct;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_rb_data_type_struct {
    pub wrap_struct_name: *const ::std::os::raw::c_char,
    pub function: Struct_Unnamed40,
    pub parent: *const rb_data_type_t,
    pub data: *mut ::std::os::raw::c_void,
    pub flags: VALUE,
}
impl ::std::clone::Clone for Struct_rb_data_type_struct {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_rb_data_type_struct {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub struct Struct_Unnamed40 {
    pub dmark: ::std::option::Option<unsafe extern "C" fn(arg1:
                                                              *mut ::std::os::raw::c_void)>,
    pub dfree: ::std::option::Option<unsafe extern "C" fn(arg1:
                                                              *mut ::std::os::raw::c_void)>,
    pub dsize: ::std::option::Option<unsafe extern "C" fn(arg1:
                                                              *const ::std::os::raw::c_void)
                                         -> size_t>,
    pub reserved: [*mut ::std::os::raw::c_void; 2usize],
}
impl ::std::clone::Clone for Struct_Unnamed40 {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_Unnamed40 {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub struct Struct_RTypedData {
    pub basic: Struct_RBasic,
    pub _type: *const rb_data_type_t,
    pub typed_flag: VALUE,
    pub data: *mut ::std::os::raw::c_void,
}
impl ::std::clone::Clone for Struct_RTypedData {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_RTypedData {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type RUBY_DATA_FUNC =
    ::std::option::Option<unsafe extern "C" fn(arg1:
                                                   *mut ::std::os::raw::c_void)>;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_RStruct {
    pub basic: Struct_RBasic,
    pub _as: Union_Unnamed41,
}
impl ::std::clone::Clone for Struct_RStruct {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_RStruct {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub struct Union_Unnamed41 {
    pub _bindgen_data_: [u64; 3usize],
}
impl Union_Unnamed41 {
    pub unsafe fn heap(&mut self) -> *mut Struct_Unnamed42 {
        let raw: *mut u8 = ::std::mem::transmute(&self._bindgen_data_);
        ::std::mem::transmute(raw.offset(0))
    }
    pub unsafe fn ary(&mut self) -> *mut [VALUE; 3usize] {
        let raw: *mut u8 = ::std::mem::transmute(&self._bindgen_data_);
        ::std::mem::transmute(raw.offset(0))
    }
}
impl ::std::clone::Clone for Union_Unnamed41 {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Union_Unnamed41 {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub struct Struct_Unnamed42 {
    pub len: ::std::os::raw::c_long,
    pub ptr: *const VALUE,
}
impl ::std::clone::Clone for Struct_Unnamed42 {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_Unnamed42 {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub struct Struct_RBignum {
    pub basic: Struct_RBasic,
    pub _as: Union_Unnamed43,
}
impl ::std::clone::Clone for Struct_RBignum {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_RBignum {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub struct Union_Unnamed43 {
    pub _bindgen_data_: [u64; 3usize],
}
impl Union_Unnamed43 {
    pub unsafe fn heap(&mut self) -> *mut Struct_Unnamed44 {
        let raw: *mut u8 = ::std::mem::transmute(&self._bindgen_data_);
        ::std::mem::transmute(raw.offset(0))
    }
    pub unsafe fn ary(&mut self) -> *mut [::std::os::raw::c_uint; 6usize] {
        let raw: *mut u8 = ::std::mem::transmute(&self._bindgen_data_);
        ::std::mem::transmute(raw.offset(0))
    }
}
impl ::std::clone::Clone for Union_Unnamed43 {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Union_Unnamed43 {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub struct Struct_Unnamed44 {
    pub len: ::std::os::raw::c_long,
    pub digits: *mut ::std::os::raw::c_uint,
}
impl ::std::clone::Clone for Struct_Unnamed44 {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_Unnamed44 {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type ruby_glob_func =
    unsafe extern "C" fn(arg1: *const ::std::os::raw::c_char, arg2: VALUE,
                         arg3: *mut ::std::os::raw::c_void)
        -> ::std::os::raw::c_int;
pub enum Struct_rb_global_variable { }
pub type rb_gvar_getter_t =
    unsafe extern "C" fn(id: ID, data: *mut ::std::os::raw::c_void,
                         gvar: *mut Struct_rb_global_variable) -> VALUE;
pub type rb_gvar_setter_t =
    unsafe extern "C" fn(val: VALUE, id: ID,
                         data: *mut ::std::os::raw::c_void,
                         gvar: *mut Struct_rb_global_variable);
pub type rb_gvar_marker_t = unsafe extern "C" fn(var: *mut VALUE);
pub type rb_block_call_func =
    unsafe extern "C" fn(yielded_arg: VALUE, callback_arg: VALUE,
                         argc: ::std::os::raw::c_int, argv: *const VALUE,
                         blockarg: VALUE) -> VALUE;
pub type rb_block_call_func_t =
    ::std::option::Option<extern "C" fn() -> VALUE>;
pub type st_data_t = ::std::os::raw::c_ulong;
pub type st_table = Struct_st_table;
pub type st_index_t = st_data_t;
pub type st_compare_func =
    extern "C" fn(arg1: st_data_t, arg2: st_data_t) -> ::std::os::raw::c_int;
pub type st_hash_func = extern "C" fn(arg1: st_data_t) -> st_index_t;
pub type st_check_for_sizeof_st_index_t = [::std::os::raw::c_char; 1usize];
#[repr(C)]
#[derive(Copy)]
pub struct Struct_st_hash_type {
    pub compare: ::std::option::Option<extern "C" fn()
                                           -> ::std::os::raw::c_int>,
    pub hash: ::std::option::Option<extern "C" fn() -> st_index_t>,
}
impl ::std::clone::Clone for Struct_st_hash_type {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_st_hash_type {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub enum Struct_st_table_entry { }
pub enum Struct_st_packed_entry { }
#[repr(C)]
#[derive(Copy)]
pub struct Struct_st_table {
    pub _type: *const Struct_st_hash_type,
    pub num_bins: st_index_t,
    pub _bindgen_bitfield_1_: ::std::os::raw::c_uint,
    pub _bindgen_bitfield_2_: st_index_t,
    pub _as: Union_Unnamed45,
}
impl ::std::clone::Clone for Struct_st_table {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_st_table {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub struct Union_Unnamed45 {
    pub _bindgen_data_: [u64; 3usize],
}
impl Union_Unnamed45 {
    pub unsafe fn big(&mut self) -> *mut Struct_Unnamed46 {
        let raw: *mut u8 = ::std::mem::transmute(&self._bindgen_data_);
        ::std::mem::transmute(raw.offset(0))
    }
    pub unsafe fn packed(&mut self) -> *mut Struct_Unnamed47 {
        let raw: *mut u8 = ::std::mem::transmute(&self._bindgen_data_);
        ::std::mem::transmute(raw.offset(0))
    }
}
impl ::std::clone::Clone for Union_Unnamed45 {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Union_Unnamed45 {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub struct Struct_Unnamed46 {
    pub bins: *mut *mut Struct_st_table_entry,
    pub head: *mut Struct_st_table_entry,
    pub tail: *mut Struct_st_table_entry,
}
impl ::std::clone::Clone for Struct_Unnamed46 {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_Unnamed46 {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub struct Struct_Unnamed47 {
    pub entries: *mut Struct_st_packed_entry,
    pub real_entries: st_index_t,
}
impl ::std::clone::Clone for Struct_Unnamed47 {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_Unnamed47 {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[derive(Clone, Copy)]
#[repr(u32)]
pub enum Enum_st_retval {
    ST_CONTINUE = 0,
    ST_STOP = 1,
    ST_DELETE = 2,
    ST_CHECK = 3,
}
pub type st_update_callback_func =
    unsafe extern "C" fn(key: *mut st_data_t, value: *mut st_data_t,
                         arg: st_data_t, existing: ::std::os::raw::c_int)
        -> ::std::os::raw::c_int;
pub type rb_enumerator_size_func =
    extern "C" fn(arg1: VALUE, arg2: VALUE, arg3: VALUE) -> VALUE;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_Unnamed48 {
    pub maxfd: ::std::os::raw::c_int,
    pub fdset: *mut fd_set,
}
impl ::std::clone::Clone for Struct_Unnamed48 {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_Unnamed48 {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type rb_fdset_t = Struct_Unnamed48;
pub type rb_alloc_func_t =
    ::std::option::Option<extern "C" fn(arg1: VALUE) -> VALUE>;
pub type rb_hash_update_func =
    extern "C" fn(newkey: VALUE, oldkey: VALUE, value: VALUE) -> VALUE;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_rb_exec_arg {
    pub execarg_obj: VALUE,
}
impl ::std::clone::Clone for Struct_rb_exec_arg {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_rb_exec_arg {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type rb_unblock_function_t =
    unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void);
pub type rb_blocking_function_t =
    unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void) -> VALUE;
pub type rb_event_flag_t = ::std::os::raw::c_ulong;
pub type rb_event_hook_func_t =
    ::std::option::Option<extern "C" fn(evflag: rb_event_flag_t, data: VALUE,
                                        _self: VALUE, mid: ID, klass: VALUE)>;
#[derive(Clone, Copy)]
#[repr(u32)]
pub enum Enum_node_type {
    NODE_SCOPE = 0,
    NODE_BLOCK = 1,
    NODE_IF = 2,
    NODE_CASE = 3,
    NODE_WHEN = 4,
    NODE_OPT_N = 5,
    NODE_WHILE = 6,
    NODE_UNTIL = 7,
    NODE_ITER = 8,
    NODE_FOR = 9,
    NODE_BREAK = 10,
    NODE_NEXT = 11,
    NODE_REDO = 12,
    NODE_RETRY = 13,
    NODE_BEGIN = 14,
    NODE_RESCUE = 15,
    NODE_RESBODY = 16,
    NODE_ENSURE = 17,
    NODE_AND = 18,
    NODE_OR = 19,
    NODE_MASGN = 20,
    NODE_LASGN = 21,
    NODE_DASGN = 22,
    NODE_DASGN_CURR = 23,
    NODE_GASGN = 24,
    NODE_IASGN = 25,
    NODE_IASGN2 = 26,
    NODE_CDECL = 27,
    NODE_CVASGN = 28,
    NODE_CVDECL = 29,
    NODE_OP_ASGN1 = 30,
    NODE_OP_ASGN2 = 31,
    NODE_OP_ASGN_AND = 32,
    NODE_OP_ASGN_OR = 33,
    NODE_OP_CDECL = 34,
    NODE_CALL = 35,
    NODE_FCALL = 36,
    NODE_VCALL = 37,
    NODE_SUPER = 38,
    NODE_ZSUPER = 39,
    NODE_ARRAY = 40,
    NODE_ZARRAY = 41,
    NODE_VALUES = 42,
    NODE_HASH = 43,
    NODE_RETURN = 44,
    NODE_YIELD = 45,
    NODE_LVAR = 46,
    NODE_DVAR = 47,
    NODE_GVAR = 48,
    NODE_IVAR = 49,
    NODE_CONST = 50,
    NODE_CVAR = 51,
    NODE_NTH_REF = 52,
    NODE_BACK_REF = 53,
    NODE_MATCH = 54,
    NODE_MATCH2 = 55,
    NODE_MATCH3 = 56,
    NODE_LIT = 57,
    NODE_STR = 58,
    NODE_DSTR = 59,
    NODE_XSTR = 60,
    NODE_DXSTR = 61,
    NODE_EVSTR = 62,
    NODE_DREGX = 63,
    NODE_DREGX_ONCE = 64,
    NODE_ARGS = 65,
    NODE_ARGS_AUX = 66,
    NODE_OPT_ARG = 67,
    NODE_KW_ARG = 68,
    NODE_POSTARG = 69,
    NODE_ARGSCAT = 70,
    NODE_ARGSPUSH = 71,
    NODE_SPLAT = 72,
    NODE_TO_ARY = 73,
    NODE_BLOCK_ARG = 74,
    NODE_BLOCK_PASS = 75,
    NODE_DEFN = 76,
    NODE_DEFS = 77,
    NODE_ALIAS = 78,
    NODE_VALIAS = 79,
    NODE_UNDEF = 80,
    NODE_CLASS = 81,
    NODE_MODULE = 82,
    NODE_SCLASS = 83,
    NODE_COLON2 = 84,
    NODE_COLON3 = 85,
    NODE_CREF = 86,
    NODE_DOT2 = 87,
    NODE_DOT3 = 88,
    NODE_FLIP2 = 89,
    NODE_FLIP3 = 90,
    NODE_SELF = 91,
    NODE_NIL = 92,
    NODE_TRUE = 93,
    NODE_FALSE = 94,
    NODE_ERRINFO = 95,
    NODE_DEFINED = 96,
    NODE_POSTEXE = 97,
    NODE_ALLOCA = 98,
    NODE_BMETHOD = 99,
    NODE_MEMO = 100,
    NODE_IFUNC = 101,
    NODE_DSYM = 102,
    NODE_ATTRASGN = 103,
    NODE_PRELUDE = 104,
    NODE_LAMBDA = 105,
    NODE_LAST = 106,
}
#[repr(C)]
#[derive(Copy)]
pub struct Struct_RNode {
    pub flags: VALUE,
    pub nd_reserved: VALUE,
    pub u1: Union_Unnamed49,
    pub u2: Union_Unnamed50,
    pub u3: Union_Unnamed51,
}
impl ::std::clone::Clone for Struct_RNode {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_RNode {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub struct Union_Unnamed49 {
    pub _bindgen_data_: [u64; 1usize],
}
impl Union_Unnamed49 {
    pub unsafe fn node(&mut self) -> *mut *mut Struct_RNode {
        let raw: *mut u8 = ::std::mem::transmute(&self._bindgen_data_);
        ::std::mem::transmute(raw.offset(0))
    }
    pub unsafe fn id(&mut self) -> *mut ID {
        let raw: *mut u8 = ::std::mem::transmute(&self._bindgen_data_);
        ::std::mem::transmute(raw.offset(0))
    }
    pub unsafe fn value(&mut self) -> *mut VALUE {
        let raw: *mut u8 = ::std::mem::transmute(&self._bindgen_data_);
        ::std::mem::transmute(raw.offset(0))
    }
    pub unsafe fn cfunc(&mut self)
     -> *mut ::std::option::Option<extern "C" fn() -> VALUE> {
        let raw: *mut u8 = ::std::mem::transmute(&self._bindgen_data_);
        ::std::mem::transmute(raw.offset(0))
    }
    pub unsafe fn tbl(&mut self) -> *mut *mut ID {
        let raw: *mut u8 = ::std::mem::transmute(&self._bindgen_data_);
        ::std::mem::transmute(raw.offset(0))
    }
}
impl ::std::clone::Clone for Union_Unnamed49 {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Union_Unnamed49 {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub struct Union_Unnamed50 {
    pub _bindgen_data_: [u64; 1usize],
}
impl Union_Unnamed50 {
    pub unsafe fn node(&mut self) -> *mut *mut Struct_RNode {
        let raw: *mut u8 = ::std::mem::transmute(&self._bindgen_data_);
        ::std::mem::transmute(raw.offset(0))
    }
    pub unsafe fn id(&mut self) -> *mut ID {
        let raw: *mut u8 = ::std::mem::transmute(&self._bindgen_data_);
        ::std::mem::transmute(raw.offset(0))
    }
    pub unsafe fn argc(&mut self) -> *mut ::std::os::raw::c_long {
        let raw: *mut u8 = ::std::mem::transmute(&self._bindgen_data_);
        ::std::mem::transmute(raw.offset(0))
    }
    pub unsafe fn value(&mut self) -> *mut VALUE {
        let raw: *mut u8 = ::std::mem::transmute(&self._bindgen_data_);
        ::std::mem::transmute(raw.offset(0))
    }
}
impl ::std::clone::Clone for Union_Unnamed50 {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Union_Unnamed50 {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub struct Union_Unnamed51 {
    pub _bindgen_data_: [u64; 1usize],
}
impl Union_Unnamed51 {
    pub unsafe fn node(&mut self) -> *mut *mut Struct_RNode {
        let raw: *mut u8 = ::std::mem::transmute(&self._bindgen_data_);
        ::std::mem::transmute(raw.offset(0))
    }
    pub unsafe fn id(&mut self) -> *mut ID {
        let raw: *mut u8 = ::std::mem::transmute(&self._bindgen_data_);
        ::std::mem::transmute(raw.offset(0))
    }
    pub unsafe fn state(&mut self) -> *mut ::std::os::raw::c_long {
        let raw: *mut u8 = ::std::mem::transmute(&self._bindgen_data_);
        ::std::mem::transmute(raw.offset(0))
    }
    pub unsafe fn entry(&mut self) -> *mut *mut Struct_rb_global_entry {
        let raw: *mut u8 = ::std::mem::transmute(&self._bindgen_data_);
        ::std::mem::transmute(raw.offset(0))
    }
    pub unsafe fn args(&mut self) -> *mut *mut Struct_rb_args_info {
        let raw: *mut u8 = ::std::mem::transmute(&self._bindgen_data_);
        ::std::mem::transmute(raw.offset(0))
    }
    pub unsafe fn cnt(&mut self) -> *mut ::std::os::raw::c_long {
        let raw: *mut u8 = ::std::mem::transmute(&self._bindgen_data_);
        ::std::mem::transmute(raw.offset(0))
    }
    pub unsafe fn value(&mut self) -> *mut VALUE {
        let raw: *mut u8 = ::std::mem::transmute(&self._bindgen_data_);
        ::std::mem::transmute(raw.offset(0))
    }
}
impl ::std::clone::Clone for Union_Unnamed51 {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Union_Unnamed51 {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type NODE = Struct_RNode;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_rb_global_entry {
    pub var: *mut Struct_rb_global_variable,
    pub id: ID,
}
impl ::std::clone::Clone for Struct_rb_global_entry {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_rb_global_entry {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub enum Struct_kwtable { }
#[repr(C)]
#[derive(Copy)]
pub struct Struct_rb_args_info {
    pub pre_init: *mut NODE,
    pub post_init: *mut NODE,
    pub pre_args_num: ::std::os::raw::c_int,
    pub post_args_num: ::std::os::raw::c_int,
    pub first_post_arg: ID,
    pub rest_arg: ID,
    pub block_arg: ID,
    pub kw_args: *mut NODE,
    pub kw_rest_arg: *mut NODE,
    pub opt_args: *mut NODE,
}
impl ::std::clone::Clone for Struct_rb_args_info {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_rb_args_info {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub enum Struct_parser_params { }
pub const RUBY_ID_INTERNAL: Enum_ruby_id_types =
    Enum_ruby_id_types::RUBY_ID_JUNK;
pub const RUBY_ID_SCOPE_SHIFT: Enum_ruby_id_types =
    Enum_ruby_id_types::RUBY_ID_GLOBAL;
pub const RUBY_ID_SCOPE_MASK: Enum_ruby_id_types =
    Enum_ruby_id_types::RUBY_ID_JUNK;
#[derive(Clone, Copy)]
#[repr(u32)]
pub enum Enum_ruby_id_types {
    RUBY_ID_LOCAL = 0,
    RUBY_ID_INSTANCE = 1,
    RUBY_ID_GLOBAL = 3,
    RUBY_ID_ATTRSET = 4,
    RUBY_ID_CONST = 5,
    RUBY_ID_CLASS = 6,
    RUBY_ID_JUNK = 7,
}
pub const tLAST_OP_ID: Enum_ruby_method_ids =
    Enum_ruby_method_ids::id_core_hash_merge_kwd;
#[derive(Clone, Copy)]
#[repr(u32)]
pub enum Enum_ruby_method_ids {
    idDot2 = 128,
    idDot3 = 129,
    idUPlus = 130,
    idUMinus = 131,
    idPow = 132,
    idCmp = 134,
    idPLUS = 43,
    idMINUS = 45,
    idMULT = 42,
    idDIV = 47,
    idMOD = 37,
    idLT = 60,
    idLTLT = 135,
    idLE = 137,
    idGT = 62,
    idGE = 138,
    idEq = 139,
    idEqq = 140,
    idNeq = 141,
    idNot = 33,
    idBackquote = 96,
    idEqTilde = 142,
    idNeqTilde = 143,
    idAREF = 144,
    idASET = 145,
    tPRESERVED_ID_BEGIN = 147,
    idNULL = 148,
    idEmptyP = 149,
    idEqlP = 150,
    idRespond_to = 151,
    idRespond_to_missing = 152,
    idIFUNC = 153,
    idCFUNC = 154,
    id_core_set_method_alias = 155,
    id_core_set_variable_alias = 156,
    id_core_undef_method = 157,
    id_core_define_method = 158,
    id_core_define_singleton_method = 159,
    id_core_set_postexe = 160,
    id_core_hash_from_ary = 161,
    id_core_hash_merge_ary = 162,
    id_core_hash_merge_ptr = 163,
    id_core_hash_merge_kwd = 164,
    tPRESERVED_ID_END = 165,
    tFreeze = 166,
    tInspect = 167,
    tIntern = 168,
    tObject_id = 169,
    tConst_missing = 170,
    tMethodMissing = 171,
    tMethod_added = 172,
    tSingleton_method_added = 173,
    tMethod_removed = 174,
    tSingleton_method_removed = 175,
    tMethod_undefined = 176,
    tSingleton_method_undefined = 177,
    tLength = 178,
    tSize = 179,
    tGets = 180,
    tSucc = 181,
    tEach = 182,
    tProc = 183,
    tLambda = 184,
    tSend = 185,
    t__send__ = 186,
    t__attached__ = 187,
    tInitialize = 188,
    tInitialize_copy = 189,
    tInitialize_clone = 190,
    tInitialize_dup = 191,
    tUScore = 192,
    idFreeze = 1328,
    idInspect = 1336,
    idIntern = 1344,
    idObject_id = 1352,
    idConst_missing = 1360,
    idMethodMissing = 1368,
    idMethod_added = 1376,
    idSingleton_method_added = 1384,
    idMethod_removed = 1392,
    idSingleton_method_removed = 1400,
    idMethod_undefined = 1408,
    idSingleton_method_undefined = 1416,
    idLength = 1424,
    idSize = 1432,
    idGets = 1440,
    idSucc = 1448,
    idEach = 1456,
    idProc = 1464,
    idLambda = 1472,
    idSend = 1480,
    id__send__ = 1488,
    id__attached__ = 1496,
    idInitialize = 1504,
    idInitialize_copy = 1512,
    idInitialize_clone = 1520,
    idInitialize_dup = 1528,
    idUScore = 1536,
    idLAST_OP_ID = 20,
}
#[repr(C)]
#[derive(Copy)]
pub struct Struct_Unnamed52 {
    pub nraddr: ::std::os::raw::c_ulonglong,
}
impl ::std::clone::Clone for Struct_Unnamed52 {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_Unnamed52 {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type OrigFn = Struct_Unnamed52;
#[derive(Clone, Copy)]
#[repr(u32)]
pub enum Enum_Unnamed53 {
    VG_USERREQ__RUNNING_ON_VALGRIND = 4097,
    VG_USERREQ__DISCARD_TRANSLATIONS = 4098,
    VG_USERREQ__CLIENT_CALL0 = 4353,
    VG_USERREQ__CLIENT_CALL1 = 4354,
    VG_USERREQ__CLIENT_CALL2 = 4355,
    VG_USERREQ__CLIENT_CALL3 = 4356,
    VG_USERREQ__COUNT_ERRORS = 4609,
    VG_USERREQ__GDB_MONITOR_COMMAND = 4610,
    VG_USERREQ__MALLOCLIKE_BLOCK = 4865,
    VG_USERREQ__RESIZEINPLACE_BLOCK = 4875,
    VG_USERREQ__FREELIKE_BLOCK = 4866,
    VG_USERREQ__CREATE_MEMPOOL = 4867,
    VG_USERREQ__DESTROY_MEMPOOL = 4868,
    VG_USERREQ__MEMPOOL_ALLOC = 4869,
    VG_USERREQ__MEMPOOL_FREE = 4870,
    VG_USERREQ__MEMPOOL_TRIM = 4871,
    VG_USERREQ__MOVE_MEMPOOL = 4872,
    VG_USERREQ__MEMPOOL_CHANGE = 4873,
    VG_USERREQ__MEMPOOL_EXISTS = 4874,
    VG_USERREQ__PRINTF = 5121,
    VG_USERREQ__PRINTF_BACKTRACE = 5122,
    VG_USERREQ__PRINTF_VALIST_BY_REF = 5123,
    VG_USERREQ__PRINTF_BACKTRACE_VALIST_BY_REF = 5124,
    VG_USERREQ__STACK_REGISTER = 5377,
    VG_USERREQ__STACK_DEREGISTER = 5378,
    VG_USERREQ__STACK_CHANGE = 5379,
    VG_USERREQ__LOAD_PDB_DEBUGINFO = 5633,
    VG_USERREQ__MAP_IP_TO_SRCLOC = 5889,
    VG_USERREQ__CHANGE_ERR_DISABLEMENT = 6145,
}
pub type Vg_ClientRequest = Enum_Unnamed53;
#[derive(Clone, Copy)]
#[repr(u32)]
pub enum Enum_Unnamed54 {
    VG_USERREQ__MAKE_MEM_NOACCESS = 1296236544,
    VG_USERREQ__MAKE_MEM_UNDEFINED = 1296236545,
    VG_USERREQ__MAKE_MEM_DEFINED = 1296236546,
    VG_USERREQ__DISCARD = 1296236547,
    VG_USERREQ__CHECK_MEM_IS_ADDRESSABLE = 1296236548,
    VG_USERREQ__CHECK_MEM_IS_DEFINED = 1296236549,
    VG_USERREQ__DO_LEAK_CHECK = 1296236550,
    VG_USERREQ__COUNT_LEAKS = 1296236551,
    VG_USERREQ__GET_VBITS = 1296236552,
    VG_USERREQ__SET_VBITS = 1296236553,
    VG_USERREQ__CREATE_BLOCK = 1296236554,
    VG_USERREQ__MAKE_MEM_DEFINED_IF_ADDRESSABLE = 1296236555,
    VG_USERREQ__COUNT_LEAK_BLOCKS = 1296236556,
    _VG_USERREQ__MEMCHECK_RECORD_OVERLAP_ERROR = 1296236800,
}
pub type Vg_MemCheckClientRequest = Enum_Unnamed54;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_rb_deprecated_classext_struct {
    pub conflict: [::std::os::raw::c_char; 24usize],
}
impl ::std::clone::Clone for Struct_rb_deprecated_classext_struct {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_rb_deprecated_classext_struct {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type rb_subclass_entry_t = Struct_rb_subclass_entry;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_rb_subclass_entry {
    pub klass: VALUE,
    pub next: *mut rb_subclass_entry_t,
}
impl ::std::clone::Clone for Struct_rb_subclass_entry {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_rb_subclass_entry {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type rb_serial_t = ::std::os::raw::c_ulonglong;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_rb_classext_struct {
    pub iv_index_tbl: *mut Struct_st_table,
    pub iv_tbl: *mut Struct_st_table,
    pub const_tbl: *mut Struct_st_table,
    pub subclasses: *mut rb_subclass_entry_t,
    pub parent_subclasses: *mut *mut rb_subclass_entry_t,
    pub module_subclasses: *mut *mut rb_subclass_entry_t,
    pub class_serial: rb_serial_t,
    pub origin: VALUE,
    pub refined_class: VALUE,
    pub allocator: rb_alloc_func_t,
}
impl ::std::clone::Clone for Struct_rb_classext_struct {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_rb_classext_struct {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub struct Struct_method_table_wrapper {
    pub tbl: *mut st_table,
    pub serial: size_t,
}
impl ::std::clone::Clone for Struct_method_table_wrapper {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_method_table_wrapper {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub enum Struct_vtm { }
#[repr(C)]
#[derive(Copy)]
pub struct Struct_RBasicRaw {
    pub flags: VALUE,
    pub klass: VALUE,
}
impl ::std::clone::Clone for Struct_RBasicRaw {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_RBasicRaw {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub struct Struct_rb_execarg {
    pub use_shell: ::std::os::raw::c_int,
    pub invoke: Union_Unnamed55,
    pub redirect_fds: VALUE,
    pub envp_str: VALUE,
    pub envp_buf: VALUE,
    pub dup2_tmpbuf: VALUE,
    pub _bindgen_bitfield_1_: ::std::os::raw::c_uint,
    pub pgroup_pgid: pid_t,
    pub rlimit_limits: VALUE,
    pub umask_mask: mode_t,
    pub uid: uid_t,
    pub gid: gid_t,
    pub fd_dup2: VALUE,
    pub fd_close: VALUE,
    pub fd_open: VALUE,
    pub fd_dup2_child: VALUE,
    pub close_others_maxhint: ::std::os::raw::c_int,
    pub env_modification: VALUE,
    pub chdir_dir: VALUE,
}
impl ::std::clone::Clone for Struct_rb_execarg {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_rb_execarg {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub struct Union_Unnamed55 {
    pub _bindgen_data_: [u64; 4usize],
}
impl Union_Unnamed55 {
    pub unsafe fn sh(&mut self) -> *mut Struct_Unnamed56 {
        let raw: *mut u8 = ::std::mem::transmute(&self._bindgen_data_);
        ::std::mem::transmute(raw.offset(0))
    }
    pub unsafe fn cmd(&mut self) -> *mut Struct_Unnamed57 {
        let raw: *mut u8 = ::std::mem::transmute(&self._bindgen_data_);
        ::std::mem::transmute(raw.offset(0))
    }
}
impl ::std::clone::Clone for Union_Unnamed55 {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Union_Unnamed55 {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub struct Struct_Unnamed56 {
    pub shell_script: VALUE,
}
impl ::std::clone::Clone for Struct_Unnamed56 {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_Unnamed56 {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub struct Struct_Unnamed57 {
    pub command_name: VALUE,
    pub command_abspath: VALUE,
    pub argv_str: VALUE,
    pub argv_buf: VALUE,
}
impl ::std::clone::Clone for Struct_Unnamed57 {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_Unnamed57 {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type rb_check_funcall_hook =
    unsafe extern "C" fn(arg1: ::std::os::raw::c_int, arg2: VALUE, arg3: ID,
                         arg4: ::std::os::raw::c_int, arg5: *const VALUE,
                         arg6: VALUE);
pub const NOEX_UNDEF: Enum_Unnamed58 = Enum_Unnamed58::NOEX_NOSUPER;
pub const NOEX_BIT_WIDTH: Enum_Unnamed58 = Enum_Unnamed58::NOEX_BASIC;
pub const NOEX_SAFE_SHIFT_OFFSET: Enum_Unnamed58 = Enum_Unnamed58::NOEX_BASIC;
#[derive(Clone, Copy)]
#[repr(u32)]
pub enum Enum_Unnamed58 {
    NOEX_PUBLIC = 0,
    NOEX_NOSUPER = 1,
    NOEX_PRIVATE = 2,
    NOEX_PROTECTED = 4,
    NOEX_MASK = 6,
    NOEX_BASIC = 8,
    NOEX_MODFUNC = 18,
    NOEX_SUPER = 32,
    NOEX_VCALL = 64,
    NOEX_RESPONDS = 128,
}
pub type rb_method_flag_t = Enum_Unnamed58;
#[derive(Clone, Copy)]
#[repr(u32)]
pub enum Enum_Unnamed59 {
    VM_METHOD_TYPE_ISEQ = 0,
    VM_METHOD_TYPE_CFUNC = 1,
    VM_METHOD_TYPE_ATTRSET = 2,
    VM_METHOD_TYPE_IVAR = 3,
    VM_METHOD_TYPE_BMETHOD = 4,
    VM_METHOD_TYPE_ZSUPER = 5,
    VM_METHOD_TYPE_UNDEF = 6,
    VM_METHOD_TYPE_NOTIMPLEMENTED = 7,
    VM_METHOD_TYPE_OPTIMIZED = 8,
    VM_METHOD_TYPE_MISSING = 9,
    VM_METHOD_TYPE_REFINED = 10,
}
pub type rb_method_type_t = Enum_Unnamed59;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_rb_method_cfunc_struct {
    pub func: ::std::option::Option<extern "C" fn() -> VALUE>,
    pub invoker: ::std::option::Option<unsafe extern "C" fn(func:
                                                                ::std::option::Option<extern "C" fn()
                                                                                          ->
                                                                                              VALUE>,
                                                            recv: VALUE,
                                                            argc:
                                                                ::std::os::raw::c_int,
                                                            argv:
                                                                *const VALUE)
                                           -> VALUE>,
    pub argc: ::std::os::raw::c_int,
}
impl ::std::clone::Clone for Struct_rb_method_cfunc_struct {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_rb_method_cfunc_struct {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type rb_method_cfunc_t = Struct_rb_method_cfunc_struct;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_rb_method_attr_struct {
    pub id: ID,
    pub location: VALUE,
}
impl ::std::clone::Clone for Struct_rb_method_attr_struct {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_rb_method_attr_struct {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type rb_method_attr_t = Struct_rb_method_attr_struct;
pub type rb_iseq_t = Struct_rb_iseq_struct;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_rb_method_definition_struct {
    pub _type: rb_method_type_t,
    pub original_id: ID,
    pub body: Union_Unnamed60,
    pub alias_count: ::std::os::raw::c_int,
}
impl ::std::clone::Clone for Struct_rb_method_definition_struct {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_rb_method_definition_struct {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub struct Union_Unnamed60 {
    pub _bindgen_data_: [u64; 3usize],
}
impl Union_Unnamed60 {
    pub unsafe fn iseq(&mut self) -> *mut *mut rb_iseq_t {
        let raw: *mut u8 = ::std::mem::transmute(&self._bindgen_data_);
        ::std::mem::transmute(raw.offset(0))
    }
    pub unsafe fn cfunc(&mut self) -> *mut rb_method_cfunc_t {
        let raw: *mut u8 = ::std::mem::transmute(&self._bindgen_data_);
        ::std::mem::transmute(raw.offset(0))
    }
    pub unsafe fn attr(&mut self) -> *mut rb_method_attr_t {
        let raw: *mut u8 = ::std::mem::transmute(&self._bindgen_data_);
        ::std::mem::transmute(raw.offset(0))
    }
    pub unsafe fn _proc(&mut self) -> *mut VALUE {
        let raw: *mut u8 = ::std::mem::transmute(&self._bindgen_data_);
        ::std::mem::transmute(raw.offset(0))
    }
    pub unsafe fn orig_me(&mut self)
     -> *mut *mut Struct_rb_method_entry_struct {
        let raw: *mut u8 = ::std::mem::transmute(&self._bindgen_data_);
        ::std::mem::transmute(raw.offset(0))
    }
}
impl ::std::clone::Clone for Union_Unnamed60 {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Union_Unnamed60 {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type rb_method_definition_t = Struct_rb_method_definition_struct;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_rb_method_entry_struct {
    pub flag: rb_method_flag_t,
    pub mark: ::std::os::raw::c_char,
    pub def: *mut rb_method_definition_t,
    pub called_id: ID,
    pub klass: VALUE,
}
impl ::std::clone::Clone for Struct_rb_method_entry_struct {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_rb_method_entry_struct {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type rb_method_entry_t = Struct_rb_method_entry_struct;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_unlinked_method_entry_list_entry {
    pub next: *mut Struct_unlinked_method_entry_list_entry,
    pub me: *mut rb_method_entry_t,
}
impl ::std::clone::Clone for Struct_unlinked_method_entry_list_entry {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_unlinked_method_entry_list_entry {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type rb_atomic_t = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_sched_param {
    pub __sched_priority: ::std::os::raw::c_int,
}
impl ::std::clone::Clone for Struct_sched_param {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_sched_param {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub struct Struct___sched_param {
    pub __sched_priority: ::std::os::raw::c_int,
}
impl ::std::clone::Clone for Struct___sched_param {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct___sched_param {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type __cpu_mask = ::std::os::raw::c_ulong;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_Unnamed61 {
    pub __bits: [__cpu_mask; 16usize],
}
impl ::std::clone::Clone for Struct_Unnamed61 {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_Unnamed61 {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type cpu_set_t = Struct_Unnamed61;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_timex {
    pub modes: ::std::os::raw::c_uint,
    pub offset: ::std::os::raw::c_long,
    pub freq: ::std::os::raw::c_long,
    pub maxerror: ::std::os::raw::c_long,
    pub esterror: ::std::os::raw::c_long,
    pub status: ::std::os::raw::c_int,
    pub constant: ::std::os::raw::c_long,
    pub precision: ::std::os::raw::c_long,
    pub tolerance: ::std::os::raw::c_long,
    pub time: Struct_timeval,
    pub tick: ::std::os::raw::c_long,
    pub ppsfreq: ::std::os::raw::c_long,
    pub jitter: ::std::os::raw::c_long,
    pub shift: ::std::os::raw::c_int,
    pub stabil: ::std::os::raw::c_long,
    pub jitcnt: ::std::os::raw::c_long,
    pub calcnt: ::std::os::raw::c_long,
    pub errcnt: ::std::os::raw::c_long,
    pub stbcnt: ::std::os::raw::c_long,
    pub tai: ::std::os::raw::c_int,
    pub _bindgen_bitfield_1_: ::std::os::raw::c_int,
    pub _bindgen_bitfield_2_: ::std::os::raw::c_int,
    pub _bindgen_bitfield_3_: ::std::os::raw::c_int,
    pub _bindgen_bitfield_4_: ::std::os::raw::c_int,
    pub _bindgen_bitfield_5_: ::std::os::raw::c_int,
    pub _bindgen_bitfield_6_: ::std::os::raw::c_int,
    pub _bindgen_bitfield_7_: ::std::os::raw::c_int,
    pub _bindgen_bitfield_8_: ::std::os::raw::c_int,
    pub _bindgen_bitfield_9_: ::std::os::raw::c_int,
    pub _bindgen_bitfield_10_: ::std::os::raw::c_int,
    pub _bindgen_bitfield_11_: ::std::os::raw::c_int,
}
impl ::std::clone::Clone for Struct_timex {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_timex {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub struct Struct_tm {
    pub tm_sec: ::std::os::raw::c_int,
    pub tm_min: ::std::os::raw::c_int,
    pub tm_hour: ::std::os::raw::c_int,
    pub tm_mday: ::std::os::raw::c_int,
    pub tm_mon: ::std::os::raw::c_int,
    pub tm_year: ::std::os::raw::c_int,
    pub tm_wday: ::std::os::raw::c_int,
    pub tm_yday: ::std::os::raw::c_int,
    pub tm_isdst: ::std::os::raw::c_int,
    pub tm_gmtoff: ::std::os::raw::c_long,
    pub tm_zone: *const ::std::os::raw::c_char,
}
impl ::std::clone::Clone for Struct_tm {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_tm {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub struct Struct_itimerspec {
    pub it_interval: Struct_timespec,
    pub it_value: Struct_timespec,
}
impl ::std::clone::Clone for Struct_itimerspec {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_itimerspec {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type __jmp_buf = [::std::os::raw::c_long; 8usize];
#[derive(Clone, Copy)]
#[repr(u32)]
pub enum Enum_Unnamed62 {
    PTHREAD_CREATE_JOINABLE = 0,
    PTHREAD_CREATE_DETACHED = 1,
}
pub const PTHREAD_MUTEX_NORMAL: Enum_Unnamed63 =
    Enum_Unnamed63::PTHREAD_MUTEX_TIMED_NP;
pub const PTHREAD_MUTEX_RECURSIVE: Enum_Unnamed63 =
    Enum_Unnamed63::PTHREAD_MUTEX_RECURSIVE_NP;
pub const PTHREAD_MUTEX_ERRORCHECK: Enum_Unnamed63 =
    Enum_Unnamed63::PTHREAD_MUTEX_ERRORCHECK_NP;
pub const PTHREAD_MUTEX_DEFAULT: Enum_Unnamed63 =
    Enum_Unnamed63::PTHREAD_MUTEX_TIMED_NP;
pub const PTHREAD_MUTEX_FAST_NP: Enum_Unnamed63 =
    Enum_Unnamed63::PTHREAD_MUTEX_TIMED_NP;
#[derive(Clone, Copy)]
#[repr(u32)]
pub enum Enum_Unnamed63 {
    PTHREAD_MUTEX_TIMED_NP = 0,
    PTHREAD_MUTEX_RECURSIVE_NP = 1,
    PTHREAD_MUTEX_ERRORCHECK_NP = 2,
    PTHREAD_MUTEX_ADAPTIVE_NP = 3,
}
pub const PTHREAD_MUTEX_STALLED_NP: Enum_Unnamed64 =
    Enum_Unnamed64::PTHREAD_MUTEX_STALLED;
pub const PTHREAD_MUTEX_ROBUST_NP: Enum_Unnamed64 =
    Enum_Unnamed64::PTHREAD_MUTEX_ROBUST;
#[derive(Clone, Copy)]
#[repr(u32)]
pub enum Enum_Unnamed64 {
    PTHREAD_MUTEX_STALLED = 0,
    PTHREAD_MUTEX_ROBUST = 1,
}
#[derive(Clone, Copy)]
#[repr(u32)]
pub enum Enum_Unnamed65 {
    PTHREAD_PRIO_NONE = 0,
    PTHREAD_PRIO_INHERIT = 1,
    PTHREAD_PRIO_PROTECT = 2,
}
pub const PTHREAD_RWLOCK_DEFAULT_NP: Enum_Unnamed66 =
    Enum_Unnamed66::PTHREAD_RWLOCK_PREFER_READER_NP;
#[derive(Clone, Copy)]
#[repr(u32)]
pub enum Enum_Unnamed66 {
    PTHREAD_RWLOCK_PREFER_READER_NP = 0,
    PTHREAD_RWLOCK_PREFER_WRITER_NP = 1,
    PTHREAD_RWLOCK_PREFER_WRITER_NONRECURSIVE_NP = 2,
}
#[derive(Clone, Copy)]
#[repr(u32)]
pub enum Enum_Unnamed67 {
    PTHREAD_INHERIT_SCHED = 0,
    PTHREAD_EXPLICIT_SCHED = 1,
}
#[derive(Clone, Copy)]
#[repr(u32)]
pub enum Enum_Unnamed68 {
    PTHREAD_SCOPE_SYSTEM = 0,
    PTHREAD_SCOPE_PROCESS = 1,
}
#[derive(Clone, Copy)]
#[repr(u32)]
pub enum Enum_Unnamed69 {
    PTHREAD_PROCESS_PRIVATE = 0,
    PTHREAD_PROCESS_SHARED = 1,
}
#[repr(C)]
#[derive(Copy)]
pub struct Struct__pthread_cleanup_buffer {
    pub __routine: ::std::option::Option<unsafe extern "C" fn(arg1:
                                                                  *mut ::std::os::raw::c_void)>,
    pub __arg: *mut ::std::os::raw::c_void,
    pub __canceltype: ::std::os::raw::c_int,
    pub __prev: *mut Struct__pthread_cleanup_buffer,
}
impl ::std::clone::Clone for Struct__pthread_cleanup_buffer {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct__pthread_cleanup_buffer {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[derive(Clone, Copy)]
#[repr(u32)]
pub enum Enum_Unnamed70 {
    PTHREAD_CANCEL_ENABLE = 0,
    PTHREAD_CANCEL_DISABLE = 1,
}
#[derive(Clone, Copy)]
#[repr(u32)]
pub enum Enum_Unnamed71 {
    PTHREAD_CANCEL_DEFERRED = 0,
    PTHREAD_CANCEL_ASYNCHRONOUS = 1,
}
#[repr(C)]
#[derive(Copy)]
pub struct Struct_Unnamed72 {
    pub __cancel_jmp_buf: [Struct_Unnamed73; 1usize],
    pub __pad: [*mut ::std::os::raw::c_void; 4usize],
}
impl ::std::clone::Clone for Struct_Unnamed72 {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_Unnamed72 {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub struct Struct_Unnamed73 {
    pub __cancel_jmp_buf: __jmp_buf,
    pub __mask_was_saved: ::std::os::raw::c_int,
}
impl ::std::clone::Clone for Struct_Unnamed73 {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_Unnamed73 {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type __pthread_unwind_buf_t = Struct_Unnamed72;
#[repr(C)]
#[derive(Copy)]
pub struct Struct___pthread_cleanup_frame {
    pub __cancel_routine: ::std::option::Option<unsafe extern "C" fn(arg1:
                                                                         *mut ::std::os::raw::c_void)>,
    pub __cancel_arg: *mut ::std::os::raw::c_void,
    pub __do_it: ::std::os::raw::c_int,
    pub __cancel_type: ::std::os::raw::c_int,
}
impl ::std::clone::Clone for Struct___pthread_cleanup_frame {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct___pthread_cleanup_frame {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type rb_nativethread_id_t = pthread_t;
pub type rb_nativethread_lock_t = pthread_mutex_t;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_rb_thread_cond_struct {
    pub cond: pthread_cond_t,
    pub clockid: clockid_t,
}
impl ::std::clone::Clone for Struct_rb_thread_cond_struct {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_rb_thread_cond_struct {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type rb_nativethread_cond_t = Struct_rb_thread_cond_struct;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_native_thread_data_struct {
    pub signal_thread_list: *mut ::std::os::raw::c_void,
    pub sleep_cond: rb_nativethread_cond_t,
}
impl ::std::clone::Clone for Struct_native_thread_data_struct {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_native_thread_data_struct {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type native_thread_data_t = Struct_native_thread_data_struct;
#[repr(C)]
#[derive(Copy)]
pub struct Union_Unnamed74 {
    pub _bindgen_data_: [u64; 4usize],
}
impl Union_Unnamed74 {
    pub unsafe fn __size(&mut self)
     -> *mut [::std::os::raw::c_char; 32usize] {
        let raw: *mut u8 = ::std::mem::transmute(&self._bindgen_data_);
        ::std::mem::transmute(raw.offset(0))
    }
    pub unsafe fn __align(&mut self) -> *mut ::std::os::raw::c_long {
        let raw: *mut u8 = ::std::mem::transmute(&self._bindgen_data_);
        ::std::mem::transmute(raw.offset(0))
    }
}
impl ::std::clone::Clone for Union_Unnamed74 {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Union_Unnamed74 {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type sem_t = Union_Unnamed74;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_rb_global_vm_lock_struct {
    pub acquired: ::std::os::raw::c_ulong,
    pub lock: pthread_mutex_t,
    pub waiting: ::std::os::raw::c_ulong,
    pub cond: rb_nativethread_cond_t,
    pub switch_cond: rb_nativethread_cond_t,
    pub switch_wait_cond: rb_nativethread_cond_t,
    pub need_yield: ::std::os::raw::c_int,
    pub wait_yield: ::std::os::raw::c_int,
}
impl ::std::clone::Clone for Struct_rb_global_vm_lock_struct {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_rb_global_vm_lock_struct {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type rb_global_vm_lock_t = Struct_rb_global_vm_lock_struct;
#[repr(C)]
#[derive(Copy)]
pub struct Struct___jmp_buf_tag {
    pub __jmpbuf: __jmp_buf,
    pub __mask_was_saved: ::std::os::raw::c_int,
    pub __saved_mask: __sigset_t,
}
impl ::std::clone::Clone for Struct___jmp_buf_tag {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct___jmp_buf_tag {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type jmp_buf = [Struct___jmp_buf_tag; 1usize];
pub type sigjmp_buf = [Struct___jmp_buf_tag; 1usize];
pub type sig_atomic_t = __sig_atomic_t;
#[repr(C)]
#[derive(Copy)]
pub struct Union_sigval {
    pub _bindgen_data_: [u64; 1usize],
}
impl Union_sigval {
    pub unsafe fn sival_int(&mut self) -> *mut ::std::os::raw::c_int {
        let raw: *mut u8 = ::std::mem::transmute(&self._bindgen_data_);
        ::std::mem::transmute(raw.offset(0))
    }
    pub unsafe fn sival_ptr(&mut self) -> *mut *mut ::std::os::raw::c_void {
        let raw: *mut u8 = ::std::mem::transmute(&self._bindgen_data_);
        ::std::mem::transmute(raw.offset(0))
    }
}
impl ::std::clone::Clone for Union_sigval {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Union_sigval {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type sigval_t = Union_sigval;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_siginfo {
    pub si_signo: ::std::os::raw::c_int,
    pub si_errno: ::std::os::raw::c_int,
    pub si_code: ::std::os::raw::c_int,
    pub _sifields: Union_Unnamed75,
}
impl ::std::clone::Clone for Struct_siginfo {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_siginfo {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub struct Union_Unnamed75 {
    pub _bindgen_data_: [u64; 14usize],
}
impl Union_Unnamed75 {
    pub unsafe fn _pad(&mut self) -> *mut [::std::os::raw::c_int; 28usize] {
        let raw: *mut u8 = ::std::mem::transmute(&self._bindgen_data_);
        ::std::mem::transmute(raw.offset(0))
    }
    pub unsafe fn _kill(&mut self) -> *mut Struct_Unnamed76 {
        let raw: *mut u8 = ::std::mem::transmute(&self._bindgen_data_);
        ::std::mem::transmute(raw.offset(0))
    }
    pub unsafe fn _timer(&mut self) -> *mut Struct_Unnamed77 {
        let raw: *mut u8 = ::std::mem::transmute(&self._bindgen_data_);
        ::std::mem::transmute(raw.offset(0))
    }
    pub unsafe fn _rt(&mut self) -> *mut Struct_Unnamed78 {
        let raw: *mut u8 = ::std::mem::transmute(&self._bindgen_data_);
        ::std::mem::transmute(raw.offset(0))
    }
    pub unsafe fn _sigchld(&mut self) -> *mut Struct_Unnamed79 {
        let raw: *mut u8 = ::std::mem::transmute(&self._bindgen_data_);
        ::std::mem::transmute(raw.offset(0))
    }
    pub unsafe fn _sigfault(&mut self) -> *mut Struct_Unnamed80 {
        let raw: *mut u8 = ::std::mem::transmute(&self._bindgen_data_);
        ::std::mem::transmute(raw.offset(0))
    }
    pub unsafe fn _sigpoll(&mut self) -> *mut Struct_Unnamed81 {
        let raw: *mut u8 = ::std::mem::transmute(&self._bindgen_data_);
        ::std::mem::transmute(raw.offset(0))
    }
}
impl ::std::clone::Clone for Union_Unnamed75 {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Union_Unnamed75 {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub struct Struct_Unnamed76 {
    pub si_pid: __pid_t,
    pub si_uid: __uid_t,
}
impl ::std::clone::Clone for Struct_Unnamed76 {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_Unnamed76 {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub struct Struct_Unnamed77 {
    pub si_tid: ::std::os::raw::c_int,
    pub si_overrun: ::std::os::raw::c_int,
    pub si_sigval: sigval_t,
}
impl ::std::clone::Clone for Struct_Unnamed77 {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_Unnamed77 {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub struct Struct_Unnamed78 {
    pub si_pid: __pid_t,
    pub si_uid: __uid_t,
    pub si_sigval: sigval_t,
}
impl ::std::clone::Clone for Struct_Unnamed78 {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_Unnamed78 {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub struct Struct_Unnamed79 {
    pub si_pid: __pid_t,
    pub si_uid: __uid_t,
    pub si_status: ::std::os::raw::c_int,
    pub si_utime: __clock_t,
    pub si_stime: __clock_t,
}
impl ::std::clone::Clone for Struct_Unnamed79 {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_Unnamed79 {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub struct Struct_Unnamed80 {
    pub si_addr: *mut ::std::os::raw::c_void,
}
impl ::std::clone::Clone for Struct_Unnamed80 {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_Unnamed80 {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub struct Struct_Unnamed81 {
    pub si_band: ::std::os::raw::c_long,
    pub si_fd: ::std::os::raw::c_int,
}
impl ::std::clone::Clone for Struct_Unnamed81 {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_Unnamed81 {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type siginfo_t = Struct_siginfo;
#[derive(Clone, Copy)]
#[repr(i32)]
pub enum Enum_Unnamed82 {
    SI_ASYNCNL = -60,
    SI_TKILL = -6,
    SI_SIGIO = -5,
    SI_ASYNCIO = -4,
    SI_MESGQ = -3,
    SI_TIMER = -2,
    SI_QUEUE = -1,
    SI_USER = 0,
    SI_KERNEL = 128,
}
#[derive(Clone, Copy)]
#[repr(u32)]
pub enum Enum_Unnamed83 {
    ILL_ILLOPC = 1,
    ILL_ILLOPN = 2,
    ILL_ILLADR = 3,
    ILL_ILLTRP = 4,
    ILL_PRVOPC = 5,
    ILL_PRVREG = 6,
    ILL_COPROC = 7,
    ILL_BADSTK = 8,
}
#[derive(Clone, Copy)]
#[repr(u32)]
pub enum Enum_Unnamed84 {
    FPE_INTDIV = 1,
    FPE_INTOVF = 2,
    FPE_FLTDIV = 3,
    FPE_FLTOVF = 4,
    FPE_FLTUND = 5,
    FPE_FLTRES = 6,
    FPE_FLTINV = 7,
    FPE_FLTSUB = 8,
}
#[derive(Clone, Copy)]
#[repr(u32)]
pub enum Enum_Unnamed85 { SEGV_MAPERR = 1, SEGV_ACCERR = 2, }
#[derive(Clone, Copy)]
#[repr(u32)]
pub enum Enum_Unnamed86 { BUS_ADRALN = 1, BUS_ADRERR = 2, BUS_OBJERR = 3, }
#[derive(Clone, Copy)]
#[repr(u32)]
pub enum Enum_Unnamed87 { TRAP_BRKPT = 1, TRAP_TRACE = 2, }
#[derive(Clone, Copy)]
#[repr(u32)]
pub enum Enum_Unnamed88 {
    CLD_EXITED = 1,
    CLD_KILLED = 2,
    CLD_DUMPED = 3,
    CLD_TRAPPED = 4,
    CLD_STOPPED = 5,
    CLD_CONTINUED = 6,
}
#[derive(Clone, Copy)]
#[repr(u32)]
pub enum Enum_Unnamed89 {
    POLL_IN = 1,
    POLL_OUT = 2,
    POLL_MSG = 3,
    POLL_ERR = 4,
    POLL_PRI = 5,
    POLL_HUP = 6,
}
#[repr(C)]
#[derive(Copy)]
pub struct Struct_sigevent {
    pub sigev_value: sigval_t,
    pub sigev_signo: ::std::os::raw::c_int,
    pub sigev_notify: ::std::os::raw::c_int,
    pub _sigev_un: Union_Unnamed90,
}
impl ::std::clone::Clone for Struct_sigevent {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_sigevent {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub struct Union_Unnamed90 {
    pub _bindgen_data_: [u64; 6usize],
}
impl Union_Unnamed90 {
    pub unsafe fn _pad(&mut self) -> *mut [::std::os::raw::c_int; 12usize] {
        let raw: *mut u8 = ::std::mem::transmute(&self._bindgen_data_);
        ::std::mem::transmute(raw.offset(0))
    }
    pub unsafe fn _tid(&mut self) -> *mut __pid_t {
        let raw: *mut u8 = ::std::mem::transmute(&self._bindgen_data_);
        ::std::mem::transmute(raw.offset(0))
    }
    pub unsafe fn _sigev_thread(&mut self) -> *mut Struct_Unnamed91 {
        let raw: *mut u8 = ::std::mem::transmute(&self._bindgen_data_);
        ::std::mem::transmute(raw.offset(0))
    }
}
impl ::std::clone::Clone for Union_Unnamed90 {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Union_Unnamed90 {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub struct Struct_Unnamed91 {
    pub _function: ::std::option::Option<extern "C" fn(arg1: sigval_t)>,
    pub _attribute: *mut ::std::os::raw::c_void,
}
impl ::std::clone::Clone for Struct_Unnamed91 {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_Unnamed91 {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type sigevent_t = Struct_sigevent;
#[derive(Clone, Copy)]
#[repr(u32)]
pub enum Enum_Unnamed92 {
    SIGEV_SIGNAL = 0,
    SIGEV_NONE = 1,
    SIGEV_THREAD = 2,
    SIGEV_THREAD_ID = 4,
}
pub type __sighandler_t =
    ::std::option::Option<extern "C" fn(arg1: ::std::os::raw::c_int)>;
pub type sighandler_t = __sighandler_t;
pub type sig_t = __sighandler_t;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_sigaction {
    pub __sigaction_handler: Union_Unnamed93,
    pub sa_mask: __sigset_t,
    pub sa_flags: ::std::os::raw::c_int,
    pub sa_restorer: ::std::option::Option<extern "C" fn()>,
}
impl ::std::clone::Clone for Struct_sigaction {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_sigaction {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub struct Union_Unnamed93 {
    pub _bindgen_data_: [u64; 1usize],
}
impl Union_Unnamed93 {
    pub unsafe fn sa_handler(&mut self) -> *mut __sighandler_t {
        let raw: *mut u8 = ::std::mem::transmute(&self._bindgen_data_);
        ::std::mem::transmute(raw.offset(0))
    }
    pub unsafe fn sa_sigaction(&mut self)
     ->
         *mut ::std::option::Option<unsafe extern "C" fn(arg1:
                                                             ::std::os::raw::c_int,
                                                         arg2: *mut siginfo_t,
                                                         arg3:
                                                             *mut ::std::os::raw::c_void)> {
        let raw: *mut u8 = ::std::mem::transmute(&self._bindgen_data_);
        ::std::mem::transmute(raw.offset(0))
    }
}
impl ::std::clone::Clone for Union_Unnamed93 {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Union_Unnamed93 {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub struct Struct_sigvec {
    pub sv_handler: __sighandler_t,
    pub sv_mask: ::std::os::raw::c_int,
    pub sv_flags: ::std::os::raw::c_int,
}
impl ::std::clone::Clone for Struct_sigvec {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_sigvec {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub struct Struct__fpreg {
    pub significand: [::std::os::raw::c_ushort; 4usize],
    pub exponent: ::std::os::raw::c_ushort,
}
impl ::std::clone::Clone for Struct__fpreg {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct__fpreg {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub struct Struct__fpxreg {
    pub significand: [::std::os::raw::c_ushort; 4usize],
    pub exponent: ::std::os::raw::c_ushort,
    pub padding: [::std::os::raw::c_ushort; 3usize],
}
impl ::std::clone::Clone for Struct__fpxreg {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct__fpxreg {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub struct Struct__xmmreg {
    pub element: [__uint32_t; 4usize],
}
impl ::std::clone::Clone for Struct__xmmreg {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct__xmmreg {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub struct Struct__fpstate {
    pub cwd: __uint16_t,
    pub swd: __uint16_t,
    pub ftw: __uint16_t,
    pub fop: __uint16_t,
    pub rip: __uint64_t,
    pub rdp: __uint64_t,
    pub mxcsr: __uint32_t,
    pub mxcr_mask: __uint32_t,
    pub _st: [Struct__fpxreg; 8usize],
    pub _xmm: [Struct__xmmreg; 16usize],
    pub padding: [__uint32_t; 24usize],
}
impl ::std::clone::Clone for Struct__fpstate {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct__fpstate {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub struct Struct_sigcontext {
    pub r8: ::std::os::raw::c_ulong,
    pub r9: ::std::os::raw::c_ulong,
    pub r10: ::std::os::raw::c_ulong,
    pub r11: ::std::os::raw::c_ulong,
    pub r12: ::std::os::raw::c_ulong,
    pub r13: ::std::os::raw::c_ulong,
    pub r14: ::std::os::raw::c_ulong,
    pub r15: ::std::os::raw::c_ulong,
    pub rdi: ::std::os::raw::c_ulong,
    pub rsi: ::std::os::raw::c_ulong,
    pub rbp: ::std::os::raw::c_ulong,
    pub rbx: ::std::os::raw::c_ulong,
    pub rdx: ::std::os::raw::c_ulong,
    pub rax: ::std::os::raw::c_ulong,
    pub rcx: ::std::os::raw::c_ulong,
    pub rsp: ::std::os::raw::c_ulong,
    pub rip: ::std::os::raw::c_ulong,
    pub eflags: ::std::os::raw::c_ulong,
    pub cs: ::std::os::raw::c_ushort,
    pub gs: ::std::os::raw::c_ushort,
    pub fs: ::std::os::raw::c_ushort,
    pub __pad0: ::std::os::raw::c_ushort,
    pub err: ::std::os::raw::c_ulong,
    pub trapno: ::std::os::raw::c_ulong,
    pub oldmask: ::std::os::raw::c_ulong,
    pub cr2: ::std::os::raw::c_ulong,
    pub fpstate: *mut Struct__fpstate,
    pub __reserved1: [::std::os::raw::c_ulong; 8usize],
}
impl ::std::clone::Clone for Struct_sigcontext {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_sigcontext {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub struct Struct_sigstack {
    pub ss_sp: *mut ::std::os::raw::c_void,
    pub ss_onstack: ::std::os::raw::c_int,
}
impl ::std::clone::Clone for Struct_sigstack {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_sigstack {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[derive(Clone, Copy)]
#[repr(u32)]
pub enum Enum_Unnamed94 { SS_ONSTACK = 1, SS_DISABLE = 2, }
#[repr(C)]
#[derive(Copy)]
pub struct Struct_sigaltstack {
    pub ss_sp: *mut ::std::os::raw::c_void,
    pub ss_flags: ::std::os::raw::c_int,
    pub ss_size: size_t,
}
impl ::std::clone::Clone for Struct_sigaltstack {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_sigaltstack {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type stack_t = Struct_sigaltstack;
pub type greg_t = ::std::os::raw::c_long;
pub type gregset_t = [greg_t; 23usize];
#[derive(Clone, Copy)]
#[repr(u32)]
pub enum Enum_Unnamed95 {
    REG_R8 = 0,
    REG_R9 = 1,
    REG_R10 = 2,
    REG_R11 = 3,
    REG_R12 = 4,
    REG_R13 = 5,
    REG_R14 = 6,
    REG_R15 = 7,
    REG_RDI = 8,
    REG_RSI = 9,
    REG_RBP = 10,
    REG_RBX = 11,
    REG_RDX = 12,
    REG_RAX = 13,
    REG_RCX = 14,
    REG_RSP = 15,
    REG_RIP = 16,
    REG_EFL = 17,
    REG_CSGSFS = 18,
    REG_ERR = 19,
    REG_TRAPNO = 20,
    REG_OLDMASK = 21,
    REG_CR2 = 22,
}
#[repr(C)]
#[derive(Copy)]
pub struct Struct__libc_fpxreg {
    pub significand: [::std::os::raw::c_ushort; 4usize],
    pub exponent: ::std::os::raw::c_ushort,
    pub padding: [::std::os::raw::c_ushort; 3usize],
}
impl ::std::clone::Clone for Struct__libc_fpxreg {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct__libc_fpxreg {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub struct Struct__libc_xmmreg {
    pub element: [__uint32_t; 4usize],
}
impl ::std::clone::Clone for Struct__libc_xmmreg {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct__libc_xmmreg {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub struct Struct__libc_fpstate {
    pub cwd: __uint16_t,
    pub swd: __uint16_t,
    pub ftw: __uint16_t,
    pub fop: __uint16_t,
    pub rip: __uint64_t,
    pub rdp: __uint64_t,
    pub mxcsr: __uint32_t,
    pub mxcr_mask: __uint32_t,
    pub _st: [Struct__libc_fpxreg; 8usize],
    pub _xmm: [Struct__libc_xmmreg; 16usize],
    pub padding: [__uint32_t; 24usize],
}
impl ::std::clone::Clone for Struct__libc_fpstate {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct__libc_fpstate {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type fpregset_t = *mut Struct__libc_fpstate;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_Unnamed96 {
    pub gregs: gregset_t,
    pub fpregs: fpregset_t,
    pub __reserved1: [::std::os::raw::c_ulong; 8usize],
}
impl ::std::clone::Clone for Struct_Unnamed96 {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_Unnamed96 {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type mcontext_t = Struct_Unnamed96;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_ucontext {
    pub uc_flags: ::std::os::raw::c_ulong,
    pub uc_link: *mut Struct_ucontext,
    pub uc_stack: stack_t,
    pub uc_mcontext: mcontext_t,
    pub uc_sigmask: __sigset_t,
    pub __fpregs_mem: Struct__libc_fpstate,
}
impl ::std::clone::Clone for Struct_ucontext {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_ucontext {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type ucontext_t = Struct_ucontext;
pub type rb_num_t = ::std::os::raw::c_ulong;
pub enum Struct_iseq_compile_data_ensure_node_stack { }
pub enum Struct_rb_compile_option_struct { }
pub type rb_compile_option_t = Struct_rb_compile_option_struct;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_iseq_inline_cache_entry {
    pub ic_serial: rb_serial_t,
    pub ic_value: Union_Unnamed97,
}
impl ::std::clone::Clone for Struct_iseq_inline_cache_entry {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_iseq_inline_cache_entry {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub struct Union_Unnamed97 {
    pub _bindgen_data_: [u64; 1usize],
}
impl Union_Unnamed97 {
    pub unsafe fn index(&mut self) -> *mut size_t {
        let raw: *mut u8 = ::std::mem::transmute(&self._bindgen_data_);
        ::std::mem::transmute(raw.offset(0))
    }
    pub unsafe fn value(&mut self) -> *mut VALUE {
        let raw: *mut u8 = ::std::mem::transmute(&self._bindgen_data_);
        ::std::mem::transmute(raw.offset(0))
    }
}
impl ::std::clone::Clone for Union_Unnamed97 {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Union_Unnamed97 {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub struct Union_iseq_inline_storage_entry {
    pub _bindgen_data_: [u64; 3usize],
}
impl Union_iseq_inline_storage_entry {
    pub unsafe fn once(&mut self) -> *mut Struct_Unnamed98 {
        let raw: *mut u8 = ::std::mem::transmute(&self._bindgen_data_);
        ::std::mem::transmute(raw.offset(0))
    }
    pub unsafe fn cache(&mut self) -> *mut Struct_iseq_inline_cache_entry {
        let raw: *mut u8 = ::std::mem::transmute(&self._bindgen_data_);
        ::std::mem::transmute(raw.offset(0))
    }
}
impl ::std::clone::Clone for Union_iseq_inline_storage_entry {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Union_iseq_inline_storage_entry {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub struct Struct_Unnamed98 {
    pub running_thread: *mut Struct_rb_thread_struct,
    pub value: VALUE,
    pub done: VALUE,
}
impl ::std::clone::Clone for Struct_Unnamed98 {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_Unnamed98 {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub struct Struct_rb_call_info_struct {
    pub mid: ID,
    pub flag: VALUE,
    pub orig_argc: ::std::os::raw::c_int,
    pub blockiseq: *mut rb_iseq_t,
    pub method_state: rb_serial_t,
    pub class_serial: rb_serial_t,
    pub klass: VALUE,
    pub me: *const rb_method_entry_t,
    pub defined_class: VALUE,
    pub argc: ::std::os::raw::c_int,
    pub blockptr: *mut Struct_rb_block_struct,
    pub recv: VALUE,
    pub aux: Union_Unnamed99,
    pub call: ::std::option::Option<unsafe extern "C" fn(th:
                                                             *mut Struct_rb_thread_struct,
                                                         cfp:
                                                             *mut Struct_rb_control_frame_struct,
                                                         ci:
                                                             *mut Struct_rb_call_info_struct)
                                        -> VALUE>,
}
impl ::std::clone::Clone for Struct_rb_call_info_struct {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_rb_call_info_struct {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub struct Union_Unnamed99 {
    pub _bindgen_data_: [u64; 1usize],
}
impl Union_Unnamed99 {
    pub unsafe fn opt_pc(&mut self) -> *mut ::std::os::raw::c_int {
        let raw: *mut u8 = ::std::mem::transmute(&self._bindgen_data_);
        ::std::mem::transmute(raw.offset(0))
    }
    pub unsafe fn index(&mut self) -> *mut ::std::os::raw::c_long {
        let raw: *mut u8 = ::std::mem::transmute(&self._bindgen_data_);
        ::std::mem::transmute(raw.offset(0))
    }
    pub unsafe fn missing_reason(&mut self) -> *mut ::std::os::raw::c_int {
        let raw: *mut u8 = ::std::mem::transmute(&self._bindgen_data_);
        ::std::mem::transmute(raw.offset(0))
    }
    pub unsafe fn inc_sp(&mut self) -> *mut ::std::os::raw::c_int {
        let raw: *mut u8 = ::std::mem::transmute(&self._bindgen_data_);
        ::std::mem::transmute(raw.offset(0))
    }
}
impl ::std::clone::Clone for Union_Unnamed99 {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Union_Unnamed99 {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type rb_call_info_t = Struct_rb_call_info_struct;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_rb_iseq_location_struct {
    pub path: VALUE,
    pub absolute_path: VALUE,
    pub base_label: VALUE,
    pub label: VALUE,
    pub first_lineno: size_t,
}
impl ::std::clone::Clone for Struct_rb_iseq_location_struct {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_rb_iseq_location_struct {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type rb_iseq_location_t = Struct_rb_iseq_location_struct;
pub enum Struct_iseq_line_info_entry { }
pub enum Struct_iseq_catch_table_entry { }
pub enum Struct_iseq_compile_data { }
#[repr(C)]
#[derive(Copy)]
pub struct Struct_rb_iseq_struct {
    pub _type: Enum_iseq_type,
    pub location: rb_iseq_location_t,
    pub iseq: *mut VALUE,
    pub iseq_encoded: *mut VALUE,
    pub iseq_size: ::std::os::raw::c_ulong,
    pub mark_ary: VALUE,
    pub coverage: VALUE,
    pub line_info_table: *mut Struct_iseq_line_info_entry,
    pub line_info_size: size_t,
    pub local_table: *mut ID,
    pub local_table_size: ::std::os::raw::c_int,
    pub local_size: ::std::os::raw::c_int,
    pub is_entries: *mut Union_iseq_inline_storage_entry,
    pub is_size: ::std::os::raw::c_int,
    pub callinfo_entries: *mut rb_call_info_t,
    pub callinfo_size: ::std::os::raw::c_int,
    pub argc: ::std::os::raw::c_int,
    pub arg_simple: ::std::os::raw::c_int,
    pub arg_rest: ::std::os::raw::c_int,
    pub arg_block: ::std::os::raw::c_int,
    pub arg_opts: ::std::os::raw::c_int,
    pub arg_post_len: ::std::os::raw::c_int,
    pub arg_post_start: ::std::os::raw::c_int,
    pub arg_size: ::std::os::raw::c_int,
    pub arg_opt_table: *mut VALUE,
    pub arg_keyword: ::std::os::raw::c_int,
    pub arg_keyword_check: ::std::os::raw::c_int,
    pub arg_keywords: ::std::os::raw::c_int,
    pub arg_keyword_required: ::std::os::raw::c_int,
    pub arg_keyword_table: *mut ID,
    pub stack_max: size_t,
    pub catch_table: *mut Struct_iseq_catch_table_entry,
    pub catch_table_size: ::std::os::raw::c_int,
    pub parent_iseq: *mut Struct_rb_iseq_struct,
    pub local_iseq: *mut Struct_rb_iseq_struct,
    pub _self: VALUE,
    pub orig: VALUE,
    pub cref_stack: *mut NODE,
    pub klass: VALUE,
    pub defined_method_id: ID,
    pub flip_cnt: rb_num_t,
    pub compile_data: *mut Struct_iseq_compile_data,
}
impl ::std::clone::Clone for Struct_rb_iseq_struct {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_rb_iseq_struct {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[derive(Clone, Copy)]
#[repr(u32)]
pub enum Enum_ruby_special_exceptions {
    ruby_error_reenter = 0,
    ruby_error_nomemory = 1,
    ruby_error_sysstack = 2,
    ruby_error_closed_stream = 3,
    ruby_special_error_count = 4,
}
#[derive(Clone, Copy)]
#[repr(u32)]
pub enum Enum_iseq_type {
    ISEQ_TYPE_TOP,
    ISEQ_TYPE_METHOD,
    ISEQ_TYPE_BLOCK,
    ISEQ_TYPE_CLASS,
    ISEQ_TYPE_RESCUE,
    ISEQ_TYPE_ENSURE,
    ISEQ_TYPE_EVAL,
    ISEQ_TYPE_MAIN,
    ISEQ_TYPE_DEFINED_GUARD
}
pub enum Struct_rb_objspace { }
pub enum Struct_rb_event_hook_struct { }
#[repr(C)]
#[derive(Copy)]
pub struct Struct_rb_hook_list_struct {
    pub hooks: *mut Struct_rb_event_hook_struct,
    pub events: rb_event_flag_t,
    pub need_clean: ::std::os::raw::c_int,
}
impl ::std::clone::Clone for Struct_rb_hook_list_struct {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_rb_hook_list_struct {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type rb_hook_list_t = Struct_rb_hook_list_struct;
pub enum Struct_rb_postponed_job_struct { }
#[repr(C)]
#[derive(Copy)]
pub struct Struct_rb_vm_struct {
    pub _self: VALUE,
    pub gvl: rb_global_vm_lock_t,
    pub thread_destruct_lock: rb_nativethread_lock_t,
    pub main_thread: *mut Struct_rb_thread_struct,
    pub running_thread: *mut Struct_rb_thread_struct,
    pub living_threads: *mut st_table,
    pub thgroup_default: VALUE,
    pub running: ::std::os::raw::c_int,
    pub thread_abort_on_exception: ::std::os::raw::c_int,
    pub trace_running: ::std::os::raw::c_int,
    pub sleeper: ::std::os::raw::c_int,
    pub mark_object_ary: VALUE,
    pub special_exceptions: [VALUE; 4usize],
    pub top_self: VALUE,
    pub load_path: VALUE,
    pub load_path_snapshot: VALUE,
    pub load_path_check_cache: VALUE,
    pub expanded_load_path: VALUE,
    pub loaded_features: VALUE,
    pub loaded_features_snapshot: VALUE,
    pub loaded_features_index: *mut Struct_st_table,
    pub loading_table: *mut Struct_st_table,
    pub trap_list: [Struct_Unnamed100; 65usize],
    pub event_hooks: rb_hook_list_t,
    pub ensure_rollback_table: *mut Struct_st_table,
    pub postponed_job_buffer: *mut Struct_rb_postponed_job_struct,
    pub postponed_job_index: ::std::os::raw::c_int,
    pub src_encoding_index: ::std::os::raw::c_int,
    pub verbose: VALUE,
    pub debug: VALUE,
    pub orig_progname: VALUE,
    pub progname: VALUE,
    pub coverages: VALUE,
    pub unlinked_method_entry_list: *mut Struct_unlinked_method_entry_list_entry,
    pub defined_module_hash: VALUE,
    pub objspace: *mut Struct_rb_objspace,
    pub at_exit: Struct_RArray,
    pub defined_strings: *mut VALUE,
    pub default_params: Struct_Unnamed101,
}
impl ::std::clone::Clone for Struct_rb_vm_struct {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_rb_vm_struct {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub struct Struct_Unnamed100 {
    pub cmd: VALUE,
    pub safe: ::std::os::raw::c_int,
}
impl ::std::clone::Clone for Struct_Unnamed100 {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_Unnamed100 {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub struct Struct_Unnamed101 {
    pub thread_vm_stack_size: size_t,
    pub thread_machine_stack_size: size_t,
    pub fiber_vm_stack_size: size_t,
    pub fiber_machine_stack_size: size_t,
}
impl ::std::clone::Clone for Struct_Unnamed101 {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_Unnamed101 {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type rb_vm_t = Struct_rb_vm_struct;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_rb_control_frame_struct {
    pub pc: *mut VALUE,
    pub sp: *mut VALUE,
    pub iseq: *mut rb_iseq_t,
    pub flag: VALUE,
    pub _self: VALUE,
    pub klass: VALUE,
    pub ep: *mut VALUE,
    pub block_iseq: *mut rb_iseq_t,
    pub _proc: VALUE,
    pub me: *const rb_method_entry_t,
}
impl ::std::clone::Clone for Struct_rb_control_frame_struct {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_rb_control_frame_struct {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type rb_control_frame_t = Struct_rb_control_frame_struct;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_rb_block_struct {
    pub _self: VALUE,
    pub klass: VALUE,
    pub ep: *mut VALUE,
    pub iseq: *mut rb_iseq_t,
    pub _proc: VALUE,
}
impl ::std::clone::Clone for Struct_rb_block_struct {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_rb_block_struct {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type rb_block_t = Struct_rb_block_struct;
#[derive(Clone, Copy)]
#[repr(u32)]
pub enum Enum_rb_thread_status {
    THREAD_RUNNABLE = 0,
    THREAD_STOPPED = 1,
    THREAD_STOPPED_FOREVER = 2,
    THREAD_KILLED = 3,
}
pub type rb_jmpbuf_t = jmp_buf;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_rb_vm_tag {
    pub tag: VALUE,
    pub retval: VALUE,
    pub buf: rb_jmpbuf_t,
    pub prev: *mut Struct_rb_vm_tag,
}
impl ::std::clone::Clone for Struct_rb_vm_tag {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_rb_vm_tag {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub struct Struct_rb_vm_protect_tag {
    pub prev: *mut Struct_rb_vm_protect_tag,
}
impl ::std::clone::Clone for Struct_rb_vm_protect_tag {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_rb_vm_protect_tag {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub struct Struct_rb_unblock_callback {
    pub func: *mut ::std::option::Option<extern "C" fn()>,
    pub arg: *mut ::std::os::raw::c_void,
}
impl ::std::clone::Clone for Struct_rb_unblock_callback {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_rb_unblock_callback {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub enum Struct_rb_mutex_struct { }
#[repr(C)]
#[derive(Copy)]
pub struct Struct_rb_thread_list_struct {
    pub next: *mut Struct_rb_thread_list_struct,
    pub th: *mut Struct_rb_thread_struct,
}
impl ::std::clone::Clone for Struct_rb_thread_list_struct {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_rb_thread_list_struct {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type rb_thread_list_t = Struct_rb_thread_list_struct;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_rb_ensure_entry {
    pub marker: VALUE,
    pub e_proc: ::std::option::Option<extern "C" fn() -> VALUE>,
    pub data2: VALUE,
}
impl ::std::clone::Clone for Struct_rb_ensure_entry {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_rb_ensure_entry {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type rb_ensure_entry_t = Struct_rb_ensure_entry;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_rb_ensure_list {
    pub next: *mut Struct_rb_ensure_list,
    pub entry: Struct_rb_ensure_entry,
}
impl ::std::clone::Clone for Struct_rb_ensure_list {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_rb_ensure_list {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type rb_ensure_list_t = Struct_rb_ensure_list;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_rb_thread_struct {
    pub _self: VALUE,
    pub vm: *mut rb_vm_t,
    pub stack: *mut VALUE,
    pub stack_size: size_t,
    pub cfp: *mut rb_control_frame_t,
    pub safe_level: ::std::os::raw::c_int,
    pub raised_flag: ::std::os::raw::c_int,
    pub last_status: VALUE,
    pub state: ::std::os::raw::c_int,
    pub waiting_fd: ::std::os::raw::c_int,
    pub passed_block: *const rb_block_t,
    pub passed_bmethod_me: *const rb_method_entry_t,
    pub passed_ci: *mut rb_call_info_t,
    pub top_self: VALUE,
    pub top_wrapper: VALUE,
    pub base_block: *mut rb_block_t,
    pub root_lep: *mut VALUE,
    pub root_svar: VALUE,
    pub thread_id: rb_nativethread_id_t,
    pub status: Enum_rb_thread_status,
    pub to_kill: ::std::os::raw::c_int,
    pub priority: ::std::os::raw::c_int,
    pub native_thread_data: native_thread_data_t,
    pub blocking_region_buffer: *mut ::std::os::raw::c_void,
    pub thgroup: VALUE,
    pub value: VALUE,
    pub errinfo: VALUE,
    pub pending_interrupt_queue: VALUE,
    pub pending_interrupt_queue_checked: ::std::os::raw::c_int,
    pub pending_interrupt_mask_stack: VALUE,
    pub interrupt_flag: rb_atomic_t,
    pub interrupt_mask: ::std::os::raw::c_ulong,
    pub interrupt_lock: rb_nativethread_lock_t,
    pub interrupt_cond: rb_nativethread_cond_t,
    pub unblock: Struct_rb_unblock_callback,
    pub locking_mutex: VALUE,
    pub keeping_mutexes: *mut Struct_rb_mutex_struct,
    pub tag: *mut Struct_rb_vm_tag,
    pub protect_tag: *mut Struct_rb_vm_protect_tag,
    pub parse_in_eval: ::std::os::raw::c_int,
    pub mild_compile_error: ::std::os::raw::c_int,
    pub local_storage: *mut st_table,
    pub join_list: *mut rb_thread_list_t,
    pub first_proc: VALUE,
    pub first_args: VALUE,
    pub first_func: ::std::option::Option<extern "C" fn() -> VALUE>,
    pub machine: Struct_Unnamed102,
    pub mark_stack_len: ::std::os::raw::c_int,
    pub stat_insn_usage: VALUE,
    pub event_hooks: rb_hook_list_t,
    pub trace_arg: *mut Struct_rb_trace_arg_struct,
    pub fiber: VALUE,
    pub root_fiber: VALUE,
    pub root_jmpbuf: rb_jmpbuf_t,
    pub ensure_list: *mut rb_ensure_list_t,
    pub method_missing_reason: ::std::os::raw::c_int,
    pub abort_on_exception: ::std::os::raw::c_int,
    pub altstack: *mut ::std::os::raw::c_void,
    pub running_time_us: ::std::os::raw::c_ulong,
}
impl ::std::clone::Clone for Struct_rb_thread_struct {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_rb_thread_struct {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub struct Struct_Unnamed102 {
    pub stack_start: *mut VALUE,
    pub stack_end: *mut VALUE,
    pub stack_maxsize: size_t,
    pub regs: jmp_buf,
}
impl ::std::clone::Clone for Struct_Unnamed102 {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_Unnamed102 {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type rb_thread_t = Struct_rb_thread_struct;
#[derive(Clone, Copy)]
#[repr(u32)]
pub enum Enum_Unnamed103 {
    VM_DEFINECLASS_TYPE_CLASS = 0,
    VM_DEFINECLASS_TYPE_SINGLETON_CLASS = 1,
    VM_DEFINECLASS_TYPE_MODULE = 2,
    VM_DEFINECLASS_TYPE_MASK = 7,
}
pub type rb_vm_defineclass_type_t = Enum_Unnamed103;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_Unnamed104 {
    pub block: rb_block_t,
    pub envval: VALUE,
    pub blockprocval: VALUE,
    pub safe_level: ::std::os::raw::c_int,
    pub is_from_method: ::std::os::raw::c_int,
    pub is_lambda: ::std::os::raw::c_int,
}
impl ::std::clone::Clone for Struct_Unnamed104 {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_Unnamed104 {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type rb_proc_t = Struct_Unnamed104;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_Unnamed105 {
    pub env: *mut VALUE,
    pub env_size: ::std::os::raw::c_int,
    pub local_size: ::std::os::raw::c_int,
    pub prev_envval: VALUE,
    pub block: rb_block_t,
}
impl ::std::clone::Clone for Struct_Unnamed105 {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_Unnamed105 {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type rb_env_t = Struct_Unnamed105;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_Unnamed106 {
    pub env: VALUE,
    pub path: VALUE,
    pub blockprocval: VALUE,
    pub first_lineno: ::std::os::raw::c_ushort,
}
impl ::std::clone::Clone for Struct_Unnamed106 {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_Unnamed106 {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type rb_binding_t = Struct_Unnamed106;
#[derive(Clone, Copy)]
#[repr(u32)]
pub enum Enum_vm_check_match_type {
    VM_CHECKMATCH_TYPE_WHEN = 1,
    VM_CHECKMATCH_TYPE_CASE = 2,
    VM_CHECKMATCH_TYPE_RESCUE = 3,
}
#[derive(Clone, Copy)]
#[repr(u32)]
pub enum Enum_vm_special_object_type {
    VM_SPECIAL_OBJECT_VMCORE = 1,
    VM_SPECIAL_OBJECT_CBASE = 2,
    VM_SPECIAL_OBJECT_CONST_BASE = 3,
}
pub type IC = *mut Struct_iseq_inline_cache_entry;
pub type CALL_INFO = *mut rb_call_info_t;
pub type CDHASH = VALUE;
pub type rb_insn_func_t =
    ::std::option::Option<unsafe extern "C" fn(arg1: *mut rb_thread_t,
                                               arg2: *mut rb_control_frame_t)
                              -> *mut rb_control_frame_t>;
pub type rb_backtrace_iter_func =
    unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void, arg2: VALUE,
                         arg3: ::std::os::raw::c_int, arg4: VALUE)
        -> ::std::os::raw::c_int;
#[derive(Clone, Copy)]
#[repr(u32)]
pub enum Enum_Unnamed107 {
    TIMER_INTERRUPT_MASK = 1,
    PENDING_INTERRUPT_MASK = 2,
    POSTPONED_JOB_INTERRUPT_MASK = 4,
    TRAP_INTERRUPT_MASK = 8,
}
#[repr(C)]
#[derive(Copy)]
pub struct Struct_rb_trace_arg_struct {
    pub event: rb_event_flag_t,
    pub th: *mut rb_thread_t,
    pub cfp: *mut rb_control_frame_t,
    pub _self: VALUE,
    pub id: ID,
    pub klass: VALUE,
    pub data: VALUE,
    pub klass_solved: ::std::os::raw::c_int,
    pub lineno: ::std::os::raw::c_int,
    pub path: VALUE,
}
impl ::std::clone::Clone for Struct_rb_trace_arg_struct {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_rb_trace_arg_struct {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type __va_list_tag = Struct___va_list_tag;
#[repr(C)]
#[derive(Copy)]
pub struct Struct___va_list_tag {
    pub gp_offset: ::std::os::raw::c_uint,
    pub fp_offset: ::std::os::raw::c_uint,
    pub overflow_arg_area: *mut ::std::os::raw::c_void,
    pub reg_save_area: *mut ::std::os::raw::c_void,
}
impl ::std::clone::Clone for Struct___va_list_tag {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct___va_list_tag {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
extern "C" {
    pub static mut _IO_2_1_stdin_: Struct__IO_FILE_plus;
    pub static mut _IO_2_1_stdout_: Struct__IO_FILE_plus;
    pub static mut _IO_2_1_stderr_: Struct__IO_FILE_plus;
    pub static mut stdin: *mut Struct__IO_FILE;
    pub static mut stdout: *mut Struct__IO_FILE;
    pub static mut stderr: *mut Struct__IO_FILE;
    pub static mut sys_nerr: ::std::os::raw::c_int;
    pub static mut sys_errlist: *const *const ::std::os::raw::c_char;
    pub static mut _sys_nerr: ::std::os::raw::c_int;
    pub static mut _sys_errlist: *const *const ::std::os::raw::c_char;
    pub static mut __environ: *mut *mut ::std::os::raw::c_char;
    pub static mut environ: *mut *mut ::std::os::raw::c_char;
    pub static mut optarg: *mut ::std::os::raw::c_char;
    pub static mut optind: ::std::os::raw::c_int;
    pub static mut opterr: ::std::os::raw::c_int;
    pub static mut optopt: ::std::os::raw::c_int;
    pub static mut signgam: ::std::os::raw::c_int;
    pub static mut _LIB_VERSION: _LIB_VERSION_TYPE;
    pub static mut rb_mKernel: VALUE;
    pub static mut rb_mComparable: VALUE;
    pub static mut rb_mEnumerable: VALUE;
    pub static mut rb_mErrno: VALUE;
    pub static mut rb_mFileTest: VALUE;
    pub static mut rb_mGC: VALUE;
    pub static mut rb_mMath: VALUE;
    pub static mut rb_mProcess: VALUE;
    pub static mut rb_mWaitReadable: VALUE;
    pub static mut rb_mWaitWritable: VALUE;
    pub static mut rb_cBasicObject: VALUE;
    pub static mut rb_cObject: VALUE;
    pub static mut rb_cArray: VALUE;
    pub static mut rb_cBignum: VALUE;
    pub static mut rb_cBinding: VALUE;
    pub static mut rb_cClass: VALUE;
    pub static mut rb_cCont: VALUE;
    pub static mut rb_cDir: VALUE;
    pub static mut rb_cData: VALUE;
    pub static mut rb_cFalseClass: VALUE;
    pub static mut rb_cEncoding: VALUE;
    pub static mut rb_cEnumerator: VALUE;
    pub static mut rb_cFile: VALUE;
    pub static mut rb_cFixnum: VALUE;
    pub static mut rb_cFloat: VALUE;
    pub static mut rb_cHash: VALUE;
    pub static mut rb_cInteger: VALUE;
    pub static mut rb_cIO: VALUE;
    pub static mut rb_cMatch: VALUE;
    pub static mut rb_cMethod: VALUE;
    pub static mut rb_cModule: VALUE;
    pub static mut rb_cNameErrorMesg: VALUE;
    pub static mut rb_cNilClass: VALUE;
    pub static mut rb_cNumeric: VALUE;
    pub static mut rb_cProc: VALUE;
    pub static mut rb_cRandom: VALUE;
    pub static mut rb_cRange: VALUE;
    pub static mut rb_cRational: VALUE;
    pub static mut rb_cComplex: VALUE;
    pub static mut rb_cRegexp: VALUE;
    pub static mut rb_cStat: VALUE;
    pub static mut rb_cString: VALUE;
    pub static mut rb_cStruct: VALUE;
    pub static mut rb_cSymbol: VALUE;
    pub static mut rb_cThread: VALUE;
    pub static mut rb_cTime: VALUE;
    pub static mut rb_cTrueClass: VALUE;
    pub static mut rb_cUnboundMethod: VALUE;
    pub static mut rb_eException: VALUE;
    pub static mut rb_eStandardError: VALUE;
    pub static mut rb_eSystemExit: VALUE;
    pub static mut rb_eInterrupt: VALUE;
    pub static mut rb_eSignal: VALUE;
    pub static mut rb_eFatal: VALUE;
    pub static mut rb_eArgError: VALUE;
    pub static mut rb_eEOFError: VALUE;
    pub static mut rb_eIndexError: VALUE;
    pub static mut rb_eStopIteration: VALUE;
    pub static mut rb_eKeyError: VALUE;
    pub static mut rb_eRangeError: VALUE;
    pub static mut rb_eIOError: VALUE;
    pub static mut rb_eRuntimeError: VALUE;
    pub static mut rb_eSecurityError: VALUE;
    pub static mut rb_eSystemCallError: VALUE;
    pub static mut rb_eThreadError: VALUE;
    pub static mut rb_eTypeError: VALUE;
    pub static mut rb_eZeroDivError: VALUE;
    pub static mut rb_eNotImpError: VALUE;
    pub static mut rb_eNoMemError: VALUE;
    pub static mut rb_eNoMethodError: VALUE;
    pub static mut rb_eFloatDomainError: VALUE;
    pub static mut rb_eLocalJumpError: VALUE;
    pub static mut rb_eSysStackError: VALUE;
    pub static mut rb_eRegexpError: VALUE;
    pub static mut rb_eEncodingError: VALUE;
    pub static mut rb_eEncCompatError: VALUE;
    pub static mut rb_eScriptError: VALUE;
    pub static mut rb_eNameError: VALUE;
    pub static mut rb_eSyntaxError: VALUE;
    pub static mut rb_eLoadError: VALUE;
    pub static mut rb_eMathDomainError: VALUE;
    pub static mut rb_stdin: VALUE;
    pub static mut rb_stdout: VALUE;
    pub static mut rb_stderr: VALUE;
    pub static mut rb_fs: VALUE;
    pub static mut rb_output_fs: VALUE;
    pub static mut rb_rs: VALUE;
    pub static mut rb_default_rs: VALUE;
    pub static mut rb_output_rs: VALUE;
    pub static mut ruby_sourceline: ::std::os::raw::c_int;
    pub static mut ruby_sourcefile: *mut ::std::os::raw::c_char;
    pub static mut rb_argv0: VALUE;
    pub static mut ruby_digit36_to_number_table:
               *const ::std::os::raw::c_char;
    pub static mut __tzname: [*mut ::std::os::raw::c_char; 2usize];
    pub static mut __daylight: ::std::os::raw::c_int;
    pub static mut __timezone: ::std::os::raw::c_long;
    pub static mut tzname: [*mut ::std::os::raw::c_char; 2usize];
    pub static mut daylight: ::std::os::raw::c_int;
    pub static mut timezone: ::std::os::raw::c_long;
    pub static mut getdate_err: ::std::os::raw::c_int;
    pub static mut _sys_siglist: [*const ::std::os::raw::c_char; 65usize];
    pub static mut sys_siglist: [*const ::std::os::raw::c_char; 65usize];
    pub static ruby_threadptr_data_type: rb_data_type_t;
    pub static mut rb_cISeq: VALUE;
    pub static mut rb_cRubyVM: VALUE;
    pub static mut rb_cEnv: VALUE;
    pub static mut rb_mRubyVMFrozenCore: VALUE;
    pub static ruby_binding_data_type: rb_data_type_t;
    pub static mut ruby_current_thread: *mut rb_thread_t;
    pub static mut ruby_current_vm: *mut rb_vm_t;
    pub static mut ruby_vm_event_flags: rb_event_flag_t;
}
extern "C" {
    pub fn _IO_cookie_init(__cfile: *mut Struct__IO_cookie_file,
                           __read_write: ::std::os::raw::c_int,
                           __cookie: *mut ::std::os::raw::c_void,
                           __fns: _IO_cookie_io_functions_t);
    pub fn __underflow(arg1: *mut _IO_FILE) -> ::std::os::raw::c_int;
    pub fn __uflow(arg1: *mut _IO_FILE) -> ::std::os::raw::c_int;
    pub fn __overflow(arg1: *mut _IO_FILE, arg2: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
    pub fn _IO_getc(__fp: *mut _IO_FILE) -> ::std::os::raw::c_int;
    pub fn _IO_putc(__c: ::std::os::raw::c_int, __fp: *mut _IO_FILE)
     -> ::std::os::raw::c_int;
    pub fn _IO_feof(__fp: *mut _IO_FILE) -> ::std::os::raw::c_int;
    pub fn _IO_ferror(__fp: *mut _IO_FILE) -> ::std::os::raw::c_int;
    pub fn _IO_peekc_locked(__fp: *mut _IO_FILE) -> ::std::os::raw::c_int;
    pub fn _IO_flockfile(arg1: *mut _IO_FILE);
    pub fn _IO_funlockfile(arg1: *mut _IO_FILE);
    pub fn _IO_ftrylockfile(arg1: *mut _IO_FILE) -> ::std::os::raw::c_int;
    pub fn _IO_vfscanf(arg1: *mut _IO_FILE,
                       arg2: *const ::std::os::raw::c_char,
                       arg3: __gnuc_va_list, arg4: *mut ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
    pub fn _IO_vfprintf(arg1: *mut _IO_FILE,
                        arg2: *const ::std::os::raw::c_char,
                        arg3: __gnuc_va_list) -> ::std::os::raw::c_int;
    pub fn _IO_padn(arg1: *mut _IO_FILE, arg2: ::std::os::raw::c_int,
                    arg3: __ssize_t) -> __ssize_t;
    pub fn _IO_sgetn(arg1: *mut _IO_FILE, arg2: *mut ::std::os::raw::c_void,
                     arg3: size_t) -> size_t;
    pub fn _IO_seekoff(arg1: *mut _IO_FILE, arg2: __off64_t,
                       arg3: ::std::os::raw::c_int,
                       arg4: ::std::os::raw::c_int) -> __off64_t;
    pub fn _IO_seekpos(arg1: *mut _IO_FILE, arg2: __off64_t,
                       arg3: ::std::os::raw::c_int) -> __off64_t;
    pub fn _IO_free_backup_area(arg1: *mut _IO_FILE);
    pub fn remove(__filename: *const ::std::os::raw::c_char)
     -> ::std::os::raw::c_int;
    pub fn rename(__old: *const ::std::os::raw::c_char,
                  __new: *const ::std::os::raw::c_char)
     -> ::std::os::raw::c_int;
    pub fn renameat(__oldfd: ::std::os::raw::c_int,
                    __old: *const ::std::os::raw::c_char,
                    __newfd: ::std::os::raw::c_int,
                    __new: *const ::std::os::raw::c_char)
     -> ::std::os::raw::c_int;
    pub fn tmpfile() -> *mut FILE;
    pub fn tmpfile64() -> *mut FILE;
    pub fn tmpnam(__s: *mut ::std::os::raw::c_char)
     -> *mut ::std::os::raw::c_char;
    pub fn tmpnam_r(__s: *mut ::std::os::raw::c_char)
     -> *mut ::std::os::raw::c_char;
    pub fn tempnam(__dir: *const ::std::os::raw::c_char,
                   __pfx: *const ::std::os::raw::c_char)
     -> *mut ::std::os::raw::c_char;
    pub fn fclose(__stream: *mut FILE) -> ::std::os::raw::c_int;
    pub fn fflush(__stream: *mut FILE) -> ::std::os::raw::c_int;
    pub fn fflush_unlocked(__stream: *mut FILE) -> ::std::os::raw::c_int;
    pub fn fcloseall() -> ::std::os::raw::c_int;
    pub fn fopen(__filename: *const ::std::os::raw::c_char,
                 __modes: *const ::std::os::raw::c_char) -> *mut FILE;
    pub fn freopen(__filename: *const ::std::os::raw::c_char,
                   __modes: *const ::std::os::raw::c_char,
                   __stream: *mut FILE) -> *mut FILE;
    pub fn fopen64(__filename: *const ::std::os::raw::c_char,
                   __modes: *const ::std::os::raw::c_char) -> *mut FILE;
    pub fn freopen64(__filename: *const ::std::os::raw::c_char,
                     __modes: *const ::std::os::raw::c_char,
                     __stream: *mut FILE) -> *mut FILE;
    pub fn fdopen(__fd: ::std::os::raw::c_int,
                  __modes: *const ::std::os::raw::c_char) -> *mut FILE;
    pub fn fopencookie(__magic_cookie: *mut ::std::os::raw::c_void,
                       __modes: *const ::std::os::raw::c_char,
                       __io_funcs: _IO_cookie_io_functions_t) -> *mut FILE;
    pub fn fmemopen(__s: *mut ::std::os::raw::c_void, __len: size_t,
                    __modes: *const ::std::os::raw::c_char) -> *mut FILE;
    pub fn open_memstream(__bufloc: *mut *mut ::std::os::raw::c_char,
                          __sizeloc: *mut size_t) -> *mut FILE;
    pub fn setbuf(__stream: *mut FILE, __buf: *mut ::std::os::raw::c_char);
    pub fn setvbuf(__stream: *mut FILE, __buf: *mut ::std::os::raw::c_char,
                   __modes: ::std::os::raw::c_int, __n: size_t)
     -> ::std::os::raw::c_int;
    pub fn setbuffer(__stream: *mut FILE, __buf: *mut ::std::os::raw::c_char,
                     __size: size_t);
    pub fn setlinebuf(__stream: *mut FILE);
    pub fn fprintf(__stream: *mut FILE,
                   __format: *const ::std::os::raw::c_char, ...)
     -> ::std::os::raw::c_int;
    pub fn printf(__format: *const ::std::os::raw::c_char, ...)
     -> ::std::os::raw::c_int;
    pub fn sprintf(__s: *mut ::std::os::raw::c_char,
                   __format: *const ::std::os::raw::c_char, ...)
     -> ::std::os::raw::c_int;
    pub fn vfprintf(__s: *mut FILE, __format: *const ::std::os::raw::c_char,
                    __arg: __gnuc_va_list) -> ::std::os::raw::c_int;
    pub fn vprintf(__format: *const ::std::os::raw::c_char,
                   __arg: __gnuc_va_list) -> ::std::os::raw::c_int;
    pub fn vsprintf(__s: *mut ::std::os::raw::c_char,
                    __format: *const ::std::os::raw::c_char,
                    __arg: __gnuc_va_list) -> ::std::os::raw::c_int;
    pub fn snprintf(__s: *mut ::std::os::raw::c_char, __maxlen: size_t,
                    __format: *const ::std::os::raw::c_char, ...)
     -> ::std::os::raw::c_int;
    pub fn vsnprintf(__s: *mut ::std::os::raw::c_char, __maxlen: size_t,
                     __format: *const ::std::os::raw::c_char,
                     __arg: __gnuc_va_list) -> ::std::os::raw::c_int;
    pub fn vasprintf(__ptr: *mut *mut ::std::os::raw::c_char,
                     __f: *const ::std::os::raw::c_char,
                     __arg: __gnuc_va_list) -> ::std::os::raw::c_int;
    pub fn __asprintf(__ptr: *mut *mut ::std::os::raw::c_char,
                      __fmt: *const ::std::os::raw::c_char, ...)
     -> ::std::os::raw::c_int;
    pub fn asprintf(__ptr: *mut *mut ::std::os::raw::c_char,
                    __fmt: *const ::std::os::raw::c_char, ...)
     -> ::std::os::raw::c_int;
    pub fn vdprintf(__fd: ::std::os::raw::c_int,
                    __fmt: *const ::std::os::raw::c_char,
                    __arg: __gnuc_va_list) -> ::std::os::raw::c_int;
    pub fn dprintf(__fd: ::std::os::raw::c_int,
                   __fmt: *const ::std::os::raw::c_char, ...)
     -> ::std::os::raw::c_int;
    pub fn fscanf(__stream: *mut FILE,
                  __format: *const ::std::os::raw::c_char, ...)
     -> ::std::os::raw::c_int;
    pub fn scanf(__format: *const ::std::os::raw::c_char, ...)
     -> ::std::os::raw::c_int;
    pub fn sscanf(__s: *const ::std::os::raw::c_char,
                  __format: *const ::std::os::raw::c_char, ...)
     -> ::std::os::raw::c_int;
    pub fn vfscanf(__s: *mut FILE, __format: *const ::std::os::raw::c_char,
                   __arg: __gnuc_va_list) -> ::std::os::raw::c_int;
    pub fn vscanf(__format: *const ::std::os::raw::c_char,
                  __arg: __gnuc_va_list) -> ::std::os::raw::c_int;
    pub fn vsscanf(__s: *const ::std::os::raw::c_char,
                   __format: *const ::std::os::raw::c_char,
                   __arg: __gnuc_va_list) -> ::std::os::raw::c_int;
    pub fn fgetc(__stream: *mut FILE) -> ::std::os::raw::c_int;
    pub fn getc(__stream: *mut FILE) -> ::std::os::raw::c_int;
    pub fn getchar() -> ::std::os::raw::c_int;
    pub fn getc_unlocked(__stream: *mut FILE) -> ::std::os::raw::c_int;
    pub fn getchar_unlocked() -> ::std::os::raw::c_int;
    pub fn fgetc_unlocked(__stream: *mut FILE) -> ::std::os::raw::c_int;
    pub fn fputc(__c: ::std::os::raw::c_int, __stream: *mut FILE)
     -> ::std::os::raw::c_int;
    pub fn putc(__c: ::std::os::raw::c_int, __stream: *mut FILE)
     -> ::std::os::raw::c_int;
    pub fn putchar(__c: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
    pub fn fputc_unlocked(__c: ::std::os::raw::c_int, __stream: *mut FILE)
     -> ::std::os::raw::c_int;
    pub fn putc_unlocked(__c: ::std::os::raw::c_int, __stream: *mut FILE)
     -> ::std::os::raw::c_int;
    pub fn putchar_unlocked(__c: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
    pub fn getw(__stream: *mut FILE) -> ::std::os::raw::c_int;
    pub fn putw(__w: ::std::os::raw::c_int, __stream: *mut FILE)
     -> ::std::os::raw::c_int;
    pub fn fgets(__s: *mut ::std::os::raw::c_char, __n: ::std::os::raw::c_int,
                 __stream: *mut FILE) -> *mut ::std::os::raw::c_char;
    pub fn gets(__s: *mut ::std::os::raw::c_char)
     -> *mut ::std::os::raw::c_char;
    pub fn fgets_unlocked(__s: *mut ::std::os::raw::c_char,
                          __n: ::std::os::raw::c_int, __stream: *mut FILE)
     -> *mut ::std::os::raw::c_char;
    pub fn __getdelim(__lineptr: *mut *mut ::std::os::raw::c_char,
                      __n: *mut size_t, __delimiter: ::std::os::raw::c_int,
                      __stream: *mut FILE) -> __ssize_t;
    pub fn getdelim(__lineptr: *mut *mut ::std::os::raw::c_char,
                    __n: *mut size_t, __delimiter: ::std::os::raw::c_int,
                    __stream: *mut FILE) -> __ssize_t;
    pub fn getline(__lineptr: *mut *mut ::std::os::raw::c_char,
                   __n: *mut size_t, __stream: *mut FILE) -> __ssize_t;
    pub fn fputs(__s: *const ::std::os::raw::c_char, __stream: *mut FILE)
     -> ::std::os::raw::c_int;
    pub fn puts(__s: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
    pub fn ungetc(__c: ::std::os::raw::c_int, __stream: *mut FILE)
     -> ::std::os::raw::c_int;
    pub fn fread(__ptr: *mut ::std::os::raw::c_void, __size: size_t,
                 __n: size_t, __stream: *mut FILE) -> size_t;
    pub fn fwrite(__ptr: *const ::std::os::raw::c_void, __size: size_t,
                  __n: size_t, __s: *mut FILE) -> size_t;
    pub fn fputs_unlocked(__s: *const ::std::os::raw::c_char,
                          __stream: *mut FILE) -> ::std::os::raw::c_int;
    pub fn fread_unlocked(__ptr: *mut ::std::os::raw::c_void, __size: size_t,
                          __n: size_t, __stream: *mut FILE) -> size_t;
    pub fn fwrite_unlocked(__ptr: *const ::std::os::raw::c_void,
                           __size: size_t, __n: size_t, __stream: *mut FILE)
     -> size_t;
    pub fn fseek(__stream: *mut FILE, __off: ::std::os::raw::c_long,
                 __whence: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
    pub fn ftell(__stream: *mut FILE) -> ::std::os::raw::c_long;
    pub fn rewind(__stream: *mut FILE);
    pub fn fseeko(__stream: *mut FILE, __off: __off_t,
                  __whence: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
    pub fn ftello(__stream: *mut FILE) -> __off_t;
    pub fn fgetpos(__stream: *mut FILE, __pos: *mut fpos_t)
     -> ::std::os::raw::c_int;
    pub fn fsetpos(__stream: *mut FILE, __pos: *const fpos_t)
     -> ::std::os::raw::c_int;
    pub fn fseeko64(__stream: *mut FILE, __off: __off64_t,
                    __whence: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
    pub fn ftello64(__stream: *mut FILE) -> __off64_t;
    pub fn fgetpos64(__stream: *mut FILE, __pos: *mut fpos64_t)
     -> ::std::os::raw::c_int;
    pub fn fsetpos64(__stream: *mut FILE, __pos: *const fpos64_t)
     -> ::std::os::raw::c_int;
    pub fn clearerr(__stream: *mut FILE);
    pub fn feof(__stream: *mut FILE) -> ::std::os::raw::c_int;
    pub fn ferror(__stream: *mut FILE) -> ::std::os::raw::c_int;
    pub fn clearerr_unlocked(__stream: *mut FILE);
    pub fn feof_unlocked(__stream: *mut FILE) -> ::std::os::raw::c_int;
    pub fn ferror_unlocked(__stream: *mut FILE) -> ::std::os::raw::c_int;
    pub fn perror(__s: *const ::std::os::raw::c_char);
    pub fn fileno(__stream: *mut FILE) -> ::std::os::raw::c_int;
    pub fn fileno_unlocked(__stream: *mut FILE) -> ::std::os::raw::c_int;
    pub fn popen(__command: *const ::std::os::raw::c_char,
                 __modes: *const ::std::os::raw::c_char) -> *mut FILE;
    pub fn pclose(__stream: *mut FILE) -> ::std::os::raw::c_int;
    pub fn ctermid(__s: *mut ::std::os::raw::c_char)
     -> *mut ::std::os::raw::c_char;
    pub fn cuserid(__s: *mut ::std::os::raw::c_char)
     -> *mut ::std::os::raw::c_char;
    pub fn obstack_printf(__obstack: *mut Struct_obstack,
                          __format: *const ::std::os::raw::c_char, ...)
     -> ::std::os::raw::c_int;
    pub fn obstack_vprintf(__obstack: *mut Struct_obstack,
                           __format: *const ::std::os::raw::c_char,
                           __args: __gnuc_va_list) -> ::std::os::raw::c_int;
    pub fn flockfile(__stream: *mut FILE);
    pub fn ftrylockfile(__stream: *mut FILE) -> ::std::os::raw::c_int;
    pub fn funlockfile(__stream: *mut FILE);
    pub fn select(__nfds: ::std::os::raw::c_int, __readfds: *mut fd_set,
                  __writefds: *mut fd_set, __exceptfds: *mut fd_set,
                  __timeout: *mut Struct_timeval) -> ::std::os::raw::c_int;
    pub fn pselect(__nfds: ::std::os::raw::c_int, __readfds: *mut fd_set,
                   __writefds: *mut fd_set, __exceptfds: *mut fd_set,
                   __timeout: *const Struct_timespec,
                   __sigmask: *const __sigset_t) -> ::std::os::raw::c_int;
    pub fn gnu_dev_major(__dev: ::std::os::raw::c_ulonglong)
     -> ::std::os::raw::c_uint;
    pub fn gnu_dev_minor(__dev: ::std::os::raw::c_ulonglong)
     -> ::std::os::raw::c_uint;
    pub fn gnu_dev_makedev(__major: ::std::os::raw::c_uint,
                           __minor: ::std::os::raw::c_uint)
     -> ::std::os::raw::c_ulonglong;
    pub fn stat(__file: *const ::std::os::raw::c_char,
                __buf: *mut Struct_stat) -> ::std::os::raw::c_int;
    pub fn fstat(__fd: ::std::os::raw::c_int, __buf: *mut Struct_stat)
     -> ::std::os::raw::c_int;
    pub fn stat64(__file: *const ::std::os::raw::c_char,
                  __buf: *mut Struct_stat64) -> ::std::os::raw::c_int;
    pub fn fstat64(__fd: ::std::os::raw::c_int, __buf: *mut Struct_stat64)
     -> ::std::os::raw::c_int;
    pub fn fstatat(__fd: ::std::os::raw::c_int,
                   __file: *const ::std::os::raw::c_char,
                   __buf: *mut Struct_stat, __flag: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
    pub fn fstatat64(__fd: ::std::os::raw::c_int,
                     __file: *const ::std::os::raw::c_char,
                     __buf: *mut Struct_stat64, __flag: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
    pub fn lstat(__file: *const ::std::os::raw::c_char,
                 __buf: *mut Struct_stat) -> ::std::os::raw::c_int;
    pub fn lstat64(__file: *const ::std::os::raw::c_char,
                   __buf: *mut Struct_stat64) -> ::std::os::raw::c_int;
    pub fn chmod(__file: *const ::std::os::raw::c_char, __mode: __mode_t)
     -> ::std::os::raw::c_int;
    pub fn lchmod(__file: *const ::std::os::raw::c_char, __mode: __mode_t)
     -> ::std::os::raw::c_int;
    pub fn fchmod(__fd: ::std::os::raw::c_int, __mode: __mode_t)
     -> ::std::os::raw::c_int;
    pub fn fchmodat(__fd: ::std::os::raw::c_int,
                    __file: *const ::std::os::raw::c_char, __mode: __mode_t,
                    __flag: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
    pub fn umask(__mask: __mode_t) -> __mode_t;
    pub fn getumask() -> __mode_t;
    pub fn mkdir(__path: *const ::std::os::raw::c_char, __mode: __mode_t)
     -> ::std::os::raw::c_int;
    pub fn mkdirat(__fd: ::std::os::raw::c_int,
                   __path: *const ::std::os::raw::c_char, __mode: __mode_t)
     -> ::std::os::raw::c_int;
    pub fn mknod(__path: *const ::std::os::raw::c_char, __mode: __mode_t,
                 __dev: __dev_t) -> ::std::os::raw::c_int;
    pub fn mknodat(__fd: ::std::os::raw::c_int,
                   __path: *const ::std::os::raw::c_char, __mode: __mode_t,
                   __dev: __dev_t) -> ::std::os::raw::c_int;
    pub fn mkfifo(__path: *const ::std::os::raw::c_char, __mode: __mode_t)
     -> ::std::os::raw::c_int;
    pub fn mkfifoat(__fd: ::std::os::raw::c_int,
                    __path: *const ::std::os::raw::c_char, __mode: __mode_t)
     -> ::std::os::raw::c_int;
    pub fn utimensat(__fd: ::std::os::raw::c_int,
                     __path: *const ::std::os::raw::c_char,
                     __times: *mut Struct_timespec,
                     __flags: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
    pub fn futimens(__fd: ::std::os::raw::c_int,
                    __times: *mut Struct_timespec) -> ::std::os::raw::c_int;
    pub fn __fxstat(__ver: ::std::os::raw::c_int,
                    __fildes: ::std::os::raw::c_int,
                    __stat_buf: *mut Struct_stat) -> ::std::os::raw::c_int;
    pub fn __xstat(__ver: ::std::os::raw::c_int,
                   __filename: *const ::std::os::raw::c_char,
                   __stat_buf: *mut Struct_stat) -> ::std::os::raw::c_int;
    pub fn __lxstat(__ver: ::std::os::raw::c_int,
                    __filename: *const ::std::os::raw::c_char,
                    __stat_buf: *mut Struct_stat) -> ::std::os::raw::c_int;
    pub fn __fxstatat(__ver: ::std::os::raw::c_int,
                      __fildes: ::std::os::raw::c_int,
                      __filename: *const ::std::os::raw::c_char,
                      __stat_buf: *mut Struct_stat,
                      __flag: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
    pub fn __fxstat64(__ver: ::std::os::raw::c_int,
                      __fildes: ::std::os::raw::c_int,
                      __stat_buf: *mut Struct_stat64)
     -> ::std::os::raw::c_int;
    pub fn __xstat64(__ver: ::std::os::raw::c_int,
                     __filename: *const ::std::os::raw::c_char,
                     __stat_buf: *mut Struct_stat64) -> ::std::os::raw::c_int;
    pub fn __lxstat64(__ver: ::std::os::raw::c_int,
                      __filename: *const ::std::os::raw::c_char,
                      __stat_buf: *mut Struct_stat64)
     -> ::std::os::raw::c_int;
    pub fn __fxstatat64(__ver: ::std::os::raw::c_int,
                        __fildes: ::std::os::raw::c_int,
                        __filename: *const ::std::os::raw::c_char,
                        __stat_buf: *mut Struct_stat64,
                        __flag: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
    pub fn __xmknod(__ver: ::std::os::raw::c_int,
                    __path: *const ::std::os::raw::c_char, __mode: __mode_t,
                    __dev: *mut __dev_t) -> ::std::os::raw::c_int;
    pub fn __xmknodat(__ver: ::std::os::raw::c_int,
                      __fd: ::std::os::raw::c_int,
                      __path: *const ::std::os::raw::c_char, __mode: __mode_t,
                      __dev: *mut __dev_t) -> ::std::os::raw::c_int;
    pub fn __ctype_get_mb_cur_max() -> size_t;
    pub fn atof(__nptr: *const ::std::os::raw::c_char)
     -> ::std::os::raw::c_double;
    pub fn atoi(__nptr: *const ::std::os::raw::c_char)
     -> ::std::os::raw::c_int;
    pub fn atol(__nptr: *const ::std::os::raw::c_char)
     -> ::std::os::raw::c_long;
    pub fn atoll(__nptr: *const ::std::os::raw::c_char)
     -> ::std::os::raw::c_longlong;
    pub fn strtod(__nptr: *const ::std::os::raw::c_char,
                  __endptr: *mut *mut ::std::os::raw::c_char)
     -> ::std::os::raw::c_double;
    pub fn strtof(__nptr: *const ::std::os::raw::c_char,
                  __endptr: *mut *mut ::std::os::raw::c_char)
     -> ::std::os::raw::c_float;
    pub fn strtold(__nptr: *const ::std::os::raw::c_char,
                   __endptr: *mut *mut ::std::os::raw::c_char)
     -> ::std::os::raw::c_double;
    pub fn strtol(__nptr: *const ::std::os::raw::c_char,
                  __endptr: *mut *mut ::std::os::raw::c_char,
                  __base: ::std::os::raw::c_int) -> ::std::os::raw::c_long;
    pub fn strtoul(__nptr: *const ::std::os::raw::c_char,
                   __endptr: *mut *mut ::std::os::raw::c_char,
                   __base: ::std::os::raw::c_int) -> ::std::os::raw::c_ulong;
    pub fn strtoq(__nptr: *const ::std::os::raw::c_char,
                  __endptr: *mut *mut ::std::os::raw::c_char,
                  __base: ::std::os::raw::c_int)
     -> ::std::os::raw::c_longlong;
    pub fn strtouq(__nptr: *const ::std::os::raw::c_char,
                   __endptr: *mut *mut ::std::os::raw::c_char,
                   __base: ::std::os::raw::c_int)
     -> ::std::os::raw::c_ulonglong;
    pub fn strtoll(__nptr: *const ::std::os::raw::c_char,
                   __endptr: *mut *mut ::std::os::raw::c_char,
                   __base: ::std::os::raw::c_int)
     -> ::std::os::raw::c_longlong;
    pub fn strtoull(__nptr: *const ::std::os::raw::c_char,
                    __endptr: *mut *mut ::std::os::raw::c_char,
                    __base: ::std::os::raw::c_int)
     -> ::std::os::raw::c_ulonglong;
    pub fn strtol_l(__nptr: *const ::std::os::raw::c_char,
                    __endptr: *mut *mut ::std::os::raw::c_char,
                    __base: ::std::os::raw::c_int, __loc: __locale_t)
     -> ::std::os::raw::c_long;
    pub fn strtoul_l(__nptr: *const ::std::os::raw::c_char,
                     __endptr: *mut *mut ::std::os::raw::c_char,
                     __base: ::std::os::raw::c_int, __loc: __locale_t)
     -> ::std::os::raw::c_ulong;
    pub fn strtoll_l(__nptr: *const ::std::os::raw::c_char,
                     __endptr: *mut *mut ::std::os::raw::c_char,
                     __base: ::std::os::raw::c_int, __loc: __locale_t)
     -> ::std::os::raw::c_longlong;
    pub fn strtoull_l(__nptr: *const ::std::os::raw::c_char,
                      __endptr: *mut *mut ::std::os::raw::c_char,
                      __base: ::std::os::raw::c_int, __loc: __locale_t)
     -> ::std::os::raw::c_ulonglong;
    pub fn strtod_l(__nptr: *const ::std::os::raw::c_char,
                    __endptr: *mut *mut ::std::os::raw::c_char,
                    __loc: __locale_t) -> ::std::os::raw::c_double;
    pub fn strtof_l(__nptr: *const ::std::os::raw::c_char,
                    __endptr: *mut *mut ::std::os::raw::c_char,
                    __loc: __locale_t) -> ::std::os::raw::c_float;
    pub fn strtold_l(__nptr: *const ::std::os::raw::c_char,
                     __endptr: *mut *mut ::std::os::raw::c_char,
                     __loc: __locale_t) -> ::std::os::raw::c_double;
    pub fn l64a(__n: ::std::os::raw::c_long) -> *mut ::std::os::raw::c_char;
    pub fn a64l(__s: *const ::std::os::raw::c_char) -> ::std::os::raw::c_long;
    pub fn random() -> ::std::os::raw::c_long;
    pub fn srandom(__seed: ::std::os::raw::c_uint);
    pub fn initstate(__seed: ::std::os::raw::c_uint,
                     __statebuf: *mut ::std::os::raw::c_char,
                     __statelen: size_t) -> *mut ::std::os::raw::c_char;
    pub fn setstate(__statebuf: *mut ::std::os::raw::c_char)
     -> *mut ::std::os::raw::c_char;
    pub fn random_r(__buf: *mut Struct_random_data, __result: *mut int32_t)
     -> ::std::os::raw::c_int;
    pub fn srandom_r(__seed: ::std::os::raw::c_uint,
                     __buf: *mut Struct_random_data) -> ::std::os::raw::c_int;
    pub fn initstate_r(__seed: ::std::os::raw::c_uint,
                       __statebuf: *mut ::std::os::raw::c_char,
                       __statelen: size_t, __buf: *mut Struct_random_data)
     -> ::std::os::raw::c_int;
    pub fn setstate_r(__statebuf: *mut ::std::os::raw::c_char,
                      __buf: *mut Struct_random_data)
     -> ::std::os::raw::c_int;
    pub fn rand() -> ::std::os::raw::c_int;
    pub fn srand(__seed: ::std::os::raw::c_uint);
    pub fn rand_r(__seed: *mut ::std::os::raw::c_uint)
     -> ::std::os::raw::c_int;
    pub fn drand48() -> ::std::os::raw::c_double;
    pub fn erand48(__xsubi: *mut ::std::os::raw::c_ushort)
     -> ::std::os::raw::c_double;
    pub fn lrand48() -> ::std::os::raw::c_long;
    pub fn nrand48(__xsubi: *mut ::std::os::raw::c_ushort)
     -> ::std::os::raw::c_long;
    pub fn mrand48() -> ::std::os::raw::c_long;
    pub fn jrand48(__xsubi: *mut ::std::os::raw::c_ushort)
     -> ::std::os::raw::c_long;
    pub fn srand48(__seedval: ::std::os::raw::c_long);
    pub fn seed48(__seed16v: *mut ::std::os::raw::c_ushort)
     -> *mut ::std::os::raw::c_ushort;
    pub fn lcong48(__param: *mut ::std::os::raw::c_ushort);
    pub fn drand48_r(__buffer: *mut Struct_drand48_data,
                     __result: *mut ::std::os::raw::c_double)
     -> ::std::os::raw::c_int;
    pub fn erand48_r(__xsubi: *mut ::std::os::raw::c_ushort,
                     __buffer: *mut Struct_drand48_data,
                     __result: *mut ::std::os::raw::c_double)
     -> ::std::os::raw::c_int;
    pub fn lrand48_r(__buffer: *mut Struct_drand48_data,
                     __result: *mut ::std::os::raw::c_long)
     -> ::std::os::raw::c_int;
    pub fn nrand48_r(__xsubi: *mut ::std::os::raw::c_ushort,
                     __buffer: *mut Struct_drand48_data,
                     __result: *mut ::std::os::raw::c_long)
     -> ::std::os::raw::c_int;
    pub fn mrand48_r(__buffer: *mut Struct_drand48_data,
                     __result: *mut ::std::os::raw::c_long)
     -> ::std::os::raw::c_int;
    pub fn jrand48_r(__xsubi: *mut ::std::os::raw::c_ushort,
                     __buffer: *mut Struct_drand48_data,
                     __result: *mut ::std::os::raw::c_long)
     -> ::std::os::raw::c_int;
    pub fn srand48_r(__seedval: ::std::os::raw::c_long,
                     __buffer: *mut Struct_drand48_data)
     -> ::std::os::raw::c_int;
    pub fn seed48_r(__seed16v: *mut ::std::os::raw::c_ushort,
                    __buffer: *mut Struct_drand48_data)
     -> ::std::os::raw::c_int;
    pub fn lcong48_r(__param: *mut ::std::os::raw::c_ushort,
                     __buffer: *mut Struct_drand48_data)
     -> ::std::os::raw::c_int;
    pub fn malloc(__size: size_t) -> *mut ::std::os::raw::c_void;
    pub fn calloc(__nmemb: size_t, __size: size_t)
     -> *mut ::std::os::raw::c_void;
    pub fn realloc(__ptr: *mut ::std::os::raw::c_void, __size: size_t)
     -> *mut ::std::os::raw::c_void;
    pub fn free(__ptr: *mut ::std::os::raw::c_void);
    pub fn cfree(__ptr: *mut ::std::os::raw::c_void);
    pub fn alloca(__size: size_t) -> *mut ::std::os::raw::c_void;
    pub fn valloc(__size: size_t) -> *mut ::std::os::raw::c_void;
    pub fn posix_memalign(__memptr: *mut *mut ::std::os::raw::c_void,
                          __alignment: size_t, __size: size_t)
     -> ::std::os::raw::c_int;
    pub fn abort();
    pub fn atexit(__func: ::std::option::Option<extern "C" fn()>)
     -> ::std::os::raw::c_int;
    pub fn at_quick_exit(__func: ::std::option::Option<extern "C" fn()>)
     -> ::std::os::raw::c_int;
    pub fn on_exit(__func:
                       ::std::option::Option<unsafe extern "C" fn(__status:
                                                                      ::std::os::raw::c_int,
                                                                  __arg:
                                                                      *mut ::std::os::raw::c_void)>,
                   __arg: *mut ::std::os::raw::c_void)
     -> ::std::os::raw::c_int;
    pub fn exit(__status: ::std::os::raw::c_int);
    pub fn quick_exit(__status: ::std::os::raw::c_int);
    pub fn _Exit(__status: ::std::os::raw::c_int);
    pub fn getenv(__name: *const ::std::os::raw::c_char)
     -> *mut ::std::os::raw::c_char;
    pub fn __secure_getenv(__name: *const ::std::os::raw::c_char)
     -> *mut ::std::os::raw::c_char;
    pub fn putenv(__string: *mut ::std::os::raw::c_char)
     -> ::std::os::raw::c_int;
    pub fn setenv(__name: *const ::std::os::raw::c_char,
                  __value: *const ::std::os::raw::c_char,
                  __replace: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
    pub fn unsetenv(__name: *const ::std::os::raw::c_char)
     -> ::std::os::raw::c_int;
    pub fn clearenv() -> ::std::os::raw::c_int;
    pub fn mktemp(__template: *mut ::std::os::raw::c_char)
     -> *mut ::std::os::raw::c_char;
    pub fn mkstemp(__template: *mut ::std::os::raw::c_char)
     -> ::std::os::raw::c_int;
    pub fn mkstemp64(__template: *mut ::std::os::raw::c_char)
     -> ::std::os::raw::c_int;
    pub fn mkstemps(__template: *mut ::std::os::raw::c_char,
                    __suffixlen: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
    pub fn mkstemps64(__template: *mut ::std::os::raw::c_char,
                      __suffixlen: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
    pub fn mkdtemp(__template: *mut ::std::os::raw::c_char)
     -> *mut ::std::os::raw::c_char;
    pub fn mkostemp(__template: *mut ::std::os::raw::c_char,
                    __flags: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
    pub fn mkostemp64(__template: *mut ::std::os::raw::c_char,
                      __flags: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
    pub fn mkostemps(__template: *mut ::std::os::raw::c_char,
                     __suffixlen: ::std::os::raw::c_int,
                     __flags: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
    pub fn mkostemps64(__template: *mut ::std::os::raw::c_char,
                       __suffixlen: ::std::os::raw::c_int,
                       __flags: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
    pub fn system(__command: *const ::std::os::raw::c_char)
     -> ::std::os::raw::c_int;
    pub fn canonicalize_file_name(__name: *const ::std::os::raw::c_char)
     -> *mut ::std::os::raw::c_char;
    pub fn realpath(__name: *const ::std::os::raw::c_char,
                    __resolved: *mut ::std::os::raw::c_char)
     -> *mut ::std::os::raw::c_char;
    pub fn bsearch(__key: *const ::std::os::raw::c_void,
                   __base: *const ::std::os::raw::c_void, __nmemb: size_t,
                   __size: size_t, __compar: __compar_fn_t)
     -> *mut ::std::os::raw::c_void;
    pub fn qsort(__base: *mut ::std::os::raw::c_void, __nmemb: size_t,
                 __size: size_t, __compar: __compar_fn_t);
    pub fn qsort_r(__base: *mut ::std::os::raw::c_void, __nmemb: size_t,
                   __size: size_t, __compar: __compar_d_fn_t,
                   __arg: *mut ::std::os::raw::c_void);
    pub fn abs(__x: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
    pub fn labs(__x: ::std::os::raw::c_long) -> ::std::os::raw::c_long;
    pub fn llabs(__x: ::std::os::raw::c_longlong)
     -> ::std::os::raw::c_longlong;
    pub fn div(__numer: ::std::os::raw::c_int, __denom: ::std::os::raw::c_int)
     -> div_t;
    pub fn ldiv(__numer: ::std::os::raw::c_long,
                __denom: ::std::os::raw::c_long) -> ldiv_t;
    pub fn lldiv(__numer: ::std::os::raw::c_longlong,
                 __denom: ::std::os::raw::c_longlong) -> lldiv_t;
    pub fn ecvt(__value: ::std::os::raw::c_double,
                __ndigit: ::std::os::raw::c_int,
                __decpt: *mut ::std::os::raw::c_int,
                __sign: *mut ::std::os::raw::c_int)
     -> *mut ::std::os::raw::c_char;
    pub fn fcvt(__value: ::std::os::raw::c_double,
                __ndigit: ::std::os::raw::c_int,
                __decpt: *mut ::std::os::raw::c_int,
                __sign: *mut ::std::os::raw::c_int)
     -> *mut ::std::os::raw::c_char;
    pub fn gcvt(__value: ::std::os::raw::c_double,
                __ndigit: ::std::os::raw::c_int,
                __buf: *mut ::std::os::raw::c_char)
     -> *mut ::std::os::raw::c_char;
    pub fn qecvt(__value: ::std::os::raw::c_double,
                 __ndigit: ::std::os::raw::c_int,
                 __decpt: *mut ::std::os::raw::c_int,
                 __sign: *mut ::std::os::raw::c_int)
     -> *mut ::std::os::raw::c_char;
    pub fn qfcvt(__value: ::std::os::raw::c_double,
                 __ndigit: ::std::os::raw::c_int,
                 __decpt: *mut ::std::os::raw::c_int,
                 __sign: *mut ::std::os::raw::c_int)
     -> *mut ::std::os::raw::c_char;
    pub fn qgcvt(__value: ::std::os::raw::c_double,
                 __ndigit: ::std::os::raw::c_int,
                 __buf: *mut ::std::os::raw::c_char)
     -> *mut ::std::os::raw::c_char;
    pub fn ecvt_r(__value: ::std::os::raw::c_double,
                  __ndigit: ::std::os::raw::c_int,
                  __decpt: *mut ::std::os::raw::c_int,
                  __sign: *mut ::std::os::raw::c_int,
                  __buf: *mut ::std::os::raw::c_char, __len: size_t)
     -> ::std::os::raw::c_int;
    pub fn fcvt_r(__value: ::std::os::raw::c_double,
                  __ndigit: ::std::os::raw::c_int,
                  __decpt: *mut ::std::os::raw::c_int,
                  __sign: *mut ::std::os::raw::c_int,
                  __buf: *mut ::std::os::raw::c_char, __len: size_t)
     -> ::std::os::raw::c_int;
    pub fn qecvt_r(__value: ::std::os::raw::c_double,
                   __ndigit: ::std::os::raw::c_int,
                   __decpt: *mut ::std::os::raw::c_int,
                   __sign: *mut ::std::os::raw::c_int,
                   __buf: *mut ::std::os::raw::c_char, __len: size_t)
     -> ::std::os::raw::c_int;
    pub fn qfcvt_r(__value: ::std::os::raw::c_double,
                   __ndigit: ::std::os::raw::c_int,
                   __decpt: *mut ::std::os::raw::c_int,
                   __sign: *mut ::std::os::raw::c_int,
                   __buf: *mut ::std::os::raw::c_char, __len: size_t)
     -> ::std::os::raw::c_int;
    pub fn mblen(__s: *const ::std::os::raw::c_char, __n: size_t)
     -> ::std::os::raw::c_int;
    pub fn mbtowc(__pwc: *mut wchar_t, __s: *const ::std::os::raw::c_char,
                  __n: size_t) -> ::std::os::raw::c_int;
    pub fn wctomb(__s: *mut ::std::os::raw::c_char, __wchar: wchar_t)
     -> ::std::os::raw::c_int;
    pub fn mbstowcs(__pwcs: *mut wchar_t, __s: *const ::std::os::raw::c_char,
                    __n: size_t) -> size_t;
    pub fn wcstombs(__s: *mut ::std::os::raw::c_char, __pwcs: *const wchar_t,
                    __n: size_t) -> size_t;
    pub fn rpmatch(__response: *const ::std::os::raw::c_char)
     -> ::std::os::raw::c_int;
    pub fn getsubopt(__optionp: *mut *mut ::std::os::raw::c_char,
                     __tokens: *const *mut ::std::os::raw::c_char,
                     __valuep: *mut *mut ::std::os::raw::c_char)
     -> ::std::os::raw::c_int;
    pub fn setkey(__key: *const ::std::os::raw::c_char);
    pub fn posix_openpt(__oflag: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
    pub fn grantpt(__fd: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
    pub fn unlockpt(__fd: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
    pub fn ptsname(__fd: ::std::os::raw::c_int)
     -> *mut ::std::os::raw::c_char;
    pub fn ptsname_r(__fd: ::std::os::raw::c_int,
                     __buf: *mut ::std::os::raw::c_char, __buflen: size_t)
     -> ::std::os::raw::c_int;
    pub fn getpt() -> ::std::os::raw::c_int;
    pub fn getloadavg(__loadavg: *mut ::std::os::raw::c_double,
                      __nelem: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
    pub fn memcpy(__dest: *mut ::std::os::raw::c_void,
                  __src: *const ::std::os::raw::c_void, __n: size_t)
     -> *mut ::std::os::raw::c_void;
    pub fn memmove(__dest: *mut ::std::os::raw::c_void,
                   __src: *const ::std::os::raw::c_void, __n: size_t)
     -> *mut ::std::os::raw::c_void;
    pub fn memccpy(__dest: *mut ::std::os::raw::c_void,
                   __src: *const ::std::os::raw::c_void,
                   __c: ::std::os::raw::c_int, __n: size_t)
     -> *mut ::std::os::raw::c_void;
    pub fn memset(__s: *mut ::std::os::raw::c_void,
                  __c: ::std::os::raw::c_int, __n: size_t)
     -> *mut ::std::os::raw::c_void;
    pub fn memcmp(__s1: *const ::std::os::raw::c_void,
                  __s2: *const ::std::os::raw::c_void, __n: size_t)
     -> ::std::os::raw::c_int;
    pub fn memchr(__s: *const ::std::os::raw::c_void,
                  __c: ::std::os::raw::c_int, __n: size_t)
     -> *mut ::std::os::raw::c_void;
    pub fn rawmemchr(__s: *const ::std::os::raw::c_void,
                     __c: ::std::os::raw::c_int)
     -> *mut ::std::os::raw::c_void;
    pub fn memrchr(__s: *const ::std::os::raw::c_void,
                   __c: ::std::os::raw::c_int, __n: size_t)
     -> *mut ::std::os::raw::c_void;
    pub fn strcpy(__dest: *mut ::std::os::raw::c_char,
                  __src: *const ::std::os::raw::c_char)
     -> *mut ::std::os::raw::c_char;
    pub fn strncpy(__dest: *mut ::std::os::raw::c_char,
                   __src: *const ::std::os::raw::c_char, __n: size_t)
     -> *mut ::std::os::raw::c_char;
    pub fn strcat(__dest: *mut ::std::os::raw::c_char,
                  __src: *const ::std::os::raw::c_char)
     -> *mut ::std::os::raw::c_char;
    pub fn strncat(__dest: *mut ::std::os::raw::c_char,
                   __src: *const ::std::os::raw::c_char, __n: size_t)
     -> *mut ::std::os::raw::c_char;
    pub fn strcmp(__s1: *const ::std::os::raw::c_char,
                  __s2: *const ::std::os::raw::c_char)
     -> ::std::os::raw::c_int;
    pub fn strncmp(__s1: *const ::std::os::raw::c_char,
                   __s2: *const ::std::os::raw::c_char, __n: size_t)
     -> ::std::os::raw::c_int;
    pub fn strcoll(__s1: *const ::std::os::raw::c_char,
                   __s2: *const ::std::os::raw::c_char)
     -> ::std::os::raw::c_int;
    pub fn strxfrm(__dest: *mut ::std::os::raw::c_char,
                   __src: *const ::std::os::raw::c_char, __n: size_t)
     -> size_t;
    pub fn strcoll_l(__s1: *const ::std::os::raw::c_char,
                     __s2: *const ::std::os::raw::c_char, __l: __locale_t)
     -> ::std::os::raw::c_int;
    pub fn strxfrm_l(__dest: *mut ::std::os::raw::c_char,
                     __src: *const ::std::os::raw::c_char, __n: size_t,
                     __l: __locale_t) -> size_t;
    pub fn strdup(__s: *const ::std::os::raw::c_char)
     -> *mut ::std::os::raw::c_char;
    pub fn strndup(__string: *const ::std::os::raw::c_char, __n: size_t)
     -> *mut ::std::os::raw::c_char;
    pub fn strchr(__s: *const ::std::os::raw::c_char,
                  __c: ::std::os::raw::c_int) -> *mut ::std::os::raw::c_char;
    pub fn strrchr(__s: *const ::std::os::raw::c_char,
                   __c: ::std::os::raw::c_int) -> *mut ::std::os::raw::c_char;
    pub fn strchrnul(__s: *const ::std::os::raw::c_char,
                     __c: ::std::os::raw::c_int)
     -> *mut ::std::os::raw::c_char;
    pub fn strcspn(__s: *const ::std::os::raw::c_char,
                   __reject: *const ::std::os::raw::c_char) -> size_t;
    pub fn strspn(__s: *const ::std::os::raw::c_char,
                  __accept: *const ::std::os::raw::c_char) -> size_t;
    pub fn strpbrk(__s: *const ::std::os::raw::c_char,
                   __accept: *const ::std::os::raw::c_char)
     -> *mut ::std::os::raw::c_char;
    pub fn strstr(__haystack: *const ::std::os::raw::c_char,
                  __needle: *const ::std::os::raw::c_char)
     -> *mut ::std::os::raw::c_char;
    pub fn strtok(__s: *mut ::std::os::raw::c_char,
                  __delim: *const ::std::os::raw::c_char)
     -> *mut ::std::os::raw::c_char;
    pub fn __strtok_r(__s: *mut ::std::os::raw::c_char,
                      __delim: *const ::std::os::raw::c_char,
                      __save_ptr: *mut *mut ::std::os::raw::c_char)
     -> *mut ::std::os::raw::c_char;
    pub fn strtok_r(__s: *mut ::std::os::raw::c_char,
                    __delim: *const ::std::os::raw::c_char,
                    __save_ptr: *mut *mut ::std::os::raw::c_char)
     -> *mut ::std::os::raw::c_char;
    pub fn strcasestr(__haystack: *const ::std::os::raw::c_char,
                      __needle: *const ::std::os::raw::c_char)
     -> *mut ::std::os::raw::c_char;
    pub fn memmem(__haystack: *const ::std::os::raw::c_void,
                  __haystacklen: size_t,
                  __needle: *const ::std::os::raw::c_void,
                  __needlelen: size_t) -> *mut ::std::os::raw::c_void;
    pub fn __mempcpy(__dest: *mut ::std::os::raw::c_void,
                     __src: *const ::std::os::raw::c_void, __n: size_t)
     -> *mut ::std::os::raw::c_void;
    pub fn mempcpy(__dest: *mut ::std::os::raw::c_void,
                   __src: *const ::std::os::raw::c_void, __n: size_t)
     -> *mut ::std::os::raw::c_void;
    pub fn strlen(__s: *const ::std::os::raw::c_char) -> size_t;
    pub fn strnlen(__string: *const ::std::os::raw::c_char, __maxlen: size_t)
     -> size_t;
    pub fn strerror(__errnum: ::std::os::raw::c_int)
     -> *mut ::std::os::raw::c_char;
    pub fn strerror_r(__errnum: ::std::os::raw::c_int,
                      __buf: *mut ::std::os::raw::c_char, __buflen: size_t)
     -> *mut ::std::os::raw::c_char;
    pub fn strerror_l(__errnum: ::std::os::raw::c_int, __l: __locale_t)
     -> *mut ::std::os::raw::c_char;
    pub fn __bzero(__s: *mut ::std::os::raw::c_void, __n: size_t);
    pub fn bcopy(__src: *const ::std::os::raw::c_void,
                 __dest: *mut ::std::os::raw::c_void, __n: size_t);
    pub fn bzero(__s: *mut ::std::os::raw::c_void, __n: size_t);
    pub fn bcmp(__s1: *const ::std::os::raw::c_void,
                __s2: *const ::std::os::raw::c_void, __n: size_t)
     -> ::std::os::raw::c_int;
    pub fn index(__s: *const ::std::os::raw::c_char,
                 __c: ::std::os::raw::c_int) -> *mut ::std::os::raw::c_char;
    pub fn rindex(__s: *const ::std::os::raw::c_char,
                  __c: ::std::os::raw::c_int) -> *mut ::std::os::raw::c_char;
    pub fn ffs(__i: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
    pub fn ffsl(__l: ::std::os::raw::c_long) -> ::std::os::raw::c_int;
    pub fn ffsll(__ll: ::std::os::raw::c_longlong) -> ::std::os::raw::c_int;
    pub fn strcasecmp(__s1: *const ::std::os::raw::c_char,
                      __s2: *const ::std::os::raw::c_char)
     -> ::std::os::raw::c_int;
    pub fn strncasecmp(__s1: *const ::std::os::raw::c_char,
                       __s2: *const ::std::os::raw::c_char, __n: size_t)
     -> ::std::os::raw::c_int;
    pub fn strcasecmp_l(__s1: *const ::std::os::raw::c_char,
                        __s2: *const ::std::os::raw::c_char,
                        __loc: __locale_t) -> ::std::os::raw::c_int;
    pub fn strncasecmp_l(__s1: *const ::std::os::raw::c_char,
                         __s2: *const ::std::os::raw::c_char, __n: size_t,
                         __loc: __locale_t) -> ::std::os::raw::c_int;
    pub fn strsep(__stringp: *mut *mut ::std::os::raw::c_char,
                  __delim: *const ::std::os::raw::c_char)
     -> *mut ::std::os::raw::c_char;
    pub fn strsignal(__sig: ::std::os::raw::c_int)
     -> *mut ::std::os::raw::c_char;
    pub fn __stpcpy(__dest: *mut ::std::os::raw::c_char,
                    __src: *const ::std::os::raw::c_char)
     -> *mut ::std::os::raw::c_char;
    pub fn stpcpy(__dest: *mut ::std::os::raw::c_char,
                  __src: *const ::std::os::raw::c_char)
     -> *mut ::std::os::raw::c_char;
    pub fn __stpncpy(__dest: *mut ::std::os::raw::c_char,
                     __src: *const ::std::os::raw::c_char, __n: size_t)
     -> *mut ::std::os::raw::c_char;
    pub fn stpncpy(__dest: *mut ::std::os::raw::c_char,
                   __src: *const ::std::os::raw::c_char, __n: size_t)
     -> *mut ::std::os::raw::c_char;
    pub fn strverscmp(__s1: *const ::std::os::raw::c_char,
                      __s2: *const ::std::os::raw::c_char)
     -> ::std::os::raw::c_int;
    pub fn strfry(__string: *mut ::std::os::raw::c_char)
     -> *mut ::std::os::raw::c_char;
    pub fn memfrob(__s: *mut ::std::os::raw::c_void, __n: size_t)
     -> *mut ::std::os::raw::c_void;
    pub fn basename(__filename: *const ::std::os::raw::c_char)
     -> *mut ::std::os::raw::c_char;
    pub fn imaxabs(__n: intmax_t) -> intmax_t;
    pub fn imaxdiv(__numer: intmax_t, __denom: intmax_t) -> imaxdiv_t;
    pub fn strtoimax(__nptr: *const ::std::os::raw::c_char,
                     __endptr: *mut *mut ::std::os::raw::c_char,
                     __base: ::std::os::raw::c_int) -> intmax_t;
    pub fn strtoumax(__nptr: *const ::std::os::raw::c_char,
                     __endptr: *mut *mut ::std::os::raw::c_char,
                     __base: ::std::os::raw::c_int) -> uintmax_t;
    pub fn wcstoimax(__nptr: *const __gwchar_t,
                     __endptr: *mut *mut __gwchar_t,
                     __base: ::std::os::raw::c_int) -> intmax_t;
    pub fn wcstoumax(__nptr: *const __gwchar_t,
                     __endptr: *mut *mut __gwchar_t,
                     __base: ::std::os::raw::c_int) -> uintmax_t;
    pub fn access(__name: *const ::std::os::raw::c_char,
                  __type: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
    pub fn euidaccess(__name: *const ::std::os::raw::c_char,
                      __type: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
    pub fn eaccess(__name: *const ::std::os::raw::c_char,
                   __type: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
    pub fn faccessat(__fd: ::std::os::raw::c_int,
                     __file: *const ::std::os::raw::c_char,
                     __type: ::std::os::raw::c_int,
                     __flag: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
    pub fn lseek(__fd: ::std::os::raw::c_int, __offset: __off_t,
                 __whence: ::std::os::raw::c_int) -> __off_t;
    pub fn lseek64(__fd: ::std::os::raw::c_int, __offset: __off64_t,
                   __whence: ::std::os::raw::c_int) -> __off64_t;
    pub fn close(__fd: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
    pub fn read(__fd: ::std::os::raw::c_int,
                __buf: *mut ::std::os::raw::c_void, __nbytes: size_t)
     -> ssize_t;
    pub fn write(__fd: ::std::os::raw::c_int,
                 __buf: *const ::std::os::raw::c_void, __n: size_t)
     -> ssize_t;
    pub fn pread(__fd: ::std::os::raw::c_int,
                 __buf: *mut ::std::os::raw::c_void, __nbytes: size_t,
                 __offset: __off_t) -> ssize_t;
    pub fn pwrite(__fd: ::std::os::raw::c_int,
                  __buf: *const ::std::os::raw::c_void, __n: size_t,
                  __offset: __off_t) -> ssize_t;
    pub fn pread64(__fd: ::std::os::raw::c_int,
                   __buf: *mut ::std::os::raw::c_void, __nbytes: size_t,
                   __offset: __off64_t) -> ssize_t;
    pub fn pwrite64(__fd: ::std::os::raw::c_int,
                    __buf: *const ::std::os::raw::c_void, __n: size_t,
                    __offset: __off64_t) -> ssize_t;
    pub fn pipe(__pipedes: *mut ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
    pub fn pipe2(__pipedes: *mut ::std::os::raw::c_int,
                 __flags: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
    pub fn alarm(__seconds: ::std::os::raw::c_uint) -> ::std::os::raw::c_uint;
    pub fn sleep(__seconds: ::std::os::raw::c_uint) -> ::std::os::raw::c_uint;
    pub fn ualarm(__value: __useconds_t, __interval: __useconds_t)
     -> __useconds_t;
    pub fn usleep(__useconds: __useconds_t) -> ::std::os::raw::c_int;
    pub fn pause() -> ::std::os::raw::c_int;
    pub fn chown(__file: *const ::std::os::raw::c_char, __owner: __uid_t,
                 __group: __gid_t) -> ::std::os::raw::c_int;
    pub fn fchown(__fd: ::std::os::raw::c_int, __owner: __uid_t,
                  __group: __gid_t) -> ::std::os::raw::c_int;
    pub fn lchown(__file: *const ::std::os::raw::c_char, __owner: __uid_t,
                  __group: __gid_t) -> ::std::os::raw::c_int;
    pub fn fchownat(__fd: ::std::os::raw::c_int,
                    __file: *const ::std::os::raw::c_char, __owner: __uid_t,
                    __group: __gid_t, __flag: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
    pub fn chdir(__path: *const ::std::os::raw::c_char)
     -> ::std::os::raw::c_int;
    pub fn fchdir(__fd: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
    pub fn getcwd(__buf: *mut ::std::os::raw::c_char, __size: size_t)
     -> *mut ::std::os::raw::c_char;
    pub fn get_current_dir_name() -> *mut ::std::os::raw::c_char;
    pub fn getwd(__buf: *mut ::std::os::raw::c_char)
     -> *mut ::std::os::raw::c_char;
    pub fn dup(__fd: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
    pub fn dup2(__fd: ::std::os::raw::c_int, __fd2: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
    pub fn dup3(__fd: ::std::os::raw::c_int, __fd2: ::std::os::raw::c_int,
                __flags: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
    pub fn execve(__path: *const ::std::os::raw::c_char,
                  __argv: *const *mut ::std::os::raw::c_char,
                  __envp: *const *mut ::std::os::raw::c_char)
     -> ::std::os::raw::c_int;
    pub fn fexecve(__fd: ::std::os::raw::c_int,
                   __argv: *const *mut ::std::os::raw::c_char,
                   __envp: *const *mut ::std::os::raw::c_char)
     -> ::std::os::raw::c_int;
    pub fn execv(__path: *const ::std::os::raw::c_char,
                 __argv: *const *mut ::std::os::raw::c_char)
     -> ::std::os::raw::c_int;
    pub fn execle(__path: *const ::std::os::raw::c_char,
                  __arg: *const ::std::os::raw::c_char, ...)
     -> ::std::os::raw::c_int;
    pub fn execl(__path: *const ::std::os::raw::c_char,
                 __arg: *const ::std::os::raw::c_char, ...)
     -> ::std::os::raw::c_int;
    pub fn execvp(__file: *const ::std::os::raw::c_char,
                  __argv: *const *mut ::std::os::raw::c_char)
     -> ::std::os::raw::c_int;
    pub fn execlp(__file: *const ::std::os::raw::c_char,
                  __arg: *const ::std::os::raw::c_char, ...)
     -> ::std::os::raw::c_int;
    pub fn execvpe(__file: *const ::std::os::raw::c_char,
                   __argv: *const *mut ::std::os::raw::c_char,
                   __envp: *const *mut ::std::os::raw::c_char)
     -> ::std::os::raw::c_int;
    pub fn nice(__inc: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
    pub fn _exit(__status: ::std::os::raw::c_int);
    pub fn pathconf(__path: *const ::std::os::raw::c_char,
                    __name: ::std::os::raw::c_int) -> ::std::os::raw::c_long;
    pub fn fpathconf(__fd: ::std::os::raw::c_int,
                     __name: ::std::os::raw::c_int) -> ::std::os::raw::c_long;
    pub fn sysconf(__name: ::std::os::raw::c_int) -> ::std::os::raw::c_long;
    pub fn confstr(__name: ::std::os::raw::c_int,
                   __buf: *mut ::std::os::raw::c_char, __len: size_t)
     -> size_t;
    pub fn getpid() -> __pid_t;
    pub fn getppid() -> __pid_t;
    pub fn getpgrp() -> __pid_t;
    pub fn __getpgid(__pid: __pid_t) -> __pid_t;
    pub fn getpgid(__pid: __pid_t) -> __pid_t;
    pub fn setpgid(__pid: __pid_t, __pgid: __pid_t) -> ::std::os::raw::c_int;
    pub fn setpgrp() -> ::std::os::raw::c_int;
    pub fn setsid() -> __pid_t;
    pub fn getsid(__pid: __pid_t) -> __pid_t;
    pub fn getuid() -> __uid_t;
    pub fn geteuid() -> __uid_t;
    pub fn getgid() -> __gid_t;
    pub fn getegid() -> __gid_t;
    pub fn getgroups(__size: ::std::os::raw::c_int, __list: *mut __gid_t)
     -> ::std::os::raw::c_int;
    pub fn group_member(__gid: __gid_t) -> ::std::os::raw::c_int;
    pub fn setuid(__uid: __uid_t) -> ::std::os::raw::c_int;
    pub fn setreuid(__ruid: __uid_t, __euid: __uid_t)
     -> ::std::os::raw::c_int;
    pub fn seteuid(__uid: __uid_t) -> ::std::os::raw::c_int;
    pub fn setgid(__gid: __gid_t) -> ::std::os::raw::c_int;
    pub fn setregid(__rgid: __gid_t, __egid: __gid_t)
     -> ::std::os::raw::c_int;
    pub fn setegid(__gid: __gid_t) -> ::std::os::raw::c_int;
    pub fn getresuid(__ruid: *mut __uid_t, __euid: *mut __uid_t,
                     __suid: *mut __uid_t) -> ::std::os::raw::c_int;
    pub fn getresgid(__rgid: *mut __gid_t, __egid: *mut __gid_t,
                     __sgid: *mut __gid_t) -> ::std::os::raw::c_int;
    pub fn setresuid(__ruid: __uid_t, __euid: __uid_t, __suid: __uid_t)
     -> ::std::os::raw::c_int;
    pub fn setresgid(__rgid: __gid_t, __egid: __gid_t, __sgid: __gid_t)
     -> ::std::os::raw::c_int;
    pub fn fork() -> __pid_t;
    pub fn vfork() -> __pid_t;
    pub fn ttyname(__fd: ::std::os::raw::c_int)
     -> *mut ::std::os::raw::c_char;
    pub fn ttyname_r(__fd: ::std::os::raw::c_int,
                     __buf: *mut ::std::os::raw::c_char, __buflen: size_t)
     -> ::std::os::raw::c_int;
    pub fn isatty(__fd: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
    pub fn ttyslot() -> ::std::os::raw::c_int;
    pub fn link(__from: *const ::std::os::raw::c_char,
                __to: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
    pub fn linkat(__fromfd: ::std::os::raw::c_int,
                  __from: *const ::std::os::raw::c_char,
                  __tofd: ::std::os::raw::c_int,
                  __to: *const ::std::os::raw::c_char,
                  __flags: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
    pub fn symlink(__from: *const ::std::os::raw::c_char,
                   __to: *const ::std::os::raw::c_char)
     -> ::std::os::raw::c_int;
    pub fn readlink(__path: *const ::std::os::raw::c_char,
                    __buf: *mut ::std::os::raw::c_char, __len: size_t)
     -> ssize_t;
    pub fn symlinkat(__from: *const ::std::os::raw::c_char,
                     __tofd: ::std::os::raw::c_int,
                     __to: *const ::std::os::raw::c_char)
     -> ::std::os::raw::c_int;
    pub fn readlinkat(__fd: ::std::os::raw::c_int,
                      __path: *const ::std::os::raw::c_char,
                      __buf: *mut ::std::os::raw::c_char, __len: size_t)
     -> ssize_t;
    pub fn unlink(__name: *const ::std::os::raw::c_char)
     -> ::std::os::raw::c_int;
    pub fn unlinkat(__fd: ::std::os::raw::c_int,
                    __name: *const ::std::os::raw::c_char,
                    __flag: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
    pub fn rmdir(__path: *const ::std::os::raw::c_char)
     -> ::std::os::raw::c_int;
    pub fn tcgetpgrp(__fd: ::std::os::raw::c_int) -> __pid_t;
    pub fn tcsetpgrp(__fd: ::std::os::raw::c_int, __pgrp_id: __pid_t)
     -> ::std::os::raw::c_int;
    pub fn getlogin() -> *mut ::std::os::raw::c_char;
    pub fn getlogin_r(__name: *mut ::std::os::raw::c_char, __name_len: size_t)
     -> ::std::os::raw::c_int;
    pub fn setlogin(__name: *const ::std::os::raw::c_char)
     -> ::std::os::raw::c_int;
    pub fn getopt(___argc: ::std::os::raw::c_int,
                  ___argv: *const *mut ::std::os::raw::c_char,
                  __shortopts: *const ::std::os::raw::c_char)
     -> ::std::os::raw::c_int;
    pub fn gethostname(__name: *mut ::std::os::raw::c_char, __len: size_t)
     -> ::std::os::raw::c_int;
    pub fn sethostname(__name: *const ::std::os::raw::c_char, __len: size_t)
     -> ::std::os::raw::c_int;
    pub fn sethostid(__id: ::std::os::raw::c_long) -> ::std::os::raw::c_int;
    pub fn getdomainname(__name: *mut ::std::os::raw::c_char, __len: size_t)
     -> ::std::os::raw::c_int;
    pub fn setdomainname(__name: *const ::std::os::raw::c_char, __len: size_t)
     -> ::std::os::raw::c_int;
    pub fn vhangup() -> ::std::os::raw::c_int;
    pub fn revoke(__file: *const ::std::os::raw::c_char)
     -> ::std::os::raw::c_int;
    pub fn profil(__sample_buffer: *mut ::std::os::raw::c_ushort,
                  __size: size_t, __offset: size_t,
                  __scale: ::std::os::raw::c_uint) -> ::std::os::raw::c_int;
    pub fn acct(__name: *const ::std::os::raw::c_char)
     -> ::std::os::raw::c_int;
    pub fn getusershell() -> *mut ::std::os::raw::c_char;
    pub fn endusershell();
    pub fn setusershell();
    pub fn daemon(__nochdir: ::std::os::raw::c_int,
                  __noclose: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
    pub fn chroot(__path: *const ::std::os::raw::c_char)
     -> ::std::os::raw::c_int;
    pub fn getpass(__prompt: *const ::std::os::raw::c_char)
     -> *mut ::std::os::raw::c_char;
    pub fn fsync(__fd: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
    pub fn syncfs(__fd: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
    pub fn gethostid() -> ::std::os::raw::c_long;
    pub fn sync();
    pub fn getpagesize() -> ::std::os::raw::c_int;
    pub fn getdtablesize() -> ::std::os::raw::c_int;
    pub fn truncate(__file: *const ::std::os::raw::c_char, __length: __off_t)
     -> ::std::os::raw::c_int;
    pub fn truncate64(__file: *const ::std::os::raw::c_char,
                      __length: __off64_t) -> ::std::os::raw::c_int;
    pub fn ftruncate(__fd: ::std::os::raw::c_int, __length: __off_t)
     -> ::std::os::raw::c_int;
    pub fn ftruncate64(__fd: ::std::os::raw::c_int, __length: __off64_t)
     -> ::std::os::raw::c_int;
    pub fn brk(__addr: *mut ::std::os::raw::c_void) -> ::std::os::raw::c_int;
    pub fn sbrk(__delta: intptr_t) -> *mut ::std::os::raw::c_void;
    pub fn syscall(__sysno: ::std::os::raw::c_long, ...)
     -> ::std::os::raw::c_long;
    pub fn lockf(__fd: ::std::os::raw::c_int, __cmd: ::std::os::raw::c_int,
                 __len: __off_t) -> ::std::os::raw::c_int;
    pub fn lockf64(__fd: ::std::os::raw::c_int, __cmd: ::std::os::raw::c_int,
                   __len: __off64_t) -> ::std::os::raw::c_int;
    pub fn fdatasync(__fildes: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
    pub fn crypt(__key: *const ::std::os::raw::c_char,
                 __salt: *const ::std::os::raw::c_char)
     -> *mut ::std::os::raw::c_char;
    pub fn encrypt(__libc_block: *mut ::std::os::raw::c_char,
                   __edflag: ::std::os::raw::c_int);
    pub fn swab(__from: *const ::std::os::raw::c_void,
                __to: *mut ::std::os::raw::c_void, __n: ssize_t);
    pub fn acos(__x: ::std::os::raw::c_double) -> ::std::os::raw::c_double;
    pub fn __acos(__x: ::std::os::raw::c_double) -> ::std::os::raw::c_double;
    pub fn asin(__x: ::std::os::raw::c_double) -> ::std::os::raw::c_double;
    pub fn __asin(__x: ::std::os::raw::c_double) -> ::std::os::raw::c_double;
    pub fn atan(__x: ::std::os::raw::c_double) -> ::std::os::raw::c_double;
    pub fn __atan(__x: ::std::os::raw::c_double) -> ::std::os::raw::c_double;
    pub fn atan2(__y: ::std::os::raw::c_double, __x: ::std::os::raw::c_double)
     -> ::std::os::raw::c_double;
    pub fn __atan2(__y: ::std::os::raw::c_double,
                   __x: ::std::os::raw::c_double) -> ::std::os::raw::c_double;
    pub fn cos(__x: ::std::os::raw::c_double) -> ::std::os::raw::c_double;
    pub fn __cos(__x: ::std::os::raw::c_double) -> ::std::os::raw::c_double;
    pub fn sin(__x: ::std::os::raw::c_double) -> ::std::os::raw::c_double;
    pub fn __sin(__x: ::std::os::raw::c_double) -> ::std::os::raw::c_double;
    pub fn tan(__x: ::std::os::raw::c_double) -> ::std::os::raw::c_double;
    pub fn __tan(__x: ::std::os::raw::c_double) -> ::std::os::raw::c_double;
    pub fn cosh(__x: ::std::os::raw::c_double) -> ::std::os::raw::c_double;
    pub fn __cosh(__x: ::std::os::raw::c_double) -> ::std::os::raw::c_double;
    pub fn sinh(__x: ::std::os::raw::c_double) -> ::std::os::raw::c_double;
    pub fn __sinh(__x: ::std::os::raw::c_double) -> ::std::os::raw::c_double;
    pub fn tanh(__x: ::std::os::raw::c_double) -> ::std::os::raw::c_double;
    pub fn __tanh(__x: ::std::os::raw::c_double) -> ::std::os::raw::c_double;
    pub fn sincos(__x: ::std::os::raw::c_double,
                  __sinx: *mut ::std::os::raw::c_double,
                  __cosx: *mut ::std::os::raw::c_double);
    pub fn __sincos(__x: ::std::os::raw::c_double,
                    __sinx: *mut ::std::os::raw::c_double,
                    __cosx: *mut ::std::os::raw::c_double);
    pub fn acosh(__x: ::std::os::raw::c_double) -> ::std::os::raw::c_double;
    pub fn __acosh(__x: ::std::os::raw::c_double) -> ::std::os::raw::c_double;
    pub fn asinh(__x: ::std::os::raw::c_double) -> ::std::os::raw::c_double;
    pub fn __asinh(__x: ::std::os::raw::c_double) -> ::std::os::raw::c_double;
    pub fn atanh(__x: ::std::os::raw::c_double) -> ::std::os::raw::c_double;
    pub fn __atanh(__x: ::std::os::raw::c_double) -> ::std::os::raw::c_double;
    pub fn exp(__x: ::std::os::raw::c_double) -> ::std::os::raw::c_double;
    pub fn __exp(__x: ::std::os::raw::c_double) -> ::std::os::raw::c_double;
    pub fn frexp(__x: ::std::os::raw::c_double,
                 __exponent: *mut ::std::os::raw::c_int)
     -> ::std::os::raw::c_double;
    pub fn __frexp(__x: ::std::os::raw::c_double,
                   __exponent: *mut ::std::os::raw::c_int)
     -> ::std::os::raw::c_double;
    pub fn ldexp(__x: ::std::os::raw::c_double,
                 __exponent: ::std::os::raw::c_int)
     -> ::std::os::raw::c_double;
    pub fn __ldexp(__x: ::std::os::raw::c_double,
                   __exponent: ::std::os::raw::c_int)
     -> ::std::os::raw::c_double;
    pub fn log(__x: ::std::os::raw::c_double) -> ::std::os::raw::c_double;
    pub fn __log(__x: ::std::os::raw::c_double) -> ::std::os::raw::c_double;
    pub fn log10(__x: ::std::os::raw::c_double) -> ::std::os::raw::c_double;
    pub fn __log10(__x: ::std::os::raw::c_double) -> ::std::os::raw::c_double;
    pub fn modf(__x: ::std::os::raw::c_double,
                __iptr: *mut ::std::os::raw::c_double)
     -> ::std::os::raw::c_double;
    pub fn __modf(__x: ::std::os::raw::c_double,
                  __iptr: *mut ::std::os::raw::c_double)
     -> ::std::os::raw::c_double;
    pub fn exp10(__x: ::std::os::raw::c_double) -> ::std::os::raw::c_double;
    pub fn __exp10(__x: ::std::os::raw::c_double) -> ::std::os::raw::c_double;
    pub fn pow10(__x: ::std::os::raw::c_double) -> ::std::os::raw::c_double;
    pub fn __pow10(__x: ::std::os::raw::c_double) -> ::std::os::raw::c_double;
    pub fn expm1(__x: ::std::os::raw::c_double) -> ::std::os::raw::c_double;
    pub fn __expm1(__x: ::std::os::raw::c_double) -> ::std::os::raw::c_double;
    pub fn log1p(__x: ::std::os::raw::c_double) -> ::std::os::raw::c_double;
    pub fn __log1p(__x: ::std::os::raw::c_double) -> ::std::os::raw::c_double;
    pub fn logb(__x: ::std::os::raw::c_double) -> ::std::os::raw::c_double;
    pub fn __logb(__x: ::std::os::raw::c_double) -> ::std::os::raw::c_double;
    pub fn exp2(__x: ::std::os::raw::c_double) -> ::std::os::raw::c_double;
    pub fn __exp2(__x: ::std::os::raw::c_double) -> ::std::os::raw::c_double;
    pub fn log2(__x: ::std::os::raw::c_double) -> ::std::os::raw::c_double;
    pub fn __log2(__x: ::std::os::raw::c_double) -> ::std::os::raw::c_double;
    pub fn pow(__x: ::std::os::raw::c_double, __y: ::std::os::raw::c_double)
     -> ::std::os::raw::c_double;
    pub fn __pow(__x: ::std::os::raw::c_double, __y: ::std::os::raw::c_double)
     -> ::std::os::raw::c_double;
    pub fn sqrt(__x: ::std::os::raw::c_double) -> ::std::os::raw::c_double;
    pub fn __sqrt(__x: ::std::os::raw::c_double) -> ::std::os::raw::c_double;
    pub fn hypot(__x: ::std::os::raw::c_double, __y: ::std::os::raw::c_double)
     -> ::std::os::raw::c_double;
    pub fn __hypot(__x: ::std::os::raw::c_double,
                   __y: ::std::os::raw::c_double) -> ::std::os::raw::c_double;
    pub fn cbrt(__x: ::std::os::raw::c_double) -> ::std::os::raw::c_double;
    pub fn __cbrt(__x: ::std::os::raw::c_double) -> ::std::os::raw::c_double;
    pub fn ceil(__x: ::std::os::raw::c_double) -> ::std::os::raw::c_double;
    pub fn __ceil(__x: ::std::os::raw::c_double) -> ::std::os::raw::c_double;
    pub fn fabs(__x: ::std::os::raw::c_double) -> ::std::os::raw::c_double;
    pub fn __fabs(__x: ::std::os::raw::c_double) -> ::std::os::raw::c_double;
    pub fn floor(__x: ::std::os::raw::c_double) -> ::std::os::raw::c_double;
    pub fn __floor(__x: ::std::os::raw::c_double) -> ::std::os::raw::c_double;
    pub fn fmod(__x: ::std::os::raw::c_double, __y: ::std::os::raw::c_double)
     -> ::std::os::raw::c_double;
    pub fn __fmod(__x: ::std::os::raw::c_double,
                  __y: ::std::os::raw::c_double) -> ::std::os::raw::c_double;
    pub fn __isinf(__value: ::std::os::raw::c_double)
     -> ::std::os::raw::c_int;
    pub fn __finite(__value: ::std::os::raw::c_double)
     -> ::std::os::raw::c_int;
    pub fn isinf(__value: ::std::os::raw::c_double) -> ::std::os::raw::c_int;
    pub fn finite(__value: ::std::os::raw::c_double) -> ::std::os::raw::c_int;
    pub fn drem(__x: ::std::os::raw::c_double, __y: ::std::os::raw::c_double)
     -> ::std::os::raw::c_double;
    pub fn __drem(__x: ::std::os::raw::c_double,
                  __y: ::std::os::raw::c_double) -> ::std::os::raw::c_double;
    pub fn significand(__x: ::std::os::raw::c_double)
     -> ::std::os::raw::c_double;
    pub fn __significand(__x: ::std::os::raw::c_double)
     -> ::std::os::raw::c_double;
    pub fn copysign(__x: ::std::os::raw::c_double,
                    __y: ::std::os::raw::c_double)
     -> ::std::os::raw::c_double;
    pub fn __copysign(__x: ::std::os::raw::c_double,
                      __y: ::std::os::raw::c_double)
     -> ::std::os::raw::c_double;
    pub fn nan(__tagb: *const ::std::os::raw::c_char)
     -> ::std::os::raw::c_double;
    pub fn __nan(__tagb: *const ::std::os::raw::c_char)
     -> ::std::os::raw::c_double;
    pub fn __isnan(__value: ::std::os::raw::c_double)
     -> ::std::os::raw::c_int;
    pub fn isnan(__value: ::std::os::raw::c_double) -> ::std::os::raw::c_int;
    pub fn j0(arg1: ::std::os::raw::c_double) -> ::std::os::raw::c_double;
    pub fn __j0(arg1: ::std::os::raw::c_double) -> ::std::os::raw::c_double;
    pub fn j1(arg1: ::std::os::raw::c_double) -> ::std::os::raw::c_double;
    pub fn __j1(arg1: ::std::os::raw::c_double) -> ::std::os::raw::c_double;
    pub fn jn(arg1: ::std::os::raw::c_int, arg2: ::std::os::raw::c_double)
     -> ::std::os::raw::c_double;
    pub fn __jn(arg1: ::std::os::raw::c_int, arg2: ::std::os::raw::c_double)
     -> ::std::os::raw::c_double;
    pub fn y0(arg1: ::std::os::raw::c_double) -> ::std::os::raw::c_double;
    pub fn __y0(arg1: ::std::os::raw::c_double) -> ::std::os::raw::c_double;
    pub fn y1(arg1: ::std::os::raw::c_double) -> ::std::os::raw::c_double;
    pub fn __y1(arg1: ::std::os::raw::c_double) -> ::std::os::raw::c_double;
    pub fn yn(arg1: ::std::os::raw::c_int, arg2: ::std::os::raw::c_double)
     -> ::std::os::raw::c_double;
    pub fn __yn(arg1: ::std::os::raw::c_int, arg2: ::std::os::raw::c_double)
     -> ::std::os::raw::c_double;
    pub fn erf(arg1: ::std::os::raw::c_double) -> ::std::os::raw::c_double;
    pub fn __erf(arg1: ::std::os::raw::c_double) -> ::std::os::raw::c_double;
    pub fn erfc(arg1: ::std::os::raw::c_double) -> ::std::os::raw::c_double;
    pub fn __erfc(arg1: ::std::os::raw::c_double) -> ::std::os::raw::c_double;
    pub fn lgamma(arg1: ::std::os::raw::c_double) -> ::std::os::raw::c_double;
    pub fn __lgamma(arg1: ::std::os::raw::c_double)
     -> ::std::os::raw::c_double;
    pub fn tgamma(arg1: ::std::os::raw::c_double) -> ::std::os::raw::c_double;
    pub fn __tgamma(arg1: ::std::os::raw::c_double)
     -> ::std::os::raw::c_double;
    pub fn gamma(arg1: ::std::os::raw::c_double) -> ::std::os::raw::c_double;
    pub fn __gamma(arg1: ::std::os::raw::c_double)
     -> ::std::os::raw::c_double;
    pub fn lgamma_r(arg1: ::std::os::raw::c_double,
                    __signgamp: *mut ::std::os::raw::c_int)
     -> ::std::os::raw::c_double;
    pub fn __lgamma_r(arg1: ::std::os::raw::c_double,
                      __signgamp: *mut ::std::os::raw::c_int)
     -> ::std::os::raw::c_double;
    pub fn rint(__x: ::std::os::raw::c_double) -> ::std::os::raw::c_double;
    pub fn __rint(__x: ::std::os::raw::c_double) -> ::std::os::raw::c_double;
    pub fn nextafter(__x: ::std::os::raw::c_double,
                     __y: ::std::os::raw::c_double)
     -> ::std::os::raw::c_double;
    pub fn __nextafter(__x: ::std::os::raw::c_double,
                       __y: ::std::os::raw::c_double)
     -> ::std::os::raw::c_double;
    pub fn nexttoward(__x: ::std::os::raw::c_double,
                      __y: ::std::os::raw::c_double)
     -> ::std::os::raw::c_double;
    pub fn __nexttoward(__x: ::std::os::raw::c_double,
                        __y: ::std::os::raw::c_double)
     -> ::std::os::raw::c_double;
    pub fn remainder(__x: ::std::os::raw::c_double,
                     __y: ::std::os::raw::c_double)
     -> ::std::os::raw::c_double;
    pub fn __remainder(__x: ::std::os::raw::c_double,
                       __y: ::std::os::raw::c_double)
     -> ::std::os::raw::c_double;
    pub fn scalbn(__x: ::std::os::raw::c_double, __n: ::std::os::raw::c_int)
     -> ::std::os::raw::c_double;
    pub fn __scalbn(__x: ::std::os::raw::c_double, __n: ::std::os::raw::c_int)
     -> ::std::os::raw::c_double;
    pub fn ilogb(__x: ::std::os::raw::c_double) -> ::std::os::raw::c_int;
    pub fn __ilogb(__x: ::std::os::raw::c_double) -> ::std::os::raw::c_int;
    pub fn scalbln(__x: ::std::os::raw::c_double, __n: ::std::os::raw::c_long)
     -> ::std::os::raw::c_double;
    pub fn __scalbln(__x: ::std::os::raw::c_double,
                     __n: ::std::os::raw::c_long) -> ::std::os::raw::c_double;
    pub fn nearbyint(__x: ::std::os::raw::c_double)
     -> ::std::os::raw::c_double;
    pub fn __nearbyint(__x: ::std::os::raw::c_double)
     -> ::std::os::raw::c_double;
    pub fn round(__x: ::std::os::raw::c_double) -> ::std::os::raw::c_double;
    pub fn __round(__x: ::std::os::raw::c_double) -> ::std::os::raw::c_double;
    pub fn trunc(__x: ::std::os::raw::c_double) -> ::std::os::raw::c_double;
    pub fn __trunc(__x: ::std::os::raw::c_double) -> ::std::os::raw::c_double;
    pub fn remquo(__x: ::std::os::raw::c_double,
                  __y: ::std::os::raw::c_double,
                  __quo: *mut ::std::os::raw::c_int)
     -> ::std::os::raw::c_double;
    pub fn __remquo(__x: ::std::os::raw::c_double,
                    __y: ::std::os::raw::c_double,
                    __quo: *mut ::std::os::raw::c_int)
     -> ::std::os::raw::c_double;
    pub fn lrint(__x: ::std::os::raw::c_double) -> ::std::os::raw::c_long;
    pub fn __lrint(__x: ::std::os::raw::c_double) -> ::std::os::raw::c_long;
    pub fn llrint(__x: ::std::os::raw::c_double)
     -> ::std::os::raw::c_longlong;
    pub fn __llrint(__x: ::std::os::raw::c_double)
     -> ::std::os::raw::c_longlong;
    pub fn lround(__x: ::std::os::raw::c_double) -> ::std::os::raw::c_long;
    pub fn __lround(__x: ::std::os::raw::c_double) -> ::std::os::raw::c_long;
    pub fn llround(__x: ::std::os::raw::c_double)
     -> ::std::os::raw::c_longlong;
    pub fn __llround(__x: ::std::os::raw::c_double)
     -> ::std::os::raw::c_longlong;
    pub fn fdim(__x: ::std::os::raw::c_double, __y: ::std::os::raw::c_double)
     -> ::std::os::raw::c_double;
    pub fn __fdim(__x: ::std::os::raw::c_double,
                  __y: ::std::os::raw::c_double) -> ::std::os::raw::c_double;
    pub fn fmax(__x: ::std::os::raw::c_double, __y: ::std::os::raw::c_double)
     -> ::std::os::raw::c_double;
    pub fn __fmax(__x: ::std::os::raw::c_double,
                  __y: ::std::os::raw::c_double) -> ::std::os::raw::c_double;
    pub fn fmin(__x: ::std::os::raw::c_double, __y: ::std::os::raw::c_double)
     -> ::std::os::raw::c_double;
    pub fn __fmin(__x: ::std::os::raw::c_double,
                  __y: ::std::os::raw::c_double) -> ::std::os::raw::c_double;
    pub fn __fpclassify(__value: ::std::os::raw::c_double)
     -> ::std::os::raw::c_int;
    pub fn __signbit(__value: ::std::os::raw::c_double)
     -> ::std::os::raw::c_int;
    pub fn fma(__x: ::std::os::raw::c_double, __y: ::std::os::raw::c_double,
               __z: ::std::os::raw::c_double) -> ::std::os::raw::c_double;
    pub fn __fma(__x: ::std::os::raw::c_double, __y: ::std::os::raw::c_double,
                 __z: ::std::os::raw::c_double) -> ::std::os::raw::c_double;
    pub fn scalb(__x: ::std::os::raw::c_double, __n: ::std::os::raw::c_double)
     -> ::std::os::raw::c_double;
    pub fn __scalb(__x: ::std::os::raw::c_double,
                   __n: ::std::os::raw::c_double) -> ::std::os::raw::c_double;
    pub fn acosf(__x: ::std::os::raw::c_float) -> ::std::os::raw::c_float;
    pub fn __acosf(__x: ::std::os::raw::c_float) -> ::std::os::raw::c_float;
    pub fn asinf(__x: ::std::os::raw::c_float) -> ::std::os::raw::c_float;
    pub fn __asinf(__x: ::std::os::raw::c_float) -> ::std::os::raw::c_float;
    pub fn atanf(__x: ::std::os::raw::c_float) -> ::std::os::raw::c_float;
    pub fn __atanf(__x: ::std::os::raw::c_float) -> ::std::os::raw::c_float;
    pub fn atan2f(__y: ::std::os::raw::c_float, __x: ::std::os::raw::c_float)
     -> ::std::os::raw::c_float;
    pub fn __atan2f(__y: ::std::os::raw::c_float,
                    __x: ::std::os::raw::c_float) -> ::std::os::raw::c_float;
    pub fn cosf(__x: ::std::os::raw::c_float) -> ::std::os::raw::c_float;
    pub fn __cosf(__x: ::std::os::raw::c_float) -> ::std::os::raw::c_float;
    pub fn sinf(__x: ::std::os::raw::c_float) -> ::std::os::raw::c_float;
    pub fn __sinf(__x: ::std::os::raw::c_float) -> ::std::os::raw::c_float;
    pub fn tanf(__x: ::std::os::raw::c_float) -> ::std::os::raw::c_float;
    pub fn __tanf(__x: ::std::os::raw::c_float) -> ::std::os::raw::c_float;
    pub fn coshf(__x: ::std::os::raw::c_float) -> ::std::os::raw::c_float;
    pub fn __coshf(__x: ::std::os::raw::c_float) -> ::std::os::raw::c_float;
    pub fn sinhf(__x: ::std::os::raw::c_float) -> ::std::os::raw::c_float;
    pub fn __sinhf(__x: ::std::os::raw::c_float) -> ::std::os::raw::c_float;
    pub fn tanhf(__x: ::std::os::raw::c_float) -> ::std::os::raw::c_float;
    pub fn __tanhf(__x: ::std::os::raw::c_float) -> ::std::os::raw::c_float;
    pub fn sincosf(__x: ::std::os::raw::c_float,
                   __sinx: *mut ::std::os::raw::c_float,
                   __cosx: *mut ::std::os::raw::c_float);
    pub fn __sincosf(__x: ::std::os::raw::c_float,
                     __sinx: *mut ::std::os::raw::c_float,
                     __cosx: *mut ::std::os::raw::c_float);
    pub fn acoshf(__x: ::std::os::raw::c_float) -> ::std::os::raw::c_float;
    pub fn __acoshf(__x: ::std::os::raw::c_float) -> ::std::os::raw::c_float;
    pub fn asinhf(__x: ::std::os::raw::c_float) -> ::std::os::raw::c_float;
    pub fn __asinhf(__x: ::std::os::raw::c_float) -> ::std::os::raw::c_float;
    pub fn atanhf(__x: ::std::os::raw::c_float) -> ::std::os::raw::c_float;
    pub fn __atanhf(__x: ::std::os::raw::c_float) -> ::std::os::raw::c_float;
    pub fn expf(__x: ::std::os::raw::c_float) -> ::std::os::raw::c_float;
    pub fn __expf(__x: ::std::os::raw::c_float) -> ::std::os::raw::c_float;
    pub fn frexpf(__x: ::std::os::raw::c_float,
                  __exponent: *mut ::std::os::raw::c_int)
     -> ::std::os::raw::c_float;
    pub fn __frexpf(__x: ::std::os::raw::c_float,
                    __exponent: *mut ::std::os::raw::c_int)
     -> ::std::os::raw::c_float;
    pub fn ldexpf(__x: ::std::os::raw::c_float,
                  __exponent: ::std::os::raw::c_int)
     -> ::std::os::raw::c_float;
    pub fn __ldexpf(__x: ::std::os::raw::c_float,
                    __exponent: ::std::os::raw::c_int)
     -> ::std::os::raw::c_float;
    pub fn logf(__x: ::std::os::raw::c_float) -> ::std::os::raw::c_float;
    pub fn __logf(__x: ::std::os::raw::c_float) -> ::std::os::raw::c_float;
    pub fn log10f(__x: ::std::os::raw::c_float) -> ::std::os::raw::c_float;
    pub fn __log10f(__x: ::std::os::raw::c_float) -> ::std::os::raw::c_float;
    pub fn modff(__x: ::std::os::raw::c_float,
                 __iptr: *mut ::std::os::raw::c_float)
     -> ::std::os::raw::c_float;
    pub fn __modff(__x: ::std::os::raw::c_float,
                   __iptr: *mut ::std::os::raw::c_float)
     -> ::std::os::raw::c_float;
    pub fn exp10f(__x: ::std::os::raw::c_float) -> ::std::os::raw::c_float;
    pub fn __exp10f(__x: ::std::os::raw::c_float) -> ::std::os::raw::c_float;
    pub fn pow10f(__x: ::std::os::raw::c_float) -> ::std::os::raw::c_float;
    pub fn __pow10f(__x: ::std::os::raw::c_float) -> ::std::os::raw::c_float;
    pub fn expm1f(__x: ::std::os::raw::c_float) -> ::std::os::raw::c_float;
    pub fn __expm1f(__x: ::std::os::raw::c_float) -> ::std::os::raw::c_float;
    pub fn log1pf(__x: ::std::os::raw::c_float) -> ::std::os::raw::c_float;
    pub fn __log1pf(__x: ::std::os::raw::c_float) -> ::std::os::raw::c_float;
    pub fn logbf(__x: ::std::os::raw::c_float) -> ::std::os::raw::c_float;
    pub fn __logbf(__x: ::std::os::raw::c_float) -> ::std::os::raw::c_float;
    pub fn exp2f(__x: ::std::os::raw::c_float) -> ::std::os::raw::c_float;
    pub fn __exp2f(__x: ::std::os::raw::c_float) -> ::std::os::raw::c_float;
    pub fn log2f(__x: ::std::os::raw::c_float) -> ::std::os::raw::c_float;
    pub fn __log2f(__x: ::std::os::raw::c_float) -> ::std::os::raw::c_float;
    pub fn powf(__x: ::std::os::raw::c_float, __y: ::std::os::raw::c_float)
     -> ::std::os::raw::c_float;
    pub fn __powf(__x: ::std::os::raw::c_float, __y: ::std::os::raw::c_float)
     -> ::std::os::raw::c_float;
    pub fn sqrtf(__x: ::std::os::raw::c_float) -> ::std::os::raw::c_float;
    pub fn __sqrtf(__x: ::std::os::raw::c_float) -> ::std::os::raw::c_float;
    pub fn hypotf(__x: ::std::os::raw::c_float, __y: ::std::os::raw::c_float)
     -> ::std::os::raw::c_float;
    pub fn __hypotf(__x: ::std::os::raw::c_float,
                    __y: ::std::os::raw::c_float) -> ::std::os::raw::c_float;
    pub fn cbrtf(__x: ::std::os::raw::c_float) -> ::std::os::raw::c_float;
    pub fn __cbrtf(__x: ::std::os::raw::c_float) -> ::std::os::raw::c_float;
    pub fn ceilf(__x: ::std::os::raw::c_float) -> ::std::os::raw::c_float;
    pub fn __ceilf(__x: ::std::os::raw::c_float) -> ::std::os::raw::c_float;
    pub fn fabsf(__x: ::std::os::raw::c_float) -> ::std::os::raw::c_float;
    pub fn __fabsf(__x: ::std::os::raw::c_float) -> ::std::os::raw::c_float;
    pub fn floorf(__x: ::std::os::raw::c_float) -> ::std::os::raw::c_float;
    pub fn __floorf(__x: ::std::os::raw::c_float) -> ::std::os::raw::c_float;
    pub fn fmodf(__x: ::std::os::raw::c_float, __y: ::std::os::raw::c_float)
     -> ::std::os::raw::c_float;
    pub fn __fmodf(__x: ::std::os::raw::c_float, __y: ::std::os::raw::c_float)
     -> ::std::os::raw::c_float;
    pub fn __isinff(__value: ::std::os::raw::c_float)
     -> ::std::os::raw::c_int;
    pub fn __finitef(__value: ::std::os::raw::c_float)
     -> ::std::os::raw::c_int;
    pub fn isinff(__value: ::std::os::raw::c_float) -> ::std::os::raw::c_int;
    pub fn finitef(__value: ::std::os::raw::c_float) -> ::std::os::raw::c_int;
    pub fn dremf(__x: ::std::os::raw::c_float, __y: ::std::os::raw::c_float)
     -> ::std::os::raw::c_float;
    pub fn __dremf(__x: ::std::os::raw::c_float, __y: ::std::os::raw::c_float)
     -> ::std::os::raw::c_float;
    pub fn significandf(__x: ::std::os::raw::c_float)
     -> ::std::os::raw::c_float;
    pub fn __significandf(__x: ::std::os::raw::c_float)
     -> ::std::os::raw::c_float;
    pub fn copysignf(__x: ::std::os::raw::c_float,
                     __y: ::std::os::raw::c_float) -> ::std::os::raw::c_float;
    pub fn __copysignf(__x: ::std::os::raw::c_float,
                       __y: ::std::os::raw::c_float)
     -> ::std::os::raw::c_float;
    pub fn nanf(__tagb: *const ::std::os::raw::c_char)
     -> ::std::os::raw::c_float;
    pub fn __nanf(__tagb: *const ::std::os::raw::c_char)
     -> ::std::os::raw::c_float;
    pub fn __isnanf(__value: ::std::os::raw::c_float)
     -> ::std::os::raw::c_int;
    pub fn isnanf(__value: ::std::os::raw::c_float) -> ::std::os::raw::c_int;
    pub fn j0f(arg1: ::std::os::raw::c_float) -> ::std::os::raw::c_float;
    pub fn __j0f(arg1: ::std::os::raw::c_float) -> ::std::os::raw::c_float;
    pub fn j1f(arg1: ::std::os::raw::c_float) -> ::std::os::raw::c_float;
    pub fn __j1f(arg1: ::std::os::raw::c_float) -> ::std::os::raw::c_float;
    pub fn jnf(arg1: ::std::os::raw::c_int, arg2: ::std::os::raw::c_float)
     -> ::std::os::raw::c_float;
    pub fn __jnf(arg1: ::std::os::raw::c_int, arg2: ::std::os::raw::c_float)
     -> ::std::os::raw::c_float;
    pub fn y0f(arg1: ::std::os::raw::c_float) -> ::std::os::raw::c_float;
    pub fn __y0f(arg1: ::std::os::raw::c_float) -> ::std::os::raw::c_float;
    pub fn y1f(arg1: ::std::os::raw::c_float) -> ::std::os::raw::c_float;
    pub fn __y1f(arg1: ::std::os::raw::c_float) -> ::std::os::raw::c_float;
    pub fn ynf(arg1: ::std::os::raw::c_int, arg2: ::std::os::raw::c_float)
     -> ::std::os::raw::c_float;
    pub fn __ynf(arg1: ::std::os::raw::c_int, arg2: ::std::os::raw::c_float)
     -> ::std::os::raw::c_float;
    pub fn erff(arg1: ::std::os::raw::c_float) -> ::std::os::raw::c_float;
    pub fn __erff(arg1: ::std::os::raw::c_float) -> ::std::os::raw::c_float;
    pub fn erfcf(arg1: ::std::os::raw::c_float) -> ::std::os::raw::c_float;
    pub fn __erfcf(arg1: ::std::os::raw::c_float) -> ::std::os::raw::c_float;
    pub fn lgammaf(arg1: ::std::os::raw::c_float) -> ::std::os::raw::c_float;
    pub fn __lgammaf(arg1: ::std::os::raw::c_float)
     -> ::std::os::raw::c_float;
    pub fn tgammaf(arg1: ::std::os::raw::c_float) -> ::std::os::raw::c_float;
    pub fn __tgammaf(arg1: ::std::os::raw::c_float)
     -> ::std::os::raw::c_float;
    pub fn gammaf(arg1: ::std::os::raw::c_float) -> ::std::os::raw::c_float;
    pub fn __gammaf(arg1: ::std::os::raw::c_float) -> ::std::os::raw::c_float;
    pub fn lgammaf_r(arg1: ::std::os::raw::c_float,
                     __signgamp: *mut ::std::os::raw::c_int)
     -> ::std::os::raw::c_float;
    pub fn __lgammaf_r(arg1: ::std::os::raw::c_float,
                       __signgamp: *mut ::std::os::raw::c_int)
     -> ::std::os::raw::c_float;
    pub fn rintf(__x: ::std::os::raw::c_float) -> ::std::os::raw::c_float;
    pub fn __rintf(__x: ::std::os::raw::c_float) -> ::std::os::raw::c_float;
    pub fn nextafterf(__x: ::std::os::raw::c_float,
                      __y: ::std::os::raw::c_float)
     -> ::std::os::raw::c_float;
    pub fn __nextafterf(__x: ::std::os::raw::c_float,
                        __y: ::std::os::raw::c_float)
     -> ::std::os::raw::c_float;
    pub fn nexttowardf(__x: ::std::os::raw::c_float,
                       __y: ::std::os::raw::c_double)
     -> ::std::os::raw::c_float;
    pub fn __nexttowardf(__x: ::std::os::raw::c_float,
                         __y: ::std::os::raw::c_double)
     -> ::std::os::raw::c_float;
    pub fn remainderf(__x: ::std::os::raw::c_float,
                      __y: ::std::os::raw::c_float)
     -> ::std::os::raw::c_float;
    pub fn __remainderf(__x: ::std::os::raw::c_float,
                        __y: ::std::os::raw::c_float)
     -> ::std::os::raw::c_float;
    pub fn scalbnf(__x: ::std::os::raw::c_float, __n: ::std::os::raw::c_int)
     -> ::std::os::raw::c_float;
    pub fn __scalbnf(__x: ::std::os::raw::c_float, __n: ::std::os::raw::c_int)
     -> ::std::os::raw::c_float;
    pub fn ilogbf(__x: ::std::os::raw::c_float) -> ::std::os::raw::c_int;
    pub fn __ilogbf(__x: ::std::os::raw::c_float) -> ::std::os::raw::c_int;
    pub fn scalblnf(__x: ::std::os::raw::c_float, __n: ::std::os::raw::c_long)
     -> ::std::os::raw::c_float;
    pub fn __scalblnf(__x: ::std::os::raw::c_float,
                      __n: ::std::os::raw::c_long) -> ::std::os::raw::c_float;
    pub fn nearbyintf(__x: ::std::os::raw::c_float)
     -> ::std::os::raw::c_float;
    pub fn __nearbyintf(__x: ::std::os::raw::c_float)
     -> ::std::os::raw::c_float;
    pub fn roundf(__x: ::std::os::raw::c_float) -> ::std::os::raw::c_float;
    pub fn __roundf(__x: ::std::os::raw::c_float) -> ::std::os::raw::c_float;
    pub fn truncf(__x: ::std::os::raw::c_float) -> ::std::os::raw::c_float;
    pub fn __truncf(__x: ::std::os::raw::c_float) -> ::std::os::raw::c_float;
    pub fn remquof(__x: ::std::os::raw::c_float, __y: ::std::os::raw::c_float,
                   __quo: *mut ::std::os::raw::c_int)
     -> ::std::os::raw::c_float;
    pub fn __remquof(__x: ::std::os::raw::c_float,
                     __y: ::std::os::raw::c_float,
                     __quo: *mut ::std::os::raw::c_int)
     -> ::std::os::raw::c_float;
    pub fn lrintf(__x: ::std::os::raw::c_float) -> ::std::os::raw::c_long;
    pub fn __lrintf(__x: ::std::os::raw::c_float) -> ::std::os::raw::c_long;
    pub fn llrintf(__x: ::std::os::raw::c_float)
     -> ::std::os::raw::c_longlong;
    pub fn __llrintf(__x: ::std::os::raw::c_float)
     -> ::std::os::raw::c_longlong;
    pub fn lroundf(__x: ::std::os::raw::c_float) -> ::std::os::raw::c_long;
    pub fn __lroundf(__x: ::std::os::raw::c_float) -> ::std::os::raw::c_long;
    pub fn llroundf(__x: ::std::os::raw::c_float)
     -> ::std::os::raw::c_longlong;
    pub fn __llroundf(__x: ::std::os::raw::c_float)
     -> ::std::os::raw::c_longlong;
    pub fn fdimf(__x: ::std::os::raw::c_float, __y: ::std::os::raw::c_float)
     -> ::std::os::raw::c_float;
    pub fn __fdimf(__x: ::std::os::raw::c_float, __y: ::std::os::raw::c_float)
     -> ::std::os::raw::c_float;
    pub fn fmaxf(__x: ::std::os::raw::c_float, __y: ::std::os::raw::c_float)
     -> ::std::os::raw::c_float;
    pub fn __fmaxf(__x: ::std::os::raw::c_float, __y: ::std::os::raw::c_float)
     -> ::std::os::raw::c_float;
    pub fn fminf(__x: ::std::os::raw::c_float, __y: ::std::os::raw::c_float)
     -> ::std::os::raw::c_float;
    pub fn __fminf(__x: ::std::os::raw::c_float, __y: ::std::os::raw::c_float)
     -> ::std::os::raw::c_float;
    pub fn __fpclassifyf(__value: ::std::os::raw::c_float)
     -> ::std::os::raw::c_int;
    pub fn __signbitf(__value: ::std::os::raw::c_float)
     -> ::std::os::raw::c_int;
    pub fn fmaf(__x: ::std::os::raw::c_float, __y: ::std::os::raw::c_float,
                __z: ::std::os::raw::c_float) -> ::std::os::raw::c_float;
    pub fn __fmaf(__x: ::std::os::raw::c_float, __y: ::std::os::raw::c_float,
                  __z: ::std::os::raw::c_float) -> ::std::os::raw::c_float;
    pub fn scalbf(__x: ::std::os::raw::c_float, __n: ::std::os::raw::c_float)
     -> ::std::os::raw::c_float;
    pub fn __scalbf(__x: ::std::os::raw::c_float,
                    __n: ::std::os::raw::c_float) -> ::std::os::raw::c_float;
    pub fn acosl(__x: ::std::os::raw::c_double) -> ::std::os::raw::c_double;
    pub fn __acosl(__x: ::std::os::raw::c_double) -> ::std::os::raw::c_double;
    pub fn asinl(__x: ::std::os::raw::c_double) -> ::std::os::raw::c_double;
    pub fn __asinl(__x: ::std::os::raw::c_double) -> ::std::os::raw::c_double;
    pub fn atanl(__x: ::std::os::raw::c_double) -> ::std::os::raw::c_double;
    pub fn __atanl(__x: ::std::os::raw::c_double) -> ::std::os::raw::c_double;
    pub fn atan2l(__y: ::std::os::raw::c_double,
                  __x: ::std::os::raw::c_double) -> ::std::os::raw::c_double;
    pub fn __atan2l(__y: ::std::os::raw::c_double,
                    __x: ::std::os::raw::c_double)
     -> ::std::os::raw::c_double;
    pub fn cosl(__x: ::std::os::raw::c_double) -> ::std::os::raw::c_double;
    pub fn __cosl(__x: ::std::os::raw::c_double) -> ::std::os::raw::c_double;
    pub fn sinl(__x: ::std::os::raw::c_double) -> ::std::os::raw::c_double;
    pub fn __sinl(__x: ::std::os::raw::c_double) -> ::std::os::raw::c_double;
    pub fn tanl(__x: ::std::os::raw::c_double) -> ::std::os::raw::c_double;
    pub fn __tanl(__x: ::std::os::raw::c_double) -> ::std::os::raw::c_double;
    pub fn coshl(__x: ::std::os::raw::c_double) -> ::std::os::raw::c_double;
    pub fn __coshl(__x: ::std::os::raw::c_double) -> ::std::os::raw::c_double;
    pub fn sinhl(__x: ::std::os::raw::c_double) -> ::std::os::raw::c_double;
    pub fn __sinhl(__x: ::std::os::raw::c_double) -> ::std::os::raw::c_double;
    pub fn tanhl(__x: ::std::os::raw::c_double) -> ::std::os::raw::c_double;
    pub fn __tanhl(__x: ::std::os::raw::c_double) -> ::std::os::raw::c_double;
    pub fn sincosl(__x: ::std::os::raw::c_double,
                   __sinx: *mut ::std::os::raw::c_double,
                   __cosx: *mut ::std::os::raw::c_double);
    pub fn __sincosl(__x: ::std::os::raw::c_double,
                     __sinx: *mut ::std::os::raw::c_double,
                     __cosx: *mut ::std::os::raw::c_double);
    pub fn acoshl(__x: ::std::os::raw::c_double) -> ::std::os::raw::c_double;
    pub fn __acoshl(__x: ::std::os::raw::c_double)
     -> ::std::os::raw::c_double;
    pub fn asinhl(__x: ::std::os::raw::c_double) -> ::std::os::raw::c_double;
    pub fn __asinhl(__x: ::std::os::raw::c_double)
     -> ::std::os::raw::c_double;
    pub fn atanhl(__x: ::std::os::raw::c_double) -> ::std::os::raw::c_double;
    pub fn __atanhl(__x: ::std::os::raw::c_double)
     -> ::std::os::raw::c_double;
    pub fn expl(__x: ::std::os::raw::c_double) -> ::std::os::raw::c_double;
    pub fn __expl(__x: ::std::os::raw::c_double) -> ::std::os::raw::c_double;
    pub fn frexpl(__x: ::std::os::raw::c_double,
                  __exponent: *mut ::std::os::raw::c_int)
     -> ::std::os::raw::c_double;
    pub fn __frexpl(__x: ::std::os::raw::c_double,
                    __exponent: *mut ::std::os::raw::c_int)
     -> ::std::os::raw::c_double;
    pub fn ldexpl(__x: ::std::os::raw::c_double,
                  __exponent: ::std::os::raw::c_int)
     -> ::std::os::raw::c_double;
    pub fn __ldexpl(__x: ::std::os::raw::c_double,
                    __exponent: ::std::os::raw::c_int)
     -> ::std::os::raw::c_double;
    pub fn logl(__x: ::std::os::raw::c_double) -> ::std::os::raw::c_double;
    pub fn __logl(__x: ::std::os::raw::c_double) -> ::std::os::raw::c_double;
    pub fn log10l(__x: ::std::os::raw::c_double) -> ::std::os::raw::c_double;
    pub fn __log10l(__x: ::std::os::raw::c_double)
     -> ::std::os::raw::c_double;
    pub fn modfl(__x: ::std::os::raw::c_double,
                 __iptr: *mut ::std::os::raw::c_double)
     -> ::std::os::raw::c_double;
    pub fn __modfl(__x: ::std::os::raw::c_double,
                   __iptr: *mut ::std::os::raw::c_double)
     -> ::std::os::raw::c_double;
    pub fn exp10l(__x: ::std::os::raw::c_double) -> ::std::os::raw::c_double;
    pub fn __exp10l(__x: ::std::os::raw::c_double)
     -> ::std::os::raw::c_double;
    pub fn pow10l(__x: ::std::os::raw::c_double) -> ::std::os::raw::c_double;
    pub fn __pow10l(__x: ::std::os::raw::c_double)
     -> ::std::os::raw::c_double;
    pub fn expm1l(__x: ::std::os::raw::c_double) -> ::std::os::raw::c_double;
    pub fn __expm1l(__x: ::std::os::raw::c_double)
     -> ::std::os::raw::c_double;
    pub fn log1pl(__x: ::std::os::raw::c_double) -> ::std::os::raw::c_double;
    pub fn __log1pl(__x: ::std::os::raw::c_double)
     -> ::std::os::raw::c_double;
    pub fn logbl(__x: ::std::os::raw::c_double) -> ::std::os::raw::c_double;
    pub fn __logbl(__x: ::std::os::raw::c_double) -> ::std::os::raw::c_double;
    pub fn exp2l(__x: ::std::os::raw::c_double) -> ::std::os::raw::c_double;
    pub fn __exp2l(__x: ::std::os::raw::c_double) -> ::std::os::raw::c_double;
    pub fn log2l(__x: ::std::os::raw::c_double) -> ::std::os::raw::c_double;
    pub fn __log2l(__x: ::std::os::raw::c_double) -> ::std::os::raw::c_double;
    pub fn powl(__x: ::std::os::raw::c_double, __y: ::std::os::raw::c_double)
     -> ::std::os::raw::c_double;
    pub fn __powl(__x: ::std::os::raw::c_double,
                  __y: ::std::os::raw::c_double) -> ::std::os::raw::c_double;
    pub fn sqrtl(__x: ::std::os::raw::c_double) -> ::std::os::raw::c_double;
    pub fn __sqrtl(__x: ::std::os::raw::c_double) -> ::std::os::raw::c_double;
    pub fn hypotl(__x: ::std::os::raw::c_double,
                  __y: ::std::os::raw::c_double) -> ::std::os::raw::c_double;
    pub fn __hypotl(__x: ::std::os::raw::c_double,
                    __y: ::std::os::raw::c_double)
     -> ::std::os::raw::c_double;
    pub fn cbrtl(__x: ::std::os::raw::c_double) -> ::std::os::raw::c_double;
    pub fn __cbrtl(__x: ::std::os::raw::c_double) -> ::std::os::raw::c_double;
    pub fn ceill(__x: ::std::os::raw::c_double) -> ::std::os::raw::c_double;
    pub fn __ceill(__x: ::std::os::raw::c_double) -> ::std::os::raw::c_double;
    pub fn fabsl(__x: ::std::os::raw::c_double) -> ::std::os::raw::c_double;
    pub fn __fabsl(__x: ::std::os::raw::c_double) -> ::std::os::raw::c_double;
    pub fn floorl(__x: ::std::os::raw::c_double) -> ::std::os::raw::c_double;
    pub fn __floorl(__x: ::std::os::raw::c_double)
     -> ::std::os::raw::c_double;
    pub fn fmodl(__x: ::std::os::raw::c_double, __y: ::std::os::raw::c_double)
     -> ::std::os::raw::c_double;
    pub fn __fmodl(__x: ::std::os::raw::c_double,
                   __y: ::std::os::raw::c_double) -> ::std::os::raw::c_double;
    pub fn __isinfl(__value: ::std::os::raw::c_double)
     -> ::std::os::raw::c_int;
    pub fn __finitel(__value: ::std::os::raw::c_double)
     -> ::std::os::raw::c_int;
    pub fn isinfl(__value: ::std::os::raw::c_double) -> ::std::os::raw::c_int;
    pub fn finitel(__value: ::std::os::raw::c_double)
     -> ::std::os::raw::c_int;
    pub fn dreml(__x: ::std::os::raw::c_double, __y: ::std::os::raw::c_double)
     -> ::std::os::raw::c_double;
    pub fn __dreml(__x: ::std::os::raw::c_double,
                   __y: ::std::os::raw::c_double) -> ::std::os::raw::c_double;
    pub fn significandl(__x: ::std::os::raw::c_double)
     -> ::std::os::raw::c_double;
    pub fn __significandl(__x: ::std::os::raw::c_double)
     -> ::std::os::raw::c_double;
    pub fn copysignl(__x: ::std::os::raw::c_double,
                     __y: ::std::os::raw::c_double)
     -> ::std::os::raw::c_double;
    pub fn __copysignl(__x: ::std::os::raw::c_double,
                       __y: ::std::os::raw::c_double)
     -> ::std::os::raw::c_double;
    pub fn nanl(__tagb: *const ::std::os::raw::c_char)
     -> ::std::os::raw::c_double;
    pub fn __nanl(__tagb: *const ::std::os::raw::c_char)
     -> ::std::os::raw::c_double;
    pub fn __isnanl(__value: ::std::os::raw::c_double)
     -> ::std::os::raw::c_int;
    pub fn isnanl(__value: ::std::os::raw::c_double) -> ::std::os::raw::c_int;
    pub fn j0l(arg1: ::std::os::raw::c_double) -> ::std::os::raw::c_double;
    pub fn __j0l(arg1: ::std::os::raw::c_double) -> ::std::os::raw::c_double;
    pub fn j1l(arg1: ::std::os::raw::c_double) -> ::std::os::raw::c_double;
    pub fn __j1l(arg1: ::std::os::raw::c_double) -> ::std::os::raw::c_double;
    pub fn jnl(arg1: ::std::os::raw::c_int, arg2: ::std::os::raw::c_double)
     -> ::std::os::raw::c_double;
    pub fn __jnl(arg1: ::std::os::raw::c_int, arg2: ::std::os::raw::c_double)
     -> ::std::os::raw::c_double;
    pub fn y0l(arg1: ::std::os::raw::c_double) -> ::std::os::raw::c_double;
    pub fn __y0l(arg1: ::std::os::raw::c_double) -> ::std::os::raw::c_double;
    pub fn y1l(arg1: ::std::os::raw::c_double) -> ::std::os::raw::c_double;
    pub fn __y1l(arg1: ::std::os::raw::c_double) -> ::std::os::raw::c_double;
    pub fn ynl(arg1: ::std::os::raw::c_int, arg2: ::std::os::raw::c_double)
     -> ::std::os::raw::c_double;
    pub fn __ynl(arg1: ::std::os::raw::c_int, arg2: ::std::os::raw::c_double)
     -> ::std::os::raw::c_double;
    pub fn erfl(arg1: ::std::os::raw::c_double) -> ::std::os::raw::c_double;
    pub fn __erfl(arg1: ::std::os::raw::c_double) -> ::std::os::raw::c_double;
    pub fn erfcl(arg1: ::std::os::raw::c_double) -> ::std::os::raw::c_double;
    pub fn __erfcl(arg1: ::std::os::raw::c_double)
     -> ::std::os::raw::c_double;
    pub fn lgammal(arg1: ::std::os::raw::c_double)
     -> ::std::os::raw::c_double;
    pub fn __lgammal(arg1: ::std::os::raw::c_double)
     -> ::std::os::raw::c_double;
    pub fn tgammal(arg1: ::std::os::raw::c_double)
     -> ::std::os::raw::c_double;
    pub fn __tgammal(arg1: ::std::os::raw::c_double)
     -> ::std::os::raw::c_double;
    pub fn gammal(arg1: ::std::os::raw::c_double) -> ::std::os::raw::c_double;
    pub fn __gammal(arg1: ::std::os::raw::c_double)
     -> ::std::os::raw::c_double;
    pub fn lgammal_r(arg1: ::std::os::raw::c_double,
                     __signgamp: *mut ::std::os::raw::c_int)
     -> ::std::os::raw::c_double;
    pub fn __lgammal_r(arg1: ::std::os::raw::c_double,
                       __signgamp: *mut ::std::os::raw::c_int)
     -> ::std::os::raw::c_double;
    pub fn rintl(__x: ::std::os::raw::c_double) -> ::std::os::raw::c_double;
    pub fn __rintl(__x: ::std::os::raw::c_double) -> ::std::os::raw::c_double;
    pub fn nextafterl(__x: ::std::os::raw::c_double,
                      __y: ::std::os::raw::c_double)
     -> ::std::os::raw::c_double;
    pub fn __nextafterl(__x: ::std::os::raw::c_double,
                        __y: ::std::os::raw::c_double)
     -> ::std::os::raw::c_double;
    pub fn nexttowardl(__x: ::std::os::raw::c_double,
                       __y: ::std::os::raw::c_double)
     -> ::std::os::raw::c_double;
    pub fn __nexttowardl(__x: ::std::os::raw::c_double,
                         __y: ::std::os::raw::c_double)
     -> ::std::os::raw::c_double;
    pub fn remainderl(__x: ::std::os::raw::c_double,
                      __y: ::std::os::raw::c_double)
     -> ::std::os::raw::c_double;
    pub fn __remainderl(__x: ::std::os::raw::c_double,
                        __y: ::std::os::raw::c_double)
     -> ::std::os::raw::c_double;
    pub fn scalbnl(__x: ::std::os::raw::c_double, __n: ::std::os::raw::c_int)
     -> ::std::os::raw::c_double;
    pub fn __scalbnl(__x: ::std::os::raw::c_double,
                     __n: ::std::os::raw::c_int) -> ::std::os::raw::c_double;
    pub fn ilogbl(__x: ::std::os::raw::c_double) -> ::std::os::raw::c_int;
    pub fn __ilogbl(__x: ::std::os::raw::c_double) -> ::std::os::raw::c_int;
    pub fn scalblnl(__x: ::std::os::raw::c_double,
                    __n: ::std::os::raw::c_long) -> ::std::os::raw::c_double;
    pub fn __scalblnl(__x: ::std::os::raw::c_double,
                      __n: ::std::os::raw::c_long)
     -> ::std::os::raw::c_double;
    pub fn nearbyintl(__x: ::std::os::raw::c_double)
     -> ::std::os::raw::c_double;
    pub fn __nearbyintl(__x: ::std::os::raw::c_double)
     -> ::std::os::raw::c_double;
    pub fn roundl(__x: ::std::os::raw::c_double) -> ::std::os::raw::c_double;
    pub fn __roundl(__x: ::std::os::raw::c_double)
     -> ::std::os::raw::c_double;
    pub fn truncl(__x: ::std::os::raw::c_double) -> ::std::os::raw::c_double;
    pub fn __truncl(__x: ::std::os::raw::c_double)
     -> ::std::os::raw::c_double;
    pub fn remquol(__x: ::std::os::raw::c_double,
                   __y: ::std::os::raw::c_double,
                   __quo: *mut ::std::os::raw::c_int)
     -> ::std::os::raw::c_double;
    pub fn __remquol(__x: ::std::os::raw::c_double,
                     __y: ::std::os::raw::c_double,
                     __quo: *mut ::std::os::raw::c_int)
     -> ::std::os::raw::c_double;
    pub fn lrintl(__x: ::std::os::raw::c_double) -> ::std::os::raw::c_long;
    pub fn __lrintl(__x: ::std::os::raw::c_double) -> ::std::os::raw::c_long;
    pub fn llrintl(__x: ::std::os::raw::c_double)
     -> ::std::os::raw::c_longlong;
    pub fn __llrintl(__x: ::std::os::raw::c_double)
     -> ::std::os::raw::c_longlong;
    pub fn lroundl(__x: ::std::os::raw::c_double) -> ::std::os::raw::c_long;
    pub fn __lroundl(__x: ::std::os::raw::c_double) -> ::std::os::raw::c_long;
    pub fn llroundl(__x: ::std::os::raw::c_double)
     -> ::std::os::raw::c_longlong;
    pub fn __llroundl(__x: ::std::os::raw::c_double)
     -> ::std::os::raw::c_longlong;
    pub fn fdiml(__x: ::std::os::raw::c_double, __y: ::std::os::raw::c_double)
     -> ::std::os::raw::c_double;
    pub fn __fdiml(__x: ::std::os::raw::c_double,
                   __y: ::std::os::raw::c_double) -> ::std::os::raw::c_double;
    pub fn fmaxl(__x: ::std::os::raw::c_double, __y: ::std::os::raw::c_double)
     -> ::std::os::raw::c_double;
    pub fn __fmaxl(__x: ::std::os::raw::c_double,
                   __y: ::std::os::raw::c_double) -> ::std::os::raw::c_double;
    pub fn fminl(__x: ::std::os::raw::c_double, __y: ::std::os::raw::c_double)
     -> ::std::os::raw::c_double;
    pub fn __fminl(__x: ::std::os::raw::c_double,
                   __y: ::std::os::raw::c_double) -> ::std::os::raw::c_double;
    pub fn __fpclassifyl(__value: ::std::os::raw::c_double)
     -> ::std::os::raw::c_int;
    pub fn __signbitl(__value: ::std::os::raw::c_double)
     -> ::std::os::raw::c_int;
    pub fn fmal(__x: ::std::os::raw::c_double, __y: ::std::os::raw::c_double,
                __z: ::std::os::raw::c_double) -> ::std::os::raw::c_double;
    pub fn __fmal(__x: ::std::os::raw::c_double,
                  __y: ::std::os::raw::c_double,
                  __z: ::std::os::raw::c_double) -> ::std::os::raw::c_double;
    pub fn scalbl(__x: ::std::os::raw::c_double,
                  __n: ::std::os::raw::c_double) -> ::std::os::raw::c_double;
    pub fn __scalbl(__x: ::std::os::raw::c_double,
                    __n: ::std::os::raw::c_double)
     -> ::std::os::raw::c_double;
    pub fn matherr(__exc: *mut Struct_exception) -> ::std::os::raw::c_int;
    pub fn strlcpy(arg1: *mut ::std::os::raw::c_char,
                   arg2: *const ::std::os::raw::c_char, arg3: size_t)
     -> size_t;
    pub fn strlcat(arg1: *mut ::std::os::raw::c_char,
                   arg2: *const ::std::os::raw::c_char, arg3: size_t)
     -> size_t;
    pub fn setproctitle(fmt: *const ::std::os::raw::c_char, ...);
    pub fn ruby_xmalloc(arg1: size_t) -> *mut ::std::os::raw::c_void;
    pub fn ruby_xmalloc2(arg1: size_t, arg2: size_t)
     -> *mut ::std::os::raw::c_void;
    pub fn ruby_xcalloc(arg1: size_t, arg2: size_t)
     -> *mut ::std::os::raw::c_void;
    pub fn ruby_xrealloc(arg1: *mut ::std::os::raw::c_void, arg2: size_t)
     -> *mut ::std::os::raw::c_void;
    pub fn ruby_xrealloc2(arg1: *mut ::std::os::raw::c_void, arg2: size_t,
                          arg3: size_t) -> *mut ::std::os::raw::c_void;
    pub fn ruby_xfree(arg1: *mut ::std::os::raw::c_void);
    pub fn rb_int2inum(arg1: ::std::os::raw::c_long) -> VALUE;
    pub fn rb_uint2inum(arg1: VALUE) -> VALUE;
    pub fn rb_ll2inum(arg1: ::std::os::raw::c_longlong) -> VALUE;
    pub fn rb_ull2inum(arg1: ::std::os::raw::c_ulonglong) -> VALUE;
    pub fn rb_out_of_int(num: ::std::os::raw::c_long);
    pub fn rb_check_type(arg1: VALUE, arg2: ::std::os::raw::c_int);
    pub fn rb_str_to_str(arg1: VALUE) -> VALUE;
    pub fn rb_string_value(arg1: *mut VALUE) -> VALUE;
    pub fn rb_string_value_ptr(arg1: *mut VALUE)
     -> *mut ::std::os::raw::c_char;
    pub fn rb_string_value_cstr(arg1: *mut VALUE)
     -> *mut ::std::os::raw::c_char;
    pub fn rb_check_safe_obj(arg1: VALUE);
    pub fn rb_check_safe_str(arg1: VALUE);
    pub fn rb_str_export(arg1: VALUE) -> VALUE;
    pub fn rb_str_export_locale(arg1: VALUE) -> VALUE;
    pub fn rb_get_path(arg1: VALUE) -> VALUE;
    pub fn rb_get_path_no_checksafe(arg1: VALUE) -> VALUE;
    pub fn rb_secure(arg1: ::std::os::raw::c_int);
    pub fn rb_safe_level() -> ::std::os::raw::c_int;
    pub fn rb_set_safe_level(arg1: ::std::os::raw::c_int);
    pub fn rb_set_safe_level_force(arg1: ::std::os::raw::c_int);
    pub fn rb_secure_update(arg1: VALUE);
    pub fn rb_insecure_operation();
    pub fn rb_errinfo() -> VALUE;
    pub fn rb_set_errinfo(arg1: VALUE);
    pub fn rb_num2long(arg1: VALUE) -> ::std::os::raw::c_long;
    pub fn rb_num2ulong(arg1: VALUE) -> VALUE;
    pub fn rb_num2int(arg1: VALUE) -> ::std::os::raw::c_long;
    pub fn rb_fix2int(arg1: VALUE) -> ::std::os::raw::c_long;
    pub fn rb_num2uint(arg1: VALUE) -> ::std::os::raw::c_ulong;
    pub fn rb_fix2uint(arg1: VALUE) -> ::std::os::raw::c_ulong;
    pub fn rb_num2short(arg1: VALUE) -> ::std::os::raw::c_short;
    pub fn rb_num2ushort(arg1: VALUE) -> ::std::os::raw::c_ushort;
    pub fn rb_fix2short(arg1: VALUE) -> ::std::os::raw::c_short;
    pub fn rb_fix2ushort(arg1: VALUE) -> ::std::os::raw::c_ushort;
    pub fn rb_num2ll(arg1: VALUE) -> ::std::os::raw::c_longlong;
    pub fn rb_num2ull(arg1: VALUE) -> ::std::os::raw::c_ulonglong;
    pub fn rb_num2dbl(arg1: VALUE) -> ::std::os::raw::c_double;
    pub fn rb_uint2big(arg1: VALUE) -> VALUE;
    pub fn rb_int2big(arg1: ::std::os::raw::c_long) -> VALUE;
    pub fn rb_newobj() -> VALUE;
    pub fn rb_newobj_of(arg1: VALUE, arg2: VALUE) -> VALUE;
    pub fn rb_obj_setup(obj: VALUE, klass: VALUE, _type: VALUE) -> VALUE;
    pub fn rb_obj_hide(obj: VALUE) -> VALUE;
    pub fn rb_obj_reveal(obj: VALUE, klass: VALUE) -> VALUE;
    pub fn rb_float_value(arg1: VALUE) -> ::std::os::raw::c_double;
    pub fn rb_float_new(arg1: ::std::os::raw::c_double) -> VALUE;
    pub fn rb_float_new_in_heap(arg1: ::std::os::raw::c_double) -> VALUE;
    pub fn rb_data_object_alloc(arg1: VALUE,
                                arg2: *mut ::std::os::raw::c_void,
                                arg3: RUBY_DATA_FUNC, arg4: RUBY_DATA_FUNC)
     -> VALUE;
    pub fn rb_data_typed_object_alloc(klass: VALUE,
                                      datap: *mut ::std::os::raw::c_void,
                                      arg1: *const rb_data_type_t) -> VALUE;
    pub fn rb_typeddata_inherited_p(child: *const rb_data_type_t,
                                    parent: *const rb_data_type_t)
     -> ::std::os::raw::c_int;
    pub fn rb_typeddata_is_kind_of(arg1: VALUE, arg2: *const rb_data_type_t)
     -> ::std::os::raw::c_int;
    pub fn rb_check_typeddata(arg1: VALUE, arg2: *const rb_data_type_t)
     -> *mut ::std::os::raw::c_void;
    pub fn rb_gc_writebarrier(a: VALUE, b: VALUE);
    pub fn rb_gc_writebarrier_unprotect_promoted(obj: VALUE);
    pub fn rb_alloc_tmp_buffer(store: *mut VALUE, len: ::std::os::raw::c_long)
     -> *mut ::std::os::raw::c_void;
    pub fn rb_free_tmp_buffer(store: *mut VALUE);
    pub fn rb_obj_infect(arg1: VALUE, arg2: VALUE);
    pub fn rb_glob(arg1: *const ::std::os::raw::c_char,
                   arg2:
                       ::std::option::Option<unsafe extern "C" fn(arg1:
                                                                      *const ::std::os::raw::c_char,
                                                                  arg2: VALUE,
                                                                  arg3:
                                                                      *mut ::std::os::raw::c_void)>,
                   arg3: VALUE);
    pub fn ruby_glob(arg1: *const ::std::os::raw::c_char,
                     arg2: ::std::os::raw::c_int,
                     arg3:
                         *mut ::std::option::Option<extern "C" fn()
                                                        ->
                                                            ::std::os::raw::c_int>,
                     arg4: VALUE) -> ::std::os::raw::c_int;
    pub fn ruby_brace_glob(arg1: *const ::std::os::raw::c_char,
                           arg2: ::std::os::raw::c_int,
                           arg3:
                               *mut ::std::option::Option<extern "C" fn()
                                                              ->
                                                                  ::std::os::raw::c_int>,
                           arg4: VALUE) -> ::std::os::raw::c_int;
    pub fn rb_define_class(arg1: *const ::std::os::raw::c_char, arg2: VALUE)
     -> VALUE;
    pub fn rb_define_module(arg1: *const ::std::os::raw::c_char) -> VALUE;
    pub fn rb_define_class_under(arg1: VALUE,
                                 arg2: *const ::std::os::raw::c_char,
                                 arg3: VALUE) -> VALUE;
    pub fn rb_define_module_under(arg1: VALUE,
                                  arg2: *const ::std::os::raw::c_char)
     -> VALUE;
    pub fn rb_include_module(arg1: VALUE, arg2: VALUE);
    pub fn rb_extend_object(arg1: VALUE, arg2: VALUE);
    pub fn rb_prepend_module(arg1: VALUE, arg2: VALUE);
    pub fn rb_gvar_undef_getter(id: ID, data: *mut ::std::os::raw::c_void,
                                gvar: *mut Struct_rb_global_variable)
     -> VALUE;
    pub fn rb_gvar_undef_setter(val: VALUE, id: ID,
                                data: *mut ::std::os::raw::c_void,
                                gvar: *mut Struct_rb_global_variable);
    pub fn rb_gvar_undef_marker(var: *mut VALUE);
    pub fn rb_gvar_val_getter(id: ID, data: *mut ::std::os::raw::c_void,
                              gvar: *mut Struct_rb_global_variable) -> VALUE;
    pub fn rb_gvar_val_setter(val: VALUE, id: ID,
                              data: *mut ::std::os::raw::c_void,
                              gvar: *mut Struct_rb_global_variable);
    pub fn rb_gvar_val_marker(var: *mut VALUE);
    pub fn rb_gvar_var_getter(id: ID, data: *mut ::std::os::raw::c_void,
                              gvar: *mut Struct_rb_global_variable) -> VALUE;
    pub fn rb_gvar_var_setter(val: VALUE, id: ID,
                              data: *mut ::std::os::raw::c_void,
                              gvar: *mut Struct_rb_global_variable);
    pub fn rb_gvar_var_marker(var: *mut VALUE);
    pub fn rb_gvar_readonly_setter(val: VALUE, id: ID,
                                   data: *mut ::std::os::raw::c_void,
                                   gvar: *mut Struct_rb_global_variable);
    pub fn rb_define_variable(arg1: *const ::std::os::raw::c_char,
                              arg2: *mut VALUE);
    pub fn rb_define_virtual_variable(arg1: *const ::std::os::raw::c_char,
                                      arg2:
                                          ::std::option::Option<extern "C" fn()
                                                                    -> VALUE>,
                                      arg3:
                                          ::std::option::Option<extern "C" fn()>);
    pub fn rb_define_hooked_variable(arg1: *const ::std::os::raw::c_char,
                                     arg2: *mut VALUE,
                                     arg3:
                                         ::std::option::Option<extern "C" fn()
                                                                   -> VALUE>,
                                     arg4:
                                         ::std::option::Option<extern "C" fn()>);
    pub fn rb_define_readonly_variable(arg1: *const ::std::os::raw::c_char,
                                       arg2: *mut VALUE);
    pub fn rb_define_const(arg1: VALUE, arg2: *const ::std::os::raw::c_char,
                           arg3: VALUE);
    pub fn rb_define_global_const(arg1: *const ::std::os::raw::c_char,
                                  arg2: VALUE);
    pub fn rb_define_method(arg1: VALUE, arg2: *const ::std::os::raw::c_char,
                            arg3:
                                ::std::option::Option<extern "C" fn()
                                                          -> VALUE>,
                            arg4: ::std::os::raw::c_int);
    pub fn rb_define_module_function(arg1: VALUE,
                                     arg2: *const ::std::os::raw::c_char,
                                     arg3:
                                         ::std::option::Option<extern "C" fn()
                                                                   -> VALUE>,
                                     arg4: ::std::os::raw::c_int);
    pub fn rb_define_global_function(arg1: *const ::std::os::raw::c_char,
                                     arg2:
                                         ::std::option::Option<extern "C" fn()
                                                                   -> VALUE>,
                                     arg3: ::std::os::raw::c_int);
    pub fn rb_undef_method(arg1: VALUE, arg2: *const ::std::os::raw::c_char);
    pub fn rb_define_alias(arg1: VALUE, arg2: *const ::std::os::raw::c_char,
                           arg3: *const ::std::os::raw::c_char);
    pub fn rb_define_attr(arg1: VALUE, arg2: *const ::std::os::raw::c_char,
                          arg3: ::std::os::raw::c_int,
                          arg4: ::std::os::raw::c_int);
    pub fn rb_global_variable(arg1: *mut VALUE);
    pub fn rb_gc_register_mark_object(arg1: VALUE);
    pub fn rb_gc_register_address(arg1: *mut VALUE);
    pub fn rb_gc_unregister_address(arg1: *mut VALUE);
    pub fn rb_intern(arg1: *const ::std::os::raw::c_char) -> ID;
    pub fn rb_intern2(arg1: *const ::std::os::raw::c_char,
                      arg2: ::std::os::raw::c_long) -> ID;
    pub fn rb_intern_str(str: VALUE) -> ID;
    pub fn rb_id2name(arg1: ID) -> *const ::std::os::raw::c_char;
    pub fn rb_check_id(arg1: *mut VALUE) -> ID;
    pub fn rb_to_id(arg1: VALUE) -> ID;
    pub fn rb_id2str(arg1: ID) -> VALUE;
    pub fn rb_class2name(arg1: VALUE) -> *const ::std::os::raw::c_char;
    pub fn rb_obj_classname(arg1: VALUE) -> *const ::std::os::raw::c_char;
    pub fn rb_p(arg1: VALUE);
    pub fn rb_eval_string(arg1: *const ::std::os::raw::c_char) -> VALUE;
    pub fn rb_eval_string_protect(arg1: *const ::std::os::raw::c_char,
                                  arg2: *mut ::std::os::raw::c_int) -> VALUE;
    pub fn rb_eval_string_wrap(arg1: *const ::std::os::raw::c_char,
                               arg2: *mut ::std::os::raw::c_int) -> VALUE;
    pub fn rb_funcall(arg1: VALUE, arg2: ID, arg3: ::std::os::raw::c_int, ...)
     -> VALUE;
    pub fn rb_funcallv(arg1: VALUE, arg2: ID, arg3: ::std::os::raw::c_int,
                       arg4: *const VALUE) -> VALUE;
    pub fn rb_funcallv_public(arg1: VALUE, arg2: ID,
                              arg3: ::std::os::raw::c_int, arg4: *const VALUE)
     -> VALUE;
    pub fn rb_funcall_passing_block(arg1: VALUE, arg2: ID,
                                    arg3: ::std::os::raw::c_int,
                                    arg4: *const VALUE) -> VALUE;
    pub fn rb_funcall_with_block(arg1: VALUE, arg2: ID,
                                 arg3: ::std::os::raw::c_int,
                                 arg4: *const VALUE, arg5: VALUE) -> VALUE;
    pub fn rb_scan_args(arg1: ::std::os::raw::c_int, arg2: *const VALUE,
                        arg3: *const ::std::os::raw::c_char, ...)
     -> ::std::os::raw::c_int;
    pub fn rb_call_super(arg1: ::std::os::raw::c_int, arg2: *const VALUE)
     -> VALUE;
    pub fn rb_gv_set(arg1: *const ::std::os::raw::c_char, arg2: VALUE)
     -> VALUE;
    pub fn rb_gv_get(arg1: *const ::std::os::raw::c_char) -> VALUE;
    pub fn rb_iv_get(arg1: VALUE, arg2: *const ::std::os::raw::c_char)
     -> VALUE;
    pub fn rb_iv_set(arg1: VALUE, arg2: *const ::std::os::raw::c_char,
                     arg3: VALUE) -> VALUE;
    pub fn rb_equal(arg1: VALUE, arg2: VALUE) -> VALUE;
    pub fn rb_ruby_verbose_ptr() -> *mut VALUE;
    pub fn rb_ruby_debug_ptr() -> *mut VALUE;
    pub fn rb_raise(arg1: VALUE, arg2: *const ::std::os::raw::c_char, ...);
    pub fn rb_fatal(arg1: *const ::std::os::raw::c_char, ...);
    pub fn rb_bug(arg1: *const ::std::os::raw::c_char, ...);
    pub fn rb_bug_errno(arg1: *const ::std::os::raw::c_char,
                        arg2: ::std::os::raw::c_int);
    pub fn rb_sys_fail(arg1: *const ::std::os::raw::c_char);
    pub fn rb_sys_fail_str(arg1: VALUE);
    pub fn rb_mod_sys_fail(arg1: VALUE, arg2: *const ::std::os::raw::c_char);
    pub fn rb_mod_sys_fail_str(arg1: VALUE, arg2: VALUE);
    pub fn rb_readwrite_sys_fail(arg1: ::std::os::raw::c_int,
                                 arg2: *const ::std::os::raw::c_char);
    pub fn rb_iter_break();
    pub fn rb_iter_break_value(arg1: VALUE);
    pub fn rb_exit(arg1: ::std::os::raw::c_int);
    pub fn rb_notimplement();
    pub fn rb_syserr_new(arg1: ::std::os::raw::c_int,
                         arg2: *const ::std::os::raw::c_char) -> VALUE;
    pub fn rb_syserr_new_str(n: ::std::os::raw::c_int, arg: VALUE) -> VALUE;
    pub fn rb_syserr_fail(arg1: ::std::os::raw::c_int,
                          arg2: *const ::std::os::raw::c_char);
    pub fn rb_syserr_fail_str(arg1: ::std::os::raw::c_int, arg2: VALUE);
    pub fn rb_mod_syserr_fail(arg1: VALUE, arg2: ::std::os::raw::c_int,
                              arg3: *const ::std::os::raw::c_char);
    pub fn rb_mod_syserr_fail_str(arg1: VALUE, arg2: ::std::os::raw::c_int,
                                  arg3: VALUE);
    pub fn rb_warning(arg1: *const ::std::os::raw::c_char, ...);
    pub fn rb_compile_warning(arg1: *const ::std::os::raw::c_char,
                              arg2: ::std::os::raw::c_int,
                              arg3: *const ::std::os::raw::c_char, ...);
    pub fn rb_sys_warning(arg1: *const ::std::os::raw::c_char, ...);
    pub fn rb_warn(arg1: *const ::std::os::raw::c_char, ...);
    pub fn rb_compile_warn(arg1: *const ::std::os::raw::c_char,
                           arg2: ::std::os::raw::c_int,
                           arg3: *const ::std::os::raw::c_char, ...);
    pub fn rb_each(arg1: VALUE) -> VALUE;
    pub fn rb_yield(arg1: VALUE) -> VALUE;
    pub fn rb_yield_values(n: ::std::os::raw::c_int, ...) -> VALUE;
    pub fn rb_yield_values2(n: ::std::os::raw::c_int, argv: *const VALUE)
     -> VALUE;
    pub fn rb_yield_splat(arg1: VALUE) -> VALUE;
    pub fn rb_yield_block(arg1: VALUE, arg2: VALUE,
                          arg3: ::std::os::raw::c_int, arg4: *const VALUE,
                          arg5: VALUE) -> VALUE;
    pub fn rb_block_given_p() -> ::std::os::raw::c_int;
    pub fn rb_need_block();
    pub fn rb_iterate(arg1:
                          ::std::option::Option<extern "C" fn(arg1: VALUE)
                                                    -> VALUE>, arg2: VALUE,
                      arg3: ::std::option::Option<extern "C" fn() -> VALUE>,
                      arg4: VALUE) -> VALUE;
    pub fn rb_block_call(arg1: VALUE, arg2: ID, arg3: ::std::os::raw::c_int,
                         arg4: *const VALUE, arg5: rb_block_call_func_t,
                         arg6: VALUE) -> VALUE;
    pub fn rb_rescue(arg1: ::std::option::Option<extern "C" fn() -> VALUE>,
                     arg2: VALUE,
                     arg3: ::std::option::Option<extern "C" fn() -> VALUE>,
                     arg4: VALUE) -> VALUE;
    pub fn rb_rescue2(arg1: ::std::option::Option<extern "C" fn() -> VALUE>,
                      arg2: VALUE,
                      arg3: ::std::option::Option<extern "C" fn() -> VALUE>,
                      arg4: VALUE, ...) -> VALUE;
    pub fn rb_ensure(arg1: ::std::option::Option<extern "C" fn() -> VALUE>,
                     arg2: VALUE,
                     arg3: ::std::option::Option<extern "C" fn() -> VALUE>,
                     arg4: VALUE) -> VALUE;
    pub fn rb_catch(arg1: *const ::std::os::raw::c_char,
                    arg2: ::std::option::Option<extern "C" fn() -> VALUE>,
                    arg3: VALUE) -> VALUE;
    pub fn rb_catch_obj(arg1: VALUE,
                        arg2: ::std::option::Option<extern "C" fn() -> VALUE>,
                        arg3: VALUE) -> VALUE;
    pub fn rb_throw(arg1: *const ::std::os::raw::c_char, arg2: VALUE);
    pub fn rb_throw_obj(arg1: VALUE, arg2: VALUE);
    pub fn rb_require(arg1: *const ::std::os::raw::c_char) -> VALUE;
    pub fn st_init_table(arg1: *const Struct_st_hash_type) -> *mut st_table;
    pub fn st_init_table_with_size(arg1: *const Struct_st_hash_type,
                                   arg2: st_index_t) -> *mut st_table;
    pub fn st_init_numtable() -> *mut st_table;
    pub fn st_init_numtable_with_size(arg1: st_index_t) -> *mut st_table;
    pub fn st_init_strtable() -> *mut st_table;
    pub fn st_init_strtable_with_size(arg1: st_index_t) -> *mut st_table;
    pub fn st_init_strcasetable() -> *mut st_table;
    pub fn st_init_strcasetable_with_size(arg1: st_index_t) -> *mut st_table;
    pub fn st_delete(arg1: *mut st_table, arg2: *mut st_data_t,
                     arg3: *mut st_data_t) -> ::std::os::raw::c_int;
    pub fn st_delete_safe(arg1: *mut st_table, arg2: *mut st_data_t,
                          arg3: *mut st_data_t, arg4: st_data_t)
     -> ::std::os::raw::c_int;
    pub fn st_shift(arg1: *mut st_table, arg2: *mut st_data_t,
                    arg3: *mut st_data_t) -> ::std::os::raw::c_int;
    pub fn st_insert(arg1: *mut st_table, arg2: st_data_t, arg3: st_data_t)
     -> ::std::os::raw::c_int;
    pub fn st_insert2(arg1: *mut st_table, arg2: st_data_t, arg3: st_data_t,
                      arg4:
                          ::std::option::Option<extern "C" fn(arg1: st_data_t)
                                                    -> st_data_t>)
     -> ::std::os::raw::c_int;
    pub fn st_lookup(arg1: *mut st_table, arg2: st_data_t,
                     arg3: *mut st_data_t) -> ::std::os::raw::c_int;
    pub fn st_get_key(arg1: *mut st_table, arg2: st_data_t,
                      arg3: *mut st_data_t) -> ::std::os::raw::c_int;
    pub fn st_update(table: *mut st_table, key: st_data_t,
                     func:
                         *mut ::std::option::Option<extern "C" fn()
                                                        ->
                                                            ::std::os::raw::c_int>,
                     arg: st_data_t) -> ::std::os::raw::c_int;
    pub fn st_foreach(arg1: *mut st_table,
                      arg2:
                          ::std::option::Option<extern "C" fn()
                                                    -> ::std::os::raw::c_int>,
                      arg3: st_data_t) -> ::std::os::raw::c_int;
    pub fn st_foreach_check(arg1: *mut st_table,
                            arg2:
                                ::std::option::Option<extern "C" fn()
                                                          ->
                                                              ::std::os::raw::c_int>,
                            arg3: st_data_t, arg4: st_data_t)
     -> ::std::os::raw::c_int;
    pub fn st_reverse_foreach(arg1: *mut st_table,
                              arg2:
                                  ::std::option::Option<extern "C" fn()
                                                            ->
                                                                ::std::os::raw::c_int>,
                              arg3: st_data_t) -> ::std::os::raw::c_int;
    pub fn st_keys(table: *mut st_table, keys: *mut st_data_t,
                   size: st_index_t) -> st_index_t;
    pub fn st_keys_check(table: *mut st_table, keys: *mut st_data_t,
                         size: st_index_t, never: st_data_t) -> st_index_t;
    pub fn st_values(table: *mut st_table, values: *mut st_data_t,
                     size: st_index_t) -> st_index_t;
    pub fn st_values_check(table: *mut st_table, values: *mut st_data_t,
                           size: st_index_t, never: st_data_t) -> st_index_t;
    pub fn st_add_direct(arg1: *mut st_table, arg2: st_data_t,
                         arg3: st_data_t);
    pub fn st_free_table(arg1: *mut st_table);
    pub fn st_cleanup_safe(arg1: *mut st_table, arg2: st_data_t);
    pub fn st_clear(arg1: *mut st_table);
    pub fn st_copy(arg1: *mut st_table) -> *mut st_table;
    pub fn st_numcmp(arg1: st_data_t, arg2: st_data_t)
     -> ::std::os::raw::c_int;
    pub fn st_numhash(arg1: st_data_t) -> st_index_t;
    pub fn st_locale_insensitive_strcasecmp(s1: *const ::std::os::raw::c_char,
                                            s2: *const ::std::os::raw::c_char)
     -> ::std::os::raw::c_int;
    pub fn st_locale_insensitive_strncasecmp(s1:
                                                 *const ::std::os::raw::c_char,
                                             s2:
                                                 *const ::std::os::raw::c_char,
                                             n: size_t)
     -> ::std::os::raw::c_int;
    pub fn st_memsize(arg1: *const st_table) -> size_t;
    pub fn st_hash(ptr: *const ::std::os::raw::c_void, len: size_t,
                   h: st_index_t) -> st_index_t;
    pub fn st_hash_uint32(h: st_index_t, i: uint32_t) -> st_index_t;
    pub fn st_hash_uint(h: st_index_t, i: st_index_t) -> st_index_t;
    pub fn st_hash_end(h: st_index_t) -> st_index_t;
    pub fn st_hash_start(h: st_index_t) -> st_index_t;
    pub fn rb_mem_clear(arg1: *mut VALUE, arg2: ::std::os::raw::c_long);
    pub fn rb_assoc_new(arg1: VALUE, arg2: VALUE) -> VALUE;
    pub fn rb_check_array_type(arg1: VALUE) -> VALUE;
    pub fn rb_ary_new() -> VALUE;
    pub fn rb_ary_new_capa(capa: ::std::os::raw::c_long) -> VALUE;
    pub fn rb_ary_new_from_args(n: ::std::os::raw::c_long, ...) -> VALUE;
    pub fn rb_ary_new_from_values(n: ::std::os::raw::c_long,
                                  elts: *const VALUE) -> VALUE;
    pub fn rb_ary_tmp_new(arg1: ::std::os::raw::c_long) -> VALUE;
    pub fn rb_ary_free(arg1: VALUE);
    pub fn rb_ary_modify(arg1: VALUE);
    pub fn rb_ary_freeze(arg1: VALUE) -> VALUE;
    pub fn rb_ary_shared_with_p(arg1: VALUE, arg2: VALUE) -> VALUE;
    pub fn rb_ary_aref(arg1: ::std::os::raw::c_int, arg2: *mut VALUE,
                       arg3: VALUE) -> VALUE;
    pub fn rb_ary_subseq(arg1: VALUE, arg2: ::std::os::raw::c_long,
                         arg3: ::std::os::raw::c_long) -> VALUE;
    pub fn rb_ary_store(arg1: VALUE, arg2: ::std::os::raw::c_long,
                        arg3: VALUE);
    pub fn rb_ary_dup(arg1: VALUE) -> VALUE;
    pub fn rb_ary_resurrect(ary: VALUE) -> VALUE;
    pub fn rb_ary_to_ary(arg1: VALUE) -> VALUE;
    pub fn rb_ary_to_s(arg1: VALUE) -> VALUE;
    pub fn rb_ary_cat(arg1: VALUE, arg2: *const VALUE,
                      arg3: ::std::os::raw::c_long) -> VALUE;
    pub fn rb_ary_push(arg1: VALUE, arg2: VALUE) -> VALUE;
    pub fn rb_ary_pop(arg1: VALUE) -> VALUE;
    pub fn rb_ary_shift(arg1: VALUE) -> VALUE;
    pub fn rb_ary_unshift(arg1: VALUE, arg2: VALUE) -> VALUE;
    pub fn rb_ary_entry(arg1: VALUE, arg2: ::std::os::raw::c_long) -> VALUE;
    pub fn rb_ary_each(arg1: VALUE) -> VALUE;
    pub fn rb_ary_join(arg1: VALUE, arg2: VALUE) -> VALUE;
    pub fn rb_ary_reverse(arg1: VALUE) -> VALUE;
    pub fn rb_ary_rotate(arg1: VALUE, arg2: ::std::os::raw::c_long) -> VALUE;
    pub fn rb_ary_sort(arg1: VALUE) -> VALUE;
    pub fn rb_ary_sort_bang(arg1: VALUE) -> VALUE;
    pub fn rb_ary_delete(arg1: VALUE, arg2: VALUE) -> VALUE;
    pub fn rb_ary_delete_at(arg1: VALUE, arg2: ::std::os::raw::c_long)
     -> VALUE;
    pub fn rb_ary_clear(arg1: VALUE) -> VALUE;
    pub fn rb_ary_plus(arg1: VALUE, arg2: VALUE) -> VALUE;
    pub fn rb_ary_concat(arg1: VALUE, arg2: VALUE) -> VALUE;
    pub fn rb_ary_assoc(arg1: VALUE, arg2: VALUE) -> VALUE;
    pub fn rb_ary_rassoc(arg1: VALUE, arg2: VALUE) -> VALUE;
    pub fn rb_ary_includes(arg1: VALUE, arg2: VALUE) -> VALUE;
    pub fn rb_ary_cmp(arg1: VALUE, arg2: VALUE) -> VALUE;
    pub fn rb_ary_replace(copy: VALUE, orig: VALUE) -> VALUE;
    pub fn rb_get_values_at(arg1: VALUE, arg2: ::std::os::raw::c_long,
                            arg3: ::std::os::raw::c_int, arg4: *mut VALUE,
                            arg5:
                                ::std::option::Option<extern "C" fn(arg1:
                                                                        VALUE,
                                                                    arg2:
                                                                        ::std::os::raw::c_long)
                                                          -> VALUE>) -> VALUE;
    pub fn rb_ary_resize(ary: VALUE, len: ::std::os::raw::c_long) -> VALUE;
    pub fn rb_big_new(arg1: ::std::os::raw::c_long,
                      arg2: ::std::os::raw::c_int) -> VALUE;
    pub fn rb_bigzero_p(x: VALUE) -> ::std::os::raw::c_int;
    pub fn rb_big_clone(arg1: VALUE) -> VALUE;
    pub fn rb_big_2comp(arg1: VALUE);
    pub fn rb_big_norm(arg1: VALUE) -> VALUE;
    pub fn rb_big_resize(big: VALUE, len: ::std::os::raw::c_long);
    pub fn rb_cstr_to_inum(arg1: *const ::std::os::raw::c_char,
                           arg2: ::std::os::raw::c_int,
                           arg3: ::std::os::raw::c_int) -> VALUE;
    pub fn rb_str_to_inum(arg1: VALUE, arg2: ::std::os::raw::c_int,
                          arg3: ::std::os::raw::c_int) -> VALUE;
    pub fn rb_cstr2inum(arg1: *const ::std::os::raw::c_char,
                        arg2: ::std::os::raw::c_int) -> VALUE;
    pub fn rb_str2inum(arg1: VALUE, arg2: ::std::os::raw::c_int) -> VALUE;
    pub fn rb_big2str(arg1: VALUE, arg2: ::std::os::raw::c_int) -> VALUE;
    pub fn rb_big2str0(arg1: VALUE, arg2: ::std::os::raw::c_int,
                       arg3: ::std::os::raw::c_int) -> VALUE;
    pub fn rb_big2long(arg1: VALUE) -> ::std::os::raw::c_long;
    pub fn rb_big2ulong(arg1: VALUE) -> VALUE;
    pub fn rb_big2ulong_pack(x: VALUE) -> VALUE;
    pub fn rb_big2ll(arg1: VALUE) -> ::std::os::raw::c_longlong;
    pub fn rb_big2ull(arg1: VALUE) -> ::std::os::raw::c_ulonglong;
    pub fn rb_quad_pack(arg1: *mut ::std::os::raw::c_char, arg2: VALUE);
    pub fn rb_quad_unpack(arg1: *const ::std::os::raw::c_char,
                          arg2: ::std::os::raw::c_int) -> VALUE;
    pub fn rb_big_pack(val: VALUE, buf: *mut ::std::os::raw::c_ulong,
                       num_longs: ::std::os::raw::c_long);
    pub fn rb_big_unpack(buf: *mut ::std::os::raw::c_ulong,
                         num_longs: ::std::os::raw::c_long) -> VALUE;
    pub fn rb_uv_to_utf8(arg1: *mut ::std::os::raw::c_char,
                         arg2: ::std::os::raw::c_ulong)
     -> ::std::os::raw::c_int;
    pub fn rb_dbl2big(arg1: ::std::os::raw::c_double) -> VALUE;
    pub fn rb_big2dbl(arg1: VALUE) -> ::std::os::raw::c_double;
    pub fn rb_big_cmp(arg1: VALUE, arg2: VALUE) -> VALUE;
    pub fn rb_big_eq(arg1: VALUE, arg2: VALUE) -> VALUE;
    pub fn rb_big_eql(arg1: VALUE, arg2: VALUE) -> VALUE;
    pub fn rb_big_plus(arg1: VALUE, arg2: VALUE) -> VALUE;
    pub fn rb_big_minus(arg1: VALUE, arg2: VALUE) -> VALUE;
    pub fn rb_big_mul(arg1: VALUE, arg2: VALUE) -> VALUE;
    pub fn rb_big_div(arg1: VALUE, arg2: VALUE) -> VALUE;
    pub fn rb_big_idiv(arg1: VALUE, arg2: VALUE) -> VALUE;
    pub fn rb_big_modulo(arg1: VALUE, arg2: VALUE) -> VALUE;
    pub fn rb_big_divmod(arg1: VALUE, arg2: VALUE) -> VALUE;
    pub fn rb_big_pow(arg1: VALUE, arg2: VALUE) -> VALUE;
    pub fn rb_big_and(arg1: VALUE, arg2: VALUE) -> VALUE;
    pub fn rb_big_or(arg1: VALUE, arg2: VALUE) -> VALUE;
    pub fn rb_big_xor(arg1: VALUE, arg2: VALUE) -> VALUE;
    pub fn rb_big_lshift(arg1: VALUE, arg2: VALUE) -> VALUE;
    pub fn rb_big_rshift(arg1: VALUE, arg2: VALUE) -> VALUE;
    pub fn rb_integer_pack(val: VALUE, words: *mut ::std::os::raw::c_void,
                           numwords: size_t, wordsize: size_t, nails: size_t,
                           flags: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
    pub fn rb_integer_unpack(words: *const ::std::os::raw::c_void,
                             numwords: size_t, wordsize: size_t,
                             nails: size_t, flags: ::std::os::raw::c_int)
     -> VALUE;
    pub fn rb_absint_size(val: VALUE,
                          nlz_bits_ret: *mut ::std::os::raw::c_int) -> size_t;
    pub fn rb_absint_numwords(val: VALUE, word_numbits: size_t,
                              nlz_bits_ret: *mut size_t) -> size_t;
    pub fn rb_absint_singlebit_p(val: VALUE) -> ::std::os::raw::c_int;
    pub fn rb_rational_raw(arg1: VALUE, arg2: VALUE) -> VALUE;
    pub fn rb_rational_new(arg1: VALUE, arg2: VALUE) -> VALUE;
    pub fn rb_Rational(arg1: VALUE, arg2: VALUE) -> VALUE;
    pub fn rb_flt_rationalize_with_prec(arg1: VALUE, arg2: VALUE) -> VALUE;
    pub fn rb_flt_rationalize(arg1: VALUE) -> VALUE;
    pub fn rb_complex_raw(arg1: VALUE, arg2: VALUE) -> VALUE;
    pub fn rb_complex_new(arg1: VALUE, arg2: VALUE) -> VALUE;
    pub fn rb_complex_polar(arg1: VALUE, arg2: VALUE) -> VALUE;
    pub fn rb_Complex(arg1: VALUE, arg2: VALUE) -> VALUE;
    pub fn rb_class_boot(arg1: VALUE) -> VALUE;
    pub fn rb_class_new(arg1: VALUE) -> VALUE;
    pub fn rb_mod_init_copy(arg1: VALUE, arg2: VALUE) -> VALUE;
    pub fn rb_singleton_class_clone(arg1: VALUE) -> VALUE;
    pub fn rb_singleton_class_attached(arg1: VALUE, arg2: VALUE);
    pub fn rb_make_metaclass(arg1: VALUE, arg2: VALUE) -> VALUE;
    pub fn rb_check_inheritable(arg1: VALUE);
    pub fn rb_class_inherited(arg1: VALUE, arg2: VALUE) -> VALUE;
    pub fn rb_define_class_id(arg1: ID, arg2: VALUE) -> VALUE;
    pub fn rb_define_class_id_under(arg1: VALUE, arg2: ID, arg3: VALUE)
     -> VALUE;
    pub fn rb_module_new() -> VALUE;
    pub fn rb_define_module_id(arg1: ID) -> VALUE;
    pub fn rb_define_module_id_under(arg1: VALUE, arg2: ID) -> VALUE;
    pub fn rb_include_class_new(arg1: VALUE, arg2: VALUE) -> VALUE;
    pub fn rb_mod_included_modules(arg1: VALUE) -> VALUE;
    pub fn rb_mod_include_p(arg1: VALUE, arg2: VALUE) -> VALUE;
    pub fn rb_mod_ancestors(arg1: VALUE) -> VALUE;
    pub fn rb_class_instance_methods(arg1: ::std::os::raw::c_int,
                                     arg2: *mut VALUE, arg3: VALUE) -> VALUE;
    pub fn rb_class_public_instance_methods(arg1: ::std::os::raw::c_int,
                                            arg2: *mut VALUE, arg3: VALUE)
     -> VALUE;
    pub fn rb_class_protected_instance_methods(arg1: ::std::os::raw::c_int,
                                               arg2: *mut VALUE, arg3: VALUE)
     -> VALUE;
    pub fn rb_class_private_instance_methods(arg1: ::std::os::raw::c_int,
                                             arg2: *mut VALUE, arg3: VALUE)
     -> VALUE;
    pub fn rb_obj_singleton_methods(arg1: ::std::os::raw::c_int,
                                    arg2: *mut VALUE, arg3: VALUE) -> VALUE;
    pub fn rb_define_method_id(arg1: VALUE, arg2: ID,
                               arg3:
                                   ::std::option::Option<extern "C" fn()
                                                             -> VALUE>,
                               arg4: ::std::os::raw::c_int);
    pub fn rb_frozen_class_p(arg1: VALUE);
    pub fn rb_undef(arg1: VALUE, arg2: ID);
    pub fn rb_define_protected_method(arg1: VALUE,
                                      arg2: *const ::std::os::raw::c_char,
                                      arg3:
                                          ::std::option::Option<extern "C" fn()
                                                                    -> VALUE>,
                                      arg4: ::std::os::raw::c_int);
    pub fn rb_define_private_method(arg1: VALUE,
                                    arg2: *const ::std::os::raw::c_char,
                                    arg3:
                                        ::std::option::Option<extern "C" fn()
                                                                  -> VALUE>,
                                    arg4: ::std::os::raw::c_int);
    pub fn rb_define_singleton_method(arg1: VALUE,
                                      arg2: *const ::std::os::raw::c_char,
                                      arg3:
                                          ::std::option::Option<extern "C" fn()
                                                                    -> VALUE>,
                                      arg4: ::std::os::raw::c_int);
    pub fn rb_singleton_class(arg1: VALUE) -> VALUE;
    pub fn rb_cmpint(arg1: VALUE, arg2: VALUE, arg3: VALUE)
     -> ::std::os::raw::c_int;
    pub fn rb_cmperr(arg1: VALUE, arg2: VALUE);
    pub fn rb_fiber_new(arg1: ::std::option::Option<extern "C" fn() -> VALUE>,
                        arg2: VALUE) -> VALUE;
    pub fn rb_fiber_resume(fib: VALUE, argc: ::std::os::raw::c_int,
                           args: *mut VALUE) -> VALUE;
    pub fn rb_fiber_yield(argc: ::std::os::raw::c_int, args: *mut VALUE)
     -> VALUE;
    pub fn rb_fiber_current() -> VALUE;
    pub fn rb_fiber_alive_p(arg1: VALUE) -> VALUE;
    pub fn rb_enum_values_pack(arg1: ::std::os::raw::c_int,
                               arg2: *const VALUE) -> VALUE;
    pub fn rb_enumeratorize(arg1: VALUE, arg2: VALUE,
                            arg3: ::std::os::raw::c_int, arg4: *mut VALUE)
     -> VALUE;
    pub fn rb_enumeratorize_with_size(arg1: VALUE, arg2: VALUE,
                                      arg3: ::std::os::raw::c_int,
                                      arg4: *mut VALUE,
                                      arg5:
                                          *mut ::std::option::Option<extern "C" fn()
                                                                         ->
                                                                             VALUE>)
     -> VALUE;
    pub fn rb_exc_new(arg1: VALUE, arg2: *const ::std::os::raw::c_char,
                      arg3: ::std::os::raw::c_long) -> VALUE;
    pub fn rb_exc_new_cstr(arg1: VALUE, arg2: *const ::std::os::raw::c_char)
     -> VALUE;
    pub fn rb_exc_new_str(arg1: VALUE, arg2: VALUE) -> VALUE;
    pub fn rb_loaderror(arg1: *const ::std::os::raw::c_char, ...);
    pub fn rb_loaderror_with_path(path: VALUE,
                                  arg1: *const ::std::os::raw::c_char, ...);
    pub fn rb_name_error(arg1: ID, arg2: *const ::std::os::raw::c_char, ...);
    pub fn rb_name_error_str(arg1: VALUE,
                             arg2: *const ::std::os::raw::c_char, ...);
    pub fn rb_invalid_str(arg1: *const ::std::os::raw::c_char,
                          arg2: *const ::std::os::raw::c_char);
    pub fn rb_compile_error(arg1: *const ::std::os::raw::c_char,
                            arg2: ::std::os::raw::c_int,
                            arg3: *const ::std::os::raw::c_char, ...);
    pub fn rb_compile_error_with_enc(arg1: *const ::std::os::raw::c_char,
                                     arg2: ::std::os::raw::c_int,
                                     arg3: *mut ::std::os::raw::c_void,
                                     arg4:
                                         *const ::std::os::raw::c_char, ...);
    pub fn rb_compile_error_append(arg1: *const ::std::os::raw::c_char, ...);
    pub fn rb_error_frozen(arg1: *const ::std::os::raw::c_char);
    pub fn rb_error_untrusted(arg1: VALUE);
    pub fn rb_check_frozen(arg1: VALUE);
    pub fn rb_check_trusted(arg1: VALUE);
    pub fn rb_check_copyable(obj: VALUE, orig: VALUE);
    pub fn rb_sourceline() -> ::std::os::raw::c_int;
    pub fn rb_sourcefile() -> *const ::std::os::raw::c_char;
    pub fn rb_check_funcall(arg1: VALUE, arg2: ID,
                            arg3: ::std::os::raw::c_int, arg4: *const VALUE)
     -> VALUE;
    pub fn rb_error_arity(arg1: ::std::os::raw::c_int,
                          arg2: ::std::os::raw::c_int,
                          arg3: ::std::os::raw::c_int);
    pub fn rb_fd_init(arg1: *mut rb_fdset_t);
    pub fn rb_fd_term(arg1: *mut rb_fdset_t);
    pub fn rb_fd_zero(arg1: *mut rb_fdset_t);
    pub fn rb_fd_set(arg1: ::std::os::raw::c_int, arg2: *mut rb_fdset_t);
    pub fn rb_fd_clr(arg1: ::std::os::raw::c_int, arg2: *mut rb_fdset_t);
    pub fn rb_fd_isset(arg1: ::std::os::raw::c_int, arg2: *const rb_fdset_t)
     -> ::std::os::raw::c_int;
    pub fn rb_fd_copy(arg1: *mut rb_fdset_t, arg2: *const fd_set,
                      arg3: ::std::os::raw::c_int);
    pub fn rb_fd_dup(dst: *mut rb_fdset_t, src: *const rb_fdset_t);
    pub fn rb_fd_select(arg1: ::std::os::raw::c_int, arg2: *mut rb_fdset_t,
                        arg3: *mut rb_fdset_t, arg4: *mut rb_fdset_t,
                        arg5: *mut Struct_timeval) -> ::std::os::raw::c_int;
    pub fn rb_exc_raise(arg1: VALUE);
    pub fn rb_exc_fatal(arg1: VALUE);
    pub fn rb_f_exit(arg1: ::std::os::raw::c_int, arg2: *mut VALUE) -> VALUE;
    pub fn rb_f_abort(arg1: ::std::os::raw::c_int, arg2: *mut VALUE) -> VALUE;
    pub fn rb_remove_method(arg1: VALUE, arg2: *const ::std::os::raw::c_char);
    pub fn rb_remove_method_id(arg1: VALUE, arg2: ID);
    pub fn rb_define_alloc_func(arg1: VALUE, arg2: rb_alloc_func_t);
    pub fn rb_undef_alloc_func(arg1: VALUE);
    pub fn rb_get_alloc_func(arg1: VALUE) -> rb_alloc_func_t;
    pub fn rb_clear_cache();
    pub fn rb_clear_constant_cache();
    pub fn rb_clear_method_cache_by_class(arg1: VALUE);
    pub fn rb_alias(arg1: VALUE, arg2: ID, arg3: ID);
    pub fn rb_attr(arg1: VALUE, arg2: ID, arg3: ::std::os::raw::c_int,
                   arg4: ::std::os::raw::c_int, arg5: ::std::os::raw::c_int);
    pub fn rb_method_boundp(arg1: VALUE, arg2: ID,
                            arg3: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
    pub fn rb_method_basic_definition_p(arg1: VALUE, arg2: ID)
     -> ::std::os::raw::c_int;
    pub fn rb_eval_cmd(arg1: VALUE, arg2: VALUE, arg3: ::std::os::raw::c_int)
     -> VALUE;
    pub fn rb_obj_respond_to(arg1: VALUE, arg2: ID,
                             arg3: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
    pub fn rb_respond_to(arg1: VALUE, arg2: ID) -> ::std::os::raw::c_int;
    pub fn rb_f_notimplement(argc: ::std::os::raw::c_int, argv: *mut VALUE,
                             obj: VALUE) -> VALUE;
    pub fn rb_interrupt();
    pub fn rb_apply(arg1: VALUE, arg2: ID, arg3: VALUE) -> VALUE;
    pub fn rb_backtrace();
    pub fn rb_frame_this_func() -> ID;
    pub fn rb_obj_instance_eval(arg1: ::std::os::raw::c_int, arg2: *mut VALUE,
                                arg3: VALUE) -> VALUE;
    pub fn rb_obj_instance_exec(arg1: ::std::os::raw::c_int, arg2: *mut VALUE,
                                arg3: VALUE) -> VALUE;
    pub fn rb_mod_module_eval(arg1: ::std::os::raw::c_int, arg2: *mut VALUE,
                              arg3: VALUE) -> VALUE;
    pub fn rb_mod_module_exec(arg1: ::std::os::raw::c_int, arg2: *mut VALUE,
                              arg3: VALUE) -> VALUE;
    pub fn rb_load(arg1: VALUE, arg2: ::std::os::raw::c_int);
    pub fn rb_load_protect(arg1: VALUE, arg2: ::std::os::raw::c_int,
                           arg3: *mut ::std::os::raw::c_int);
    pub fn rb_jump_tag(arg1: ::std::os::raw::c_int);
    pub fn rb_provided(arg1: *const ::std::os::raw::c_char)
     -> ::std::os::raw::c_int;
    pub fn rb_feature_provided(arg1: *const ::std::os::raw::c_char,
                               arg2: *mut *const ::std::os::raw::c_char)
     -> ::std::os::raw::c_int;
    pub fn rb_provide(arg1: *const ::std::os::raw::c_char);
    pub fn rb_f_require(arg1: VALUE, arg2: VALUE) -> VALUE;
    pub fn rb_require_safe(arg1: VALUE, arg2: ::std::os::raw::c_int) -> VALUE;
    pub fn rb_obj_call_init(arg1: VALUE, arg2: ::std::os::raw::c_int,
                            arg3: *mut VALUE);
    pub fn rb_class_new_instance(arg1: ::std::os::raw::c_int,
                                 arg2: *mut VALUE, arg3: VALUE) -> VALUE;
    pub fn rb_block_proc() -> VALUE;
    pub fn rb_block_lambda() -> VALUE;
    pub fn rb_proc_new(arg1: ::std::option::Option<extern "C" fn() -> VALUE>,
                       arg2: VALUE) -> VALUE;
    pub fn rb_obj_is_proc(arg1: VALUE) -> VALUE;
    pub fn rb_proc_call(arg1: VALUE, arg2: VALUE) -> VALUE;
    pub fn rb_proc_call_with_block(arg1: VALUE, argc: ::std::os::raw::c_int,
                                   argv: *const VALUE, arg2: VALUE) -> VALUE;
    pub fn rb_proc_arity(arg1: VALUE) -> ::std::os::raw::c_int;
    pub fn rb_proc_lambda_p(arg1: VALUE) -> VALUE;
    pub fn rb_binding_new() -> VALUE;
    pub fn rb_obj_method(arg1: VALUE, arg2: VALUE) -> VALUE;
    pub fn rb_obj_is_method(arg1: VALUE) -> VALUE;
    pub fn rb_method_call(arg1: ::std::os::raw::c_int, arg2: *mut VALUE,
                          arg3: VALUE) -> VALUE;
    pub fn rb_method_call_with_block(arg1: ::std::os::raw::c_int,
                                     arg2: *mut VALUE, arg3: VALUE,
                                     arg4: VALUE) -> VALUE;
    pub fn rb_mod_method_arity(arg1: VALUE, arg2: ID)
     -> ::std::os::raw::c_int;
    pub fn rb_obj_method_arity(arg1: VALUE, arg2: ID)
     -> ::std::os::raw::c_int;
    pub fn rb_protect(arg1:
                          ::std::option::Option<extern "C" fn(arg1: VALUE)
                                                    -> VALUE>, arg2: VALUE,
                      arg3: *mut ::std::os::raw::c_int) -> VALUE;
    pub fn rb_set_end_proc(arg1:
                               ::std::option::Option<extern "C" fn(arg1:
                                                                       VALUE)>,
                           arg2: VALUE);
    pub fn rb_exec_end_proc();
    pub fn rb_thread_schedule();
    pub fn rb_thread_wait_fd(arg1: ::std::os::raw::c_int);
    pub fn rb_thread_fd_writable(arg1: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
    pub fn rb_thread_fd_close(arg1: ::std::os::raw::c_int);
    pub fn rb_thread_alone() -> ::std::os::raw::c_int;
    pub fn rb_thread_polling();
    pub fn rb_thread_sleep(arg1: ::std::os::raw::c_int);
    pub fn rb_thread_sleep_forever();
    pub fn rb_thread_sleep_deadly();
    pub fn rb_thread_stop() -> VALUE;
    pub fn rb_thread_wakeup(arg1: VALUE) -> VALUE;
    pub fn rb_thread_wakeup_alive(arg1: VALUE) -> VALUE;
    pub fn rb_thread_run(arg1: VALUE) -> VALUE;
    pub fn rb_thread_kill(arg1: VALUE) -> VALUE;
    pub fn rb_thread_create(arg1:
                                ::std::option::Option<extern "C" fn()
                                                          -> VALUE>,
                            arg2: *mut ::std::os::raw::c_void) -> VALUE;
    pub fn rb_thread_select(arg1: ::std::os::raw::c_int, arg2: *mut fd_set,
                            arg3: *mut fd_set, arg4: *mut fd_set,
                            arg5: *mut Struct_timeval)
     -> ::std::os::raw::c_int;
    pub fn rb_thread_fd_select(arg1: ::std::os::raw::c_int,
                               arg2: *mut rb_fdset_t, arg3: *mut rb_fdset_t,
                               arg4: *mut rb_fdset_t,
                               arg5: *mut Struct_timeval)
     -> ::std::os::raw::c_int;
    pub fn rb_thread_wait_for(arg1: Struct_timeval);
    pub fn rb_thread_current() -> VALUE;
    pub fn rb_thread_main() -> VALUE;
    pub fn rb_thread_local_aref(arg1: VALUE, arg2: ID) -> VALUE;
    pub fn rb_thread_local_aset(arg1: VALUE, arg2: ID, arg3: VALUE) -> VALUE;
    pub fn rb_thread_atfork();
    pub fn rb_thread_atfork_before_exec();
    pub fn rb_exec_recursive(arg1:
                                 ::std::option::Option<extern "C" fn(arg1:
                                                                         VALUE,
                                                                     arg2:
                                                                         VALUE,
                                                                     arg3:
                                                                         ::std::os::raw::c_int)
                                                           -> VALUE>,
                             arg2: VALUE, arg3: VALUE) -> VALUE;
    pub fn rb_exec_recursive_paired(arg1:
                                        ::std::option::Option<extern "C" fn(arg1:
                                                                                VALUE,
                                                                            arg2:
                                                                                VALUE,
                                                                            arg3:
                                                                                ::std::os::raw::c_int)
                                                                  -> VALUE>,
                                    arg2: VALUE, arg3: VALUE, arg4: VALUE)
     -> VALUE;
    pub fn rb_exec_recursive_outer(arg1:
                                       ::std::option::Option<extern "C" fn(arg1:
                                                                               VALUE,
                                                                           arg2:
                                                                               VALUE,
                                                                           arg3:
                                                                               ::std::os::raw::c_int)
                                                                 -> VALUE>,
                                   arg2: VALUE, arg3: VALUE) -> VALUE;
    pub fn rb_exec_recursive_paired_outer(arg1:
                                              ::std::option::Option<extern "C" fn(arg1:
                                                                                      VALUE,
                                                                                  arg2:
                                                                                      VALUE,
                                                                                  arg3:
                                                                                      ::std::os::raw::c_int)
                                                                        ->
                                                                            VALUE>,
                                          arg2: VALUE, arg3: VALUE,
                                          arg4: VALUE) -> VALUE;
    pub fn rb_dir_getwd() -> VALUE;
    pub fn rb_file_s_expand_path(arg1: ::std::os::raw::c_int,
                                 arg2: *mut VALUE) -> VALUE;
    pub fn rb_file_expand_path(arg1: VALUE, arg2: VALUE) -> VALUE;
    pub fn rb_file_s_absolute_path(arg1: ::std::os::raw::c_int,
                                   arg2: *mut VALUE) -> VALUE;
    pub fn rb_file_absolute_path(arg1: VALUE, arg2: VALUE) -> VALUE;
    pub fn rb_file_dirname(fname: VALUE) -> VALUE;
    pub fn rb_find_file_ext_safe(arg1: *mut VALUE,
                                 arg2: *const *const ::std::os::raw::c_char,
                                 arg3: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
    pub fn rb_find_file_safe(arg1: VALUE, arg2: ::std::os::raw::c_int)
     -> VALUE;
    pub fn rb_find_file_ext(arg1: *mut VALUE,
                            arg2: *const *const ::std::os::raw::c_char)
     -> ::std::os::raw::c_int;
    pub fn rb_find_file(arg1: VALUE) -> VALUE;
    pub fn rb_file_directory_p(arg1: VALUE, arg2: VALUE) -> VALUE;
    pub fn rb_str_encode_ospath(arg1: VALUE) -> VALUE;
    pub fn rb_is_absolute_path(arg1: *const ::std::os::raw::c_char)
     -> ::std::os::raw::c_int;
    pub fn rb_memerror();
    pub fn rb_during_gc() -> ::std::os::raw::c_int;
    pub fn rb_gc_mark_locations(arg1: *mut VALUE, arg2: *mut VALUE);
    pub fn rb_mark_tbl(arg1: *mut Struct_st_table);
    pub fn rb_mark_set(arg1: *mut Struct_st_table);
    pub fn rb_mark_hash(arg1: *mut Struct_st_table);
    pub fn rb_gc_mark_maybe(arg1: VALUE);
    pub fn rb_gc_mark(arg1: VALUE);
    pub fn rb_gc_force_recycle(arg1: VALUE);
    pub fn rb_gc();
    pub fn rb_gc_copy_finalizer(arg1: VALUE, arg2: VALUE);
    pub fn rb_gc_finalize_deferred();
    pub fn rb_gc_call_finalizer_at_exit();
    pub fn rb_gc_enable() -> VALUE;
    pub fn rb_gc_disable() -> VALUE;
    pub fn rb_gc_start() -> VALUE;
    pub fn rb_gc_set_params();
    pub fn rb_define_finalizer(arg1: VALUE, arg2: VALUE) -> VALUE;
    pub fn rb_undefine_finalizer(arg1: VALUE) -> VALUE;
    pub fn rb_gc_count() -> size_t;
    pub fn rb_gc_stat(arg1: VALUE) -> size_t;
    pub fn rb_gc_latest_gc_info(arg1: VALUE) -> VALUE;
    pub fn st_foreach_safe(arg1: *mut Struct_st_table,
                           arg2:
                               ::std::option::Option<extern "C" fn()
                                                         ->
                                                             ::std::os::raw::c_int>,
                           arg3: st_data_t);
    pub fn rb_check_hash_type(arg1: VALUE) -> VALUE;
    pub fn rb_hash_foreach(arg1: VALUE,
                           arg2:
                               ::std::option::Option<extern "C" fn()
                                                         ->
                                                             ::std::os::raw::c_int>,
                           arg3: VALUE);
    pub fn rb_hash(arg1: VALUE) -> VALUE;
    pub fn rb_hash_new() -> VALUE;
    pub fn rb_hash_dup(arg1: VALUE) -> VALUE;
    pub fn rb_hash_freeze(arg1: VALUE) -> VALUE;
    pub fn rb_hash_aref(arg1: VALUE, arg2: VALUE) -> VALUE;
    pub fn rb_hash_lookup(arg1: VALUE, arg2: VALUE) -> VALUE;
    pub fn rb_hash_lookup2(arg1: VALUE, arg2: VALUE, arg3: VALUE) -> VALUE;
    pub fn rb_hash_fetch(arg1: VALUE, arg2: VALUE) -> VALUE;
    pub fn rb_hash_aset(arg1: VALUE, arg2: VALUE, arg3: VALUE) -> VALUE;
    pub fn rb_hash_clear(arg1: VALUE) -> VALUE;
    pub fn rb_hash_delete_if(arg1: VALUE) -> VALUE;
    pub fn rb_hash_delete(arg1: VALUE, arg2: VALUE) -> VALUE;
    pub fn rb_hash_set_ifnone(hash: VALUE, ifnone: VALUE) -> VALUE;
    pub fn rb_hash_update_by(hash1: VALUE, hash2: VALUE,
                             func:
                                 *mut ::std::option::Option<extern "C" fn()
                                                                -> VALUE>)
     -> VALUE;
    pub fn rb_hash_tbl(arg1: VALUE) -> *mut Struct_st_table;
    pub fn rb_path_check(arg1: *const ::std::os::raw::c_char)
     -> ::std::os::raw::c_int;
    pub fn rb_env_path_tainted() -> ::std::os::raw::c_int;
    pub fn rb_env_clear() -> VALUE;
    pub fn rb_io_write(arg1: VALUE, arg2: VALUE) -> VALUE;
    pub fn rb_io_gets(arg1: VALUE) -> VALUE;
    pub fn rb_io_getbyte(arg1: VALUE) -> VALUE;
    pub fn rb_io_ungetc(arg1: VALUE, arg2: VALUE) -> VALUE;
    pub fn rb_io_ungetbyte(arg1: VALUE, arg2: VALUE) -> VALUE;
    pub fn rb_io_close(arg1: VALUE) -> VALUE;
    pub fn rb_io_flush(arg1: VALUE) -> VALUE;
    pub fn rb_io_eof(arg1: VALUE) -> VALUE;
    pub fn rb_io_binmode(arg1: VALUE) -> VALUE;
    pub fn rb_io_ascii8bit_binmode(arg1: VALUE) -> VALUE;
    pub fn rb_io_addstr(arg1: VALUE, arg2: VALUE) -> VALUE;
    pub fn rb_io_printf(arg1: ::std::os::raw::c_int, arg2: *mut VALUE,
                        arg3: VALUE) -> VALUE;
    pub fn rb_io_print(arg1: ::std::os::raw::c_int, arg2: *mut VALUE,
                       arg3: VALUE) -> VALUE;
    pub fn rb_io_puts(arg1: ::std::os::raw::c_int, arg2: *mut VALUE,
                      arg3: VALUE) -> VALUE;
    pub fn rb_io_fdopen(arg1: ::std::os::raw::c_int,
                        arg2: ::std::os::raw::c_int,
                        arg3: *const ::std::os::raw::c_char) -> VALUE;
    pub fn rb_io_get_io(arg1: VALUE) -> VALUE;
    pub fn rb_file_open(arg1: *const ::std::os::raw::c_char,
                        arg2: *const ::std::os::raw::c_char) -> VALUE;
    pub fn rb_file_open_str(arg1: VALUE, arg2: *const ::std::os::raw::c_char)
     -> VALUE;
    pub fn rb_gets() -> VALUE;
    pub fn rb_write_error(arg1: *const ::std::os::raw::c_char);
    pub fn rb_write_error2(arg1: *const ::std::os::raw::c_char,
                           arg2: ::std::os::raw::c_long);
    pub fn rb_close_before_exec(lowfd: ::std::os::raw::c_int,
                                maxhint: ::std::os::raw::c_int,
                                noclose_fds: VALUE);
    pub fn rb_pipe(pipes: *mut ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
    pub fn rb_reserved_fd_p(fd: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
    pub fn rb_cloexec_open(pathname: *const ::std::os::raw::c_char,
                           flags: ::std::os::raw::c_int, mode: mode_t)
     -> ::std::os::raw::c_int;
    pub fn rb_cloexec_dup(oldfd: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
    pub fn rb_cloexec_dup2(oldfd: ::std::os::raw::c_int,
                           newfd: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
    pub fn rb_cloexec_pipe(fildes: *mut ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
    pub fn rb_cloexec_fcntl_dupfd(fd: ::std::os::raw::c_int,
                                  minfd: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
    pub fn rb_update_max_fd(fd: ::std::os::raw::c_int);
    pub fn rb_fd_fix_cloexec(fd: ::std::os::raw::c_int);
    pub fn rb_marshal_dump(arg1: VALUE, arg2: VALUE) -> VALUE;
    pub fn rb_marshal_load(arg1: VALUE) -> VALUE;
    pub fn rb_marshal_define_compat(newclass: VALUE, oldclass: VALUE,
                                    dumper:
                                        ::std::option::Option<extern "C" fn(arg1:
                                                                                VALUE)
                                                                  -> VALUE>,
                                    loader:
                                        ::std::option::Option<extern "C" fn(arg1:
                                                                                VALUE,
                                                                            arg2:
                                                                                VALUE)
                                                                  -> VALUE>);
    pub fn rb_num_zerodiv();
    pub fn rb_num_coerce_bin(arg1: VALUE, arg2: VALUE, arg3: ID) -> VALUE;
    pub fn rb_num_coerce_cmp(arg1: VALUE, arg2: VALUE, arg3: ID) -> VALUE;
    pub fn rb_num_coerce_relop(arg1: VALUE, arg2: VALUE, arg3: ID) -> VALUE;
    pub fn rb_num_coerce_bit(arg1: VALUE, arg2: VALUE, arg3: ID) -> VALUE;
    pub fn rb_num2fix(arg1: VALUE) -> VALUE;
    pub fn rb_fix2str(arg1: VALUE, arg2: ::std::os::raw::c_int) -> VALUE;
    pub fn rb_dbl_cmp(arg1: ::std::os::raw::c_double,
                      arg2: ::std::os::raw::c_double) -> VALUE;
    pub fn rb_eql(arg1: VALUE, arg2: VALUE) -> ::std::os::raw::c_int;
    pub fn rb_any_to_s(arg1: VALUE) -> VALUE;
    pub fn rb_inspect(arg1: VALUE) -> VALUE;
    pub fn rb_obj_is_instance_of(arg1: VALUE, arg2: VALUE) -> VALUE;
    pub fn rb_obj_is_kind_of(arg1: VALUE, arg2: VALUE) -> VALUE;
    pub fn rb_obj_alloc(arg1: VALUE) -> VALUE;
    pub fn rb_obj_clone(arg1: VALUE) -> VALUE;
    pub fn rb_obj_dup(arg1: VALUE) -> VALUE;
    pub fn rb_obj_init_copy(arg1: VALUE, arg2: VALUE) -> VALUE;
    pub fn rb_obj_taint(arg1: VALUE) -> VALUE;
    pub fn rb_obj_tainted(arg1: VALUE) -> VALUE;
    pub fn rb_obj_untaint(arg1: VALUE) -> VALUE;
    pub fn rb_obj_untrust(arg1: VALUE) -> VALUE;
    pub fn rb_obj_untrusted(arg1: VALUE) -> VALUE;
    pub fn rb_obj_trust(arg1: VALUE) -> VALUE;
    pub fn rb_obj_freeze(arg1: VALUE) -> VALUE;
    pub fn rb_obj_frozen_p(arg1: VALUE) -> VALUE;
    pub fn rb_obj_id(arg1: VALUE) -> VALUE;
    pub fn rb_obj_class(arg1: VALUE) -> VALUE;
    pub fn rb_class_real(arg1: VALUE) -> VALUE;
    pub fn rb_class_inherited_p(arg1: VALUE, arg2: VALUE) -> VALUE;
    pub fn rb_class_superclass(arg1: VALUE) -> VALUE;
    pub fn rb_class_get_superclass(arg1: VALUE) -> VALUE;
    pub fn rb_convert_type(arg1: VALUE, arg2: ::std::os::raw::c_int,
                           arg3: *const ::std::os::raw::c_char,
                           arg4: *const ::std::os::raw::c_char) -> VALUE;
    pub fn rb_check_convert_type(arg1: VALUE, arg2: ::std::os::raw::c_int,
                                 arg3: *const ::std::os::raw::c_char,
                                 arg4: *const ::std::os::raw::c_char)
     -> VALUE;
    pub fn rb_check_to_integer(arg1: VALUE,
                               arg2: *const ::std::os::raw::c_char) -> VALUE;
    pub fn rb_check_to_float(arg1: VALUE) -> VALUE;
    pub fn rb_to_int(arg1: VALUE) -> VALUE;
    pub fn rb_check_to_int(arg1: VALUE) -> VALUE;
    pub fn rb_Integer(arg1: VALUE) -> VALUE;
    pub fn rb_to_float(arg1: VALUE) -> VALUE;
    pub fn rb_Float(arg1: VALUE) -> VALUE;
    pub fn rb_String(arg1: VALUE) -> VALUE;
    pub fn rb_Array(arg1: VALUE) -> VALUE;
    pub fn rb_Hash(arg1: VALUE) -> VALUE;
    pub fn rb_cstr_to_dbl(arg1: *const ::std::os::raw::c_char,
                          arg2: ::std::os::raw::c_int)
     -> ::std::os::raw::c_double;
    pub fn rb_str_to_dbl(arg1: VALUE, arg2: ::std::os::raw::c_int)
     -> ::std::os::raw::c_double;
    pub fn rb_id_attrset(arg1: ID) -> ID;
    pub fn rb_is_const_id(arg1: ID) -> ::std::os::raw::c_int;
    pub fn rb_is_global_id(arg1: ID) -> ::std::os::raw::c_int;
    pub fn rb_is_instance_id(arg1: ID) -> ::std::os::raw::c_int;
    pub fn rb_is_attrset_id(arg1: ID) -> ::std::os::raw::c_int;
    pub fn rb_is_class_id(arg1: ID) -> ::std::os::raw::c_int;
    pub fn rb_is_local_id(arg1: ID) -> ::std::os::raw::c_int;
    pub fn rb_is_junk_id(arg1: ID) -> ::std::os::raw::c_int;
    pub fn rb_symname_p(arg1: *const ::std::os::raw::c_char)
     -> ::std::os::raw::c_int;
    pub fn rb_sym_interned_p(arg1: VALUE) -> ::std::os::raw::c_int;
    pub fn rb_backref_get() -> VALUE;
    pub fn rb_backref_set(arg1: VALUE);
    pub fn rb_lastline_get() -> VALUE;
    pub fn rb_lastline_set(arg1: VALUE);
    pub fn rb_sym_all_symbols() -> VALUE;
    pub fn rb_last_status_set(status: ::std::os::raw::c_int, pid: pid_t);
    pub fn rb_last_status_get() -> VALUE;
    pub fn rb_proc_exec_n(arg1: ::std::os::raw::c_int, arg2: *mut VALUE,
                          arg3: *const ::std::os::raw::c_char)
     -> ::std::os::raw::c_int;
    pub fn rb_proc_exec(arg1: *const ::std::os::raw::c_char)
     -> ::std::os::raw::c_int;
    pub fn rb_exec_arg_init(argc: ::std::os::raw::c_int, argv: *mut VALUE,
                            accept_shell: ::std::os::raw::c_int,
                            e: *mut Struct_rb_exec_arg) -> VALUE;
    pub fn rb_exec_arg_addopt(e: *mut Struct_rb_exec_arg, key: VALUE,
                              val: VALUE) -> ::std::os::raw::c_int;
    pub fn rb_exec_arg_fixup(e: *mut Struct_rb_exec_arg);
    pub fn rb_run_exec_options(e: *const Struct_rb_exec_arg,
                               s: *mut Struct_rb_exec_arg)
     -> ::std::os::raw::c_int;
    pub fn rb_run_exec_options_err(e: *const Struct_rb_exec_arg,
                                   s: *mut Struct_rb_exec_arg,
                                   arg1: *mut ::std::os::raw::c_char,
                                   arg2: size_t) -> ::std::os::raw::c_int;
    pub fn rb_exec(arg1: *const Struct_rb_exec_arg) -> ::std::os::raw::c_int;
    pub fn rb_exec_err(arg1: *const Struct_rb_exec_arg,
                       arg2: *mut ::std::os::raw::c_char, arg3: size_t)
     -> ::std::os::raw::c_int;
    pub fn rb_fork(arg1: *mut ::std::os::raw::c_int,
                   arg2:
                       ::std::option::Option<unsafe extern "C" fn(arg1:
                                                                      *mut ::std::os::raw::c_void)
                                                 -> ::std::os::raw::c_int>,
                   arg3: *mut ::std::os::raw::c_void, arg4: VALUE) -> pid_t;
    pub fn rb_fork_err(arg1: *mut ::std::os::raw::c_int,
                       arg2:
                           ::std::option::Option<unsafe extern "C" fn(arg1:
                                                                          *mut ::std::os::raw::c_void,
                                                                      arg2:
                                                                          *mut ::std::os::raw::c_char,
                                                                      arg3:
                                                                          size_t)
                                                     ->
                                                         ::std::os::raw::c_int>,
                       arg3: *mut ::std::os::raw::c_void, arg4: VALUE,
                       arg5: *mut ::std::os::raw::c_char, arg6: size_t)
     -> pid_t;
    pub fn rb_f_exec(arg1: ::std::os::raw::c_int, arg2: *mut VALUE) -> VALUE;
    pub fn rb_waitpid(pid: pid_t, status: *mut ::std::os::raw::c_int,
                      flags: ::std::os::raw::c_int) -> pid_t;
    pub fn rb_syswait(pid: pid_t);
    pub fn rb_spawn(arg1: ::std::os::raw::c_int, arg2: *mut VALUE) -> pid_t;
    pub fn rb_spawn_err(arg1: ::std::os::raw::c_int, arg2: *mut VALUE,
                        arg3: *mut ::std::os::raw::c_char, arg4: size_t)
     -> pid_t;
    pub fn rb_proc_times(arg1: VALUE) -> VALUE;
    pub fn rb_detach_process(pid: pid_t) -> VALUE;
    pub fn rb_range_new(arg1: VALUE, arg2: VALUE, arg3: ::std::os::raw::c_int)
     -> VALUE;
    pub fn rb_range_beg_len(arg1: VALUE, arg2: *mut ::std::os::raw::c_long,
                            arg3: *mut ::std::os::raw::c_long,
                            arg4: ::std::os::raw::c_long,
                            arg5: ::std::os::raw::c_int) -> VALUE;
    pub fn rb_range_values(range: VALUE, begp: *mut VALUE, endp: *mut VALUE,
                           exclp: *mut ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
    pub fn rb_genrand_int32() -> ::std::os::raw::c_uint;
    pub fn rb_genrand_real() -> ::std::os::raw::c_double;
    pub fn rb_reset_random_seed();
    pub fn rb_random_bytes(rnd: VALUE, n: ::std::os::raw::c_long) -> VALUE;
    pub fn rb_random_int(rnd: VALUE, max: VALUE) -> VALUE;
    pub fn rb_random_int32(rnd: VALUE) -> ::std::os::raw::c_uint;
    pub fn rb_random_real(rnd: VALUE) -> ::std::os::raw::c_double;
    pub fn rb_random_ulong_limited(rnd: VALUE, limit: ::std::os::raw::c_ulong)
     -> ::std::os::raw::c_ulong;
    pub fn rb_genrand_ulong_limited(i: ::std::os::raw::c_ulong)
     -> ::std::os::raw::c_ulong;
    pub fn rb_memcicmp(arg1: *const ::std::os::raw::c_void,
                       arg2: *const ::std::os::raw::c_void,
                       arg3: ::std::os::raw::c_long) -> ::std::os::raw::c_int;
    pub fn rb_match_busy(arg1: VALUE);
    pub fn rb_reg_nth_defined(arg1: ::std::os::raw::c_int, arg2: VALUE)
     -> VALUE;
    pub fn rb_reg_nth_match(arg1: ::std::os::raw::c_int, arg2: VALUE)
     -> VALUE;
    pub fn rb_reg_backref_number(_match: VALUE, backref: VALUE)
     -> ::std::os::raw::c_int;
    pub fn rb_reg_last_match(arg1: VALUE) -> VALUE;
    pub fn rb_reg_match_pre(arg1: VALUE) -> VALUE;
    pub fn rb_reg_match_post(arg1: VALUE) -> VALUE;
    pub fn rb_reg_match_last(arg1: VALUE) -> VALUE;
    pub fn rb_reg_new_str(arg1: VALUE, arg2: ::std::os::raw::c_int) -> VALUE;
    pub fn rb_reg_new(arg1: *const ::std::os::raw::c_char,
                      arg2: ::std::os::raw::c_long,
                      arg3: ::std::os::raw::c_int) -> VALUE;
    pub fn rb_reg_alloc() -> VALUE;
    pub fn rb_reg_init_str(re: VALUE, s: VALUE,
                           options: ::std::os::raw::c_int) -> VALUE;
    pub fn rb_reg_match(arg1: VALUE, arg2: VALUE) -> VALUE;
    pub fn rb_reg_match2(arg1: VALUE) -> VALUE;
    pub fn rb_reg_options(arg1: VALUE) -> ::std::os::raw::c_int;
    pub fn rb_get_argv() -> VALUE;
    pub fn rb_load_file(arg1: *const ::std::os::raw::c_char)
     -> *mut ::std::os::raw::c_void;
    pub fn rb_load_file_str(arg1: VALUE) -> *mut ::std::os::raw::c_void;
    pub fn rb_f_kill(arg1: ::std::os::raw::c_int, arg2: *mut VALUE) -> VALUE;
    pub fn ruby_posix_signal(arg1: ::std::os::raw::c_int,
                             arg2:
                                 ::std::option::Option<extern "C" fn(arg1:
                                                                         ::std::os::raw::c_int)>)
     ->
         ::std::option::Option<extern "C" fn(arg1: ::std::os::raw::c_int,
                                             arg2:
                                                 ::std::option::Option<extern "C" fn(arg1:
                                                                                         ::std::os::raw::c_int)>)>;
    pub fn rb_trap_exit();
    pub fn rb_trap_exec();
    pub fn ruby_signal_name(arg1: ::std::os::raw::c_int)
     -> *const ::std::os::raw::c_char;
    pub fn ruby_default_signal(arg1: ::std::os::raw::c_int);
    pub fn rb_f_sprintf(arg1: ::std::os::raw::c_int, arg2: *const VALUE)
     -> VALUE;
    pub fn rb_sprintf(arg1: *const ::std::os::raw::c_char, ...) -> VALUE;
    pub fn rb_vsprintf(arg1: *const ::std::os::raw::c_char, arg2: va_list)
     -> VALUE;
    pub fn rb_str_catf(arg1: VALUE, arg2: *const ::std::os::raw::c_char, ...)
     -> VALUE;
    pub fn rb_str_vcatf(arg1: VALUE, arg2: *const ::std::os::raw::c_char,
                        arg3: va_list) -> VALUE;
    pub fn rb_str_format(arg1: ::std::os::raw::c_int, arg2: *const VALUE,
                         arg3: VALUE) -> VALUE;
    pub fn rb_str_new(arg1: *const ::std::os::raw::c_char,
                      arg2: ::std::os::raw::c_long) -> VALUE;
    pub fn rb_str_new_cstr(arg1: *const ::std::os::raw::c_char) -> VALUE;
    pub fn rb_str_new_shared(arg1: VALUE) -> VALUE;
    pub fn rb_str_new_frozen(arg1: VALUE) -> VALUE;
    pub fn rb_str_new_with_class(arg1: VALUE,
                                 arg2: *const ::std::os::raw::c_char,
                                 arg3: ::std::os::raw::c_long) -> VALUE;
    pub fn rb_tainted_str_new_cstr(arg1: *const ::std::os::raw::c_char)
     -> VALUE;
    pub fn rb_tainted_str_new(arg1: *const ::std::os::raw::c_char,
                              arg2: ::std::os::raw::c_long) -> VALUE;
    pub fn rb_external_str_new(arg1: *const ::std::os::raw::c_char,
                               arg2: ::std::os::raw::c_long) -> VALUE;
    pub fn rb_external_str_new_cstr(arg1: *const ::std::os::raw::c_char)
     -> VALUE;
    pub fn rb_locale_str_new(arg1: *const ::std::os::raw::c_char,
                             arg2: ::std::os::raw::c_long) -> VALUE;
    pub fn rb_locale_str_new_cstr(arg1: *const ::std::os::raw::c_char)
     -> VALUE;
    pub fn rb_filesystem_str_new(arg1: *const ::std::os::raw::c_char,
                                 arg2: ::std::os::raw::c_long) -> VALUE;
    pub fn rb_filesystem_str_new_cstr(arg1: *const ::std::os::raw::c_char)
     -> VALUE;
    pub fn rb_str_buf_new(arg1: ::std::os::raw::c_long) -> VALUE;
    pub fn rb_str_buf_new_cstr(arg1: *const ::std::os::raw::c_char) -> VALUE;
    pub fn rb_str_buf_new2(arg1: *const ::std::os::raw::c_char) -> VALUE;
    pub fn rb_str_tmp_new(arg1: ::std::os::raw::c_long) -> VALUE;
    pub fn rb_usascii_str_new(arg1: *const ::std::os::raw::c_char,
                              arg2: ::std::os::raw::c_long) -> VALUE;
    pub fn rb_usascii_str_new_cstr(arg1: *const ::std::os::raw::c_char)
     -> VALUE;
    pub fn rb_str_free(arg1: VALUE);
    pub fn rb_str_shared_replace(arg1: VALUE, arg2: VALUE);
    pub fn rb_str_buf_append(arg1: VALUE, arg2: VALUE) -> VALUE;
    pub fn rb_str_buf_cat(arg1: VALUE, arg2: *const ::std::os::raw::c_char,
                          arg3: ::std::os::raw::c_long) -> VALUE;
    pub fn rb_str_buf_cat2(arg1: VALUE, arg2: *const ::std::os::raw::c_char)
     -> VALUE;
    pub fn rb_str_buf_cat_ascii(arg1: VALUE,
                                arg2: *const ::std::os::raw::c_char) -> VALUE;
    pub fn rb_obj_as_string(arg1: VALUE) -> VALUE;
    pub fn rb_check_string_type(arg1: VALUE) -> VALUE;
    pub fn rb_must_asciicompat(arg1: VALUE);
    pub fn rb_str_dup(arg1: VALUE) -> VALUE;
    pub fn rb_str_resurrect(str: VALUE) -> VALUE;
    pub fn rb_str_locktmp(arg1: VALUE) -> VALUE;
    pub fn rb_str_unlocktmp(arg1: VALUE) -> VALUE;
    pub fn rb_str_dup_frozen(arg1: VALUE) -> VALUE;
    pub fn rb_str_plus(arg1: VALUE, arg2: VALUE) -> VALUE;
    pub fn rb_str_times(arg1: VALUE, arg2: VALUE) -> VALUE;
    pub fn rb_str_sublen(arg1: VALUE, arg2: ::std::os::raw::c_long)
     -> ::std::os::raw::c_long;
    pub fn rb_str_substr(arg1: VALUE, arg2: ::std::os::raw::c_long,
                         arg3: ::std::os::raw::c_long) -> VALUE;
    pub fn rb_str_subseq(arg1: VALUE, arg2: ::std::os::raw::c_long,
                         arg3: ::std::os::raw::c_long) -> VALUE;
    pub fn rb_str_subpos(arg1: VALUE, arg2: ::std::os::raw::c_long,
                         arg3: *mut ::std::os::raw::c_long)
     -> *mut ::std::os::raw::c_char;
    pub fn rb_str_modify(arg1: VALUE);
    pub fn rb_str_modify_expand(arg1: VALUE, arg2: ::std::os::raw::c_long);
    pub fn rb_str_freeze(arg1: VALUE) -> VALUE;
    pub fn rb_str_set_len(arg1: VALUE, arg2: ::std::os::raw::c_long);
    pub fn rb_str_resize(arg1: VALUE, arg2: ::std::os::raw::c_long) -> VALUE;
    pub fn rb_str_cat(arg1: VALUE, arg2: *const ::std::os::raw::c_char,
                      arg3: ::std::os::raw::c_long) -> VALUE;
    pub fn rb_str_cat2(arg1: VALUE, arg2: *const ::std::os::raw::c_char)
     -> VALUE;
    pub fn rb_str_append(arg1: VALUE, arg2: VALUE) -> VALUE;
    pub fn rb_str_concat(arg1: VALUE, arg2: VALUE) -> VALUE;
    pub fn rb_memhash(ptr: *const ::std::os::raw::c_void,
                      len: ::std::os::raw::c_long) -> st_index_t;
    pub fn rb_hash_start(arg1: st_index_t) -> st_index_t;
    pub fn rb_hash_uint32(arg1: st_index_t, arg2: uint32_t) -> st_index_t;
    pub fn rb_hash_uint(arg1: st_index_t, arg2: st_index_t) -> st_index_t;
    pub fn rb_hash_end(arg1: st_index_t) -> st_index_t;
    pub fn rb_str_hash(arg1: VALUE) -> st_index_t;
    pub fn rb_str_hash_cmp(arg1: VALUE, arg2: VALUE) -> ::std::os::raw::c_int;
    pub fn rb_str_comparable(arg1: VALUE, arg2: VALUE)
     -> ::std::os::raw::c_int;
    pub fn rb_str_cmp(arg1: VALUE, arg2: VALUE) -> ::std::os::raw::c_int;
    pub fn rb_str_equal(str1: VALUE, str2: VALUE) -> VALUE;
    pub fn rb_str_drop_bytes(arg1: VALUE, arg2: ::std::os::raw::c_long)
     -> VALUE;
    pub fn rb_str_update(arg1: VALUE, arg2: ::std::os::raw::c_long,
                         arg3: ::std::os::raw::c_long, arg4: VALUE);
    pub fn rb_str_replace(arg1: VALUE, arg2: VALUE) -> VALUE;
    pub fn rb_str_inspect(arg1: VALUE) -> VALUE;
    pub fn rb_str_dump(arg1: VALUE) -> VALUE;
    pub fn rb_str_split(arg1: VALUE, arg2: *const ::std::os::raw::c_char)
     -> VALUE;
    pub fn rb_str_associate(arg1: VALUE, arg2: VALUE);
    pub fn rb_str_associated(arg1: VALUE) -> VALUE;
    pub fn rb_str_setter(arg1: VALUE, arg2: ID, arg3: *mut VALUE);
    pub fn rb_str_intern(arg1: VALUE) -> VALUE;
    pub fn rb_sym_to_s(arg1: VALUE) -> VALUE;
    pub fn rb_str_strlen(arg1: VALUE) -> ::std::os::raw::c_long;
    pub fn rb_str_length(arg1: VALUE) -> VALUE;
    pub fn rb_str_offset(arg1: VALUE, arg2: ::std::os::raw::c_long)
     -> ::std::os::raw::c_long;
    pub fn rb_str_capacity(arg1: VALUE) -> size_t;
    pub fn rb_str_ellipsize(arg1: VALUE, arg2: ::std::os::raw::c_long)
     -> VALUE;
    pub fn rb_str_scrub(arg1: VALUE, arg2: VALUE) -> VALUE;
    pub fn rb_struct_new(arg1: VALUE, ...) -> VALUE;
    pub fn rb_struct_define(arg1: *const ::std::os::raw::c_char, ...)
     -> VALUE;
    pub fn rb_struct_define_under(arg1: VALUE,
                                  arg2: *const ::std::os::raw::c_char, ...)
     -> VALUE;
    pub fn rb_struct_alloc(arg1: VALUE, arg2: VALUE) -> VALUE;
    pub fn rb_struct_initialize(arg1: VALUE, arg2: VALUE) -> VALUE;
    pub fn rb_struct_aref(arg1: VALUE, arg2: VALUE) -> VALUE;
    pub fn rb_struct_aset(arg1: VALUE, arg2: VALUE, arg3: VALUE) -> VALUE;
    pub fn rb_struct_getmember(arg1: VALUE, arg2: ID) -> VALUE;
    pub fn rb_struct_iv_get(arg1: VALUE, arg2: *const ::std::os::raw::c_char)
     -> VALUE;
    pub fn rb_struct_s_members(arg1: VALUE) -> VALUE;
    pub fn rb_struct_members(arg1: VALUE) -> VALUE;
    pub fn rb_struct_alloc_noinit(arg1: VALUE) -> VALUE;
    pub fn rb_struct_define_without_accessor(arg1:
                                                 *const ::std::os::raw::c_char,
                                             arg2: VALUE,
                                             arg3: rb_alloc_func_t, ...)
     -> VALUE;
    pub fn rb_struct_define_without_accessor_under(outer: VALUE,
                                                   class_name:
                                                       *const ::std::os::raw::c_char,
                                                   _super: VALUE,
                                                   alloc:
                                                       rb_alloc_func_t, ...)
     -> VALUE;
    pub fn rb_thread_check_ints();
    pub fn rb_thread_interrupted(thval: VALUE) -> ::std::os::raw::c_int;
    pub fn rb_thread_blocking_region(func:
                                         *mut ::std::option::Option<extern "C" fn()
                                                                        ->
                                                                            VALUE>,
                                     data1: *mut ::std::os::raw::c_void,
                                     ubf:
                                         *mut ::std::option::Option<extern "C" fn()>,
                                     data2: *mut ::std::os::raw::c_void)
     -> VALUE;
    pub fn rb_mutex_new() -> VALUE;
    pub fn rb_mutex_locked_p(mutex: VALUE) -> VALUE;
    pub fn rb_mutex_trylock(mutex: VALUE) -> VALUE;
    pub fn rb_mutex_lock(mutex: VALUE) -> VALUE;
    pub fn rb_mutex_unlock(mutex: VALUE) -> VALUE;
    pub fn rb_mutex_sleep(_self: VALUE, timeout: VALUE) -> VALUE;
    pub fn rb_mutex_synchronize(mutex: VALUE,
                                func:
                                    ::std::option::Option<extern "C" fn(arg:
                                                                            VALUE)
                                                              -> VALUE>,
                                arg: VALUE) -> VALUE;
    pub fn rb_time_new(arg1: time_t, arg2: ::std::os::raw::c_long) -> VALUE;
    pub fn rb_time_nano_new(arg1: time_t, arg2: ::std::os::raw::c_long)
     -> VALUE;
    pub fn rb_time_num_new(arg1: VALUE, arg2: VALUE) -> VALUE;
    pub fn rb_time_interval(num: VALUE) -> Struct_timeval;
    pub fn rb_time_timeval(arg1: VALUE) -> Struct_timeval;
    pub fn rb_time_timespec(time: VALUE) -> Struct_timespec;
    pub fn rb_mod_name(arg1: VALUE) -> VALUE;
    pub fn rb_class_path(arg1: VALUE) -> VALUE;
    pub fn rb_class_path_cached(arg1: VALUE) -> VALUE;
    pub fn rb_set_class_path(arg1: VALUE, arg2: VALUE,
                             arg3: *const ::std::os::raw::c_char);
    pub fn rb_set_class_path_string(arg1: VALUE, arg2: VALUE, arg3: VALUE);
    pub fn rb_path_to_class(arg1: VALUE) -> VALUE;
    pub fn rb_path2class(arg1: *const ::std::os::raw::c_char) -> VALUE;
    pub fn rb_name_class(arg1: VALUE, arg2: ID);
    pub fn rb_class_name(arg1: VALUE) -> VALUE;
    pub fn rb_autoload(arg1: VALUE, arg2: ID,
                       arg3: *const ::std::os::raw::c_char);
    pub fn rb_autoload_load(arg1: VALUE, arg2: ID) -> VALUE;
    pub fn rb_autoload_p(arg1: VALUE, arg2: ID) -> VALUE;
    pub fn rb_f_trace_var(arg1: ::std::os::raw::c_int, arg2: *mut VALUE)
     -> VALUE;
    pub fn rb_f_untrace_var(arg1: ::std::os::raw::c_int, arg2: *mut VALUE)
     -> VALUE;
    pub fn rb_f_global_variables() -> VALUE;
    pub fn rb_alias_variable(arg1: ID, arg2: ID);
    pub fn rb_generic_ivar_table(arg1: VALUE) -> *mut Struct_st_table;
    pub fn rb_copy_generic_ivar(arg1: VALUE, arg2: VALUE);
    pub fn rb_free_generic_ivar(arg1: VALUE);
    pub fn rb_ivar_get(arg1: VALUE, arg2: ID) -> VALUE;
    pub fn rb_ivar_set(arg1: VALUE, arg2: ID, arg3: VALUE) -> VALUE;
    pub fn rb_ivar_defined(arg1: VALUE, arg2: ID) -> VALUE;
    pub fn rb_ivar_foreach(arg1: VALUE,
                           arg2:
                               ::std::option::Option<extern "C" fn()
                                                         ->
                                                             ::std::os::raw::c_int>,
                           arg3: st_data_t);
    pub fn rb_ivar_count(arg1: VALUE) -> st_index_t;
    pub fn rb_attr_get(arg1: VALUE, arg2: ID) -> VALUE;
    pub fn rb_obj_instance_variables(arg1: VALUE) -> VALUE;
    pub fn rb_obj_remove_instance_variable(arg1: VALUE, arg2: VALUE) -> VALUE;
    pub fn rb_mod_const_at(arg1: VALUE, arg2: *mut ::std::os::raw::c_void)
     -> *mut ::std::os::raw::c_void;
    pub fn rb_mod_const_of(arg1: VALUE, arg2: *mut ::std::os::raw::c_void)
     -> *mut ::std::os::raw::c_void;
    pub fn rb_const_list(arg1: *mut ::std::os::raw::c_void) -> VALUE;
    pub fn rb_mod_constants(arg1: ::std::os::raw::c_int, arg2: *mut VALUE,
                            arg3: VALUE) -> VALUE;
    pub fn rb_mod_remove_const(arg1: VALUE, arg2: VALUE) -> VALUE;
    pub fn rb_const_defined(arg1: VALUE, arg2: ID) -> ::std::os::raw::c_int;
    pub fn rb_const_defined_at(arg1: VALUE, arg2: ID)
     -> ::std::os::raw::c_int;
    pub fn rb_const_defined_from(arg1: VALUE, arg2: ID)
     -> ::std::os::raw::c_int;
    pub fn rb_const_get(arg1: VALUE, arg2: ID) -> VALUE;
    pub fn rb_const_get_at(arg1: VALUE, arg2: ID) -> VALUE;
    pub fn rb_const_get_from(arg1: VALUE, arg2: ID) -> VALUE;
    pub fn rb_const_set(arg1: VALUE, arg2: ID, arg3: VALUE);
    pub fn rb_const_remove(arg1: VALUE, arg2: ID) -> VALUE;
    pub fn rb_mod_const_missing(arg1: VALUE, arg2: VALUE) -> VALUE;
    pub fn rb_cvar_defined(arg1: VALUE, arg2: ID) -> VALUE;
    pub fn rb_cvar_set(arg1: VALUE, arg2: ID, arg3: VALUE);
    pub fn rb_cvar_get(arg1: VALUE, arg2: ID) -> VALUE;
    pub fn rb_cv_set(arg1: VALUE, arg2: *const ::std::os::raw::c_char,
                     arg3: VALUE);
    pub fn rb_cv_get(arg1: VALUE, arg2: *const ::std::os::raw::c_char)
     -> VALUE;
    pub fn rb_define_class_variable(arg1: VALUE,
                                    arg2: *const ::std::os::raw::c_char,
                                    arg3: VALUE);
    pub fn rb_mod_class_variables(arg1: ::std::os::raw::c_int,
                                  arg2: *mut VALUE, arg3: VALUE) -> VALUE;
    pub fn rb_mod_remove_cvar(arg1: VALUE, arg2: VALUE) -> VALUE;
    pub fn rb_frame_callee() -> ID;
    pub fn rb_str_succ(arg1: VALUE) -> VALUE;
    pub fn rb_time_succ(arg1: VALUE) -> VALUE;
    pub fn rb_frame_method_id_and_class(idp: *mut ID, klassp: *mut VALUE)
     -> ::std::os::raw::c_int;
    pub fn rb_make_backtrace() -> VALUE;
    pub fn rb_make_exception(arg1: ::std::os::raw::c_int, arg2: *mut VALUE)
     -> VALUE;
    pub fn rb_frame_pop();
    pub fn ruby_native_thread_p() -> ::std::os::raw::c_int;
    pub fn rb_add_event_hook(func: rb_event_hook_func_t,
                             events: rb_event_flag_t, data: VALUE);
    pub fn rb_remove_event_hook(func: rb_event_hook_func_t)
     -> ::std::os::raw::c_int;
    pub fn rb_isalnum(c: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
    pub fn rb_isalpha(c: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
    pub fn rb_isblank(c: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
    pub fn rb_iscntrl(c: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
    pub fn rb_isdigit(c: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
    pub fn rb_isgraph(c: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
    pub fn rb_islower(c: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
    pub fn rb_isprint(c: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
    pub fn rb_ispunct(c: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
    pub fn rb_isspace(c: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
    pub fn rb_isupper(c: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
    pub fn rb_isxdigit(c: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
    pub fn rb_tolower(c: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
    pub fn rb_toupper(c: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
    pub fn ruby_strtoul(str: *const ::std::os::raw::c_char,
                        endptr: *mut *mut ::std::os::raw::c_char,
                        base: ::std::os::raw::c_int)
     -> ::std::os::raw::c_ulong;
    pub fn ruby_snprintf(str: *mut ::std::os::raw::c_char, n: size_t,
                         fmt: *const ::std::os::raw::c_char, ...)
     -> ::std::os::raw::c_int;
    pub fn ruby_vsnprintf(str: *mut ::std::os::raw::c_char, n: size_t,
                          fmt: *const ::std::os::raw::c_char, ap: va_list)
     -> ::std::os::raw::c_int;
    pub fn ruby_sysinit(argc: *mut ::std::os::raw::c_int,
                        argv: *mut *mut *mut ::std::os::raw::c_char);
    pub fn ruby_init();
    pub fn ruby_options(argc: ::std::os::raw::c_int,
                        argv: *mut *mut ::std::os::raw::c_char)
     -> *mut ::std::os::raw::c_void;
    pub fn ruby_executable_node(n: *mut ::std::os::raw::c_void,
                                status: *mut ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
    pub fn ruby_run_node(n: *mut ::std::os::raw::c_void)
     -> ::std::os::raw::c_int;
    pub fn ruby_show_version();
    pub fn ruby_show_copyright();
    pub fn ruby_init_stack(arg1: *mut VALUE);
    pub fn ruby_setup() -> ::std::os::raw::c_int;
    pub fn ruby_cleanup(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
    pub fn ruby_finalize();
    pub fn ruby_stop(arg1: ::std::os::raw::c_int);
    pub fn ruby_set_stack_size(arg1: size_t);
    pub fn ruby_stack_check() -> ::std::os::raw::c_int;
    pub fn ruby_stack_length(arg1: *mut *mut VALUE) -> size_t;
    pub fn ruby_exec_node(n: *mut ::std::os::raw::c_void)
     -> ::std::os::raw::c_int;
    pub fn ruby_script(name: *const ::std::os::raw::c_char);
    pub fn ruby_set_script_name(name: VALUE);
    pub fn ruby_prog_init();
    pub fn ruby_set_argv(arg1: ::std::os::raw::c_int,
                         arg2: *mut *mut ::std::os::raw::c_char);
    pub fn ruby_process_options(arg1: ::std::os::raw::c_int,
                                arg2: *mut *mut ::std::os::raw::c_char)
     -> *mut ::std::os::raw::c_void;
    pub fn ruby_init_loadpath();
    pub fn ruby_incpush(arg1: *const ::std::os::raw::c_char);
    pub fn ruby_sig_finalize();
    pub fn rb_parser_new() -> VALUE;
    pub fn rb_parser_end_seen_p(arg1: VALUE) -> VALUE;
    pub fn rb_parser_encoding(arg1: VALUE) -> VALUE;
    pub fn rb_parser_get_yydebug(arg1: VALUE) -> VALUE;
    pub fn rb_parser_set_yydebug(arg1: VALUE, arg2: VALUE) -> VALUE;
    pub fn rb_parser_dump_tree(node: *mut NODE,
                               comment: ::std::os::raw::c_int) -> VALUE;
    pub fn rb_parser_append_print(arg1: VALUE, arg2: *mut NODE) -> *mut NODE;
    pub fn rb_parser_while_loop(arg1: VALUE, arg2: *mut NODE,
                                arg3: ::std::os::raw::c_int,
                                arg4: ::std::os::raw::c_int) -> *mut NODE;
    pub fn rb_parser_compile_cstr(arg1: VALUE,
                                  arg2: *const ::std::os::raw::c_char,
                                  arg3: *const ::std::os::raw::c_char,
                                  arg4: ::std::os::raw::c_int,
                                  arg5: ::std::os::raw::c_int) -> *mut NODE;
    pub fn rb_parser_compile_string(arg1: VALUE,
                                    arg2: *const ::std::os::raw::c_char,
                                    arg3: VALUE, arg4: ::std::os::raw::c_int)
     -> *mut NODE;
    pub fn rb_parser_compile_file(arg1: VALUE,
                                  arg2: *const ::std::os::raw::c_char,
                                  arg3: VALUE, arg4: ::std::os::raw::c_int)
     -> *mut NODE;
    pub fn rb_parser_compile_string_path(vparser: VALUE, fname: VALUE,
                                         src: VALUE,
                                         line: ::std::os::raw::c_int)
     -> *mut NODE;
    pub fn rb_parser_compile_file_path(vparser: VALUE, fname: VALUE,
                                       input: VALUE,
                                       line: ::std::os::raw::c_int)
     -> *mut NODE;
    pub fn rb_compile_cstr(arg1: *const ::std::os::raw::c_char,
                           arg2: *const ::std::os::raw::c_char,
                           arg3: ::std::os::raw::c_int,
                           arg4: ::std::os::raw::c_int) -> *mut NODE;
    pub fn rb_compile_string(arg1: *const ::std::os::raw::c_char, arg2: VALUE,
                             arg3: ::std::os::raw::c_int) -> *mut NODE;
    pub fn rb_compile_file(arg1: *const ::std::os::raw::c_char, arg2: VALUE,
                           arg3: ::std::os::raw::c_int) -> *mut NODE;
    pub fn rb_node_newnode(arg1: Enum_node_type, arg2: VALUE, arg3: VALUE,
                           arg4: VALUE) -> *mut NODE;
    pub fn rb_node_newnode_longlife(arg1: Enum_node_type, arg2: VALUE,
                                    arg3: VALUE, arg4: VALUE) -> *mut NODE;
    pub fn rb_global_entry(arg1: ID) -> *mut Struct_rb_global_entry;
    pub fn rb_gvar_get(arg1: *mut Struct_rb_global_entry) -> VALUE;
    pub fn rb_gvar_set(arg1: *mut Struct_rb_global_entry, arg2: VALUE)
     -> VALUE;
    pub fn rb_gvar_defined(arg1: *mut Struct_rb_global_entry) -> VALUE;
    pub fn rb_reserved_word(arg1: *const ::std::os::raw::c_char,
                            arg2: ::std::os::raw::c_uint)
     -> *const Struct_kwtable;
    pub fn rb_parser_malloc(arg1: *mut Struct_parser_params, arg2: size_t)
     -> *mut ::std::os::raw::c_void;
    pub fn rb_parser_realloc(arg1: *mut Struct_parser_params,
                             arg2: *mut ::std::os::raw::c_void, arg3: size_t)
     -> *mut ::std::os::raw::c_void;
    pub fn rb_parser_calloc(arg1: *mut Struct_parser_params, arg2: size_t,
                            arg3: size_t) -> *mut ::std::os::raw::c_void;
    pub fn rb_parser_free(arg1: *mut Struct_parser_params,
                          arg2: *mut ::std::os::raw::c_void);
    pub fn ruby_debug_print_value(level: ::std::os::raw::c_int,
                                  debug_level: ::std::os::raw::c_int,
                                  header: *const ::std::os::raw::c_char,
                                  v: VALUE) -> VALUE;
    pub fn ruby_debug_print_id(level: ::std::os::raw::c_int,
                               debug_level: ::std::os::raw::c_int,
                               header: *const ::std::os::raw::c_char, id: ID)
     -> ID;
    pub fn ruby_debug_print_node(level: ::std::os::raw::c_int,
                                 debug_level: ::std::os::raw::c_int,
                                 header: *const ::std::os::raw::c_char,
                                 node: *const NODE) -> *mut NODE;
    pub fn ruby_debug_print_indent(level: ::std::os::raw::c_int,
                                   debug_level: ::std::os::raw::c_int,
                                   indent_level: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
    pub fn ruby_debug_breakpoint();
    pub fn ruby_debug_gc_check_func();
    pub fn ruby_set_debug_option(str: *const ::std::os::raw::c_char);
    pub fn rb_class_subclass_add(_super: VALUE, klass: VALUE);
    pub fn rb_class_remove_from_super_subclasses(arg1: VALUE);
    pub fn rb_ary_last(arg1: ::std::os::raw::c_int, arg2: *mut VALUE,
                       arg3: VALUE) -> VALUE;
    pub fn rb_ary_set_len(arg1: VALUE, arg2: ::std::os::raw::c_long);
    pub fn rb_ary_delete_same(arg1: VALUE, arg2: VALUE);
    pub fn rb_big_fdiv(x: VALUE, y: VALUE) -> VALUE;
    pub fn rb_big_uminus(x: VALUE) -> VALUE;
    pub fn rb_integer_float_cmp(x: VALUE, y: VALUE) -> VALUE;
    pub fn rb_integer_float_eq(x: VALUE, y: VALUE) -> VALUE;
    pub fn rb_class_foreach_subclass(klass: VALUE,
                                     f:
                                         ::std::option::Option<extern "C" fn(arg1:
                                                                                 VALUE)>);
    pub fn rb_class_detach_subclasses(arg1: VALUE);
    pub fn rb_class_detach_module_subclasses(arg1: VALUE);
    pub fn rb_class_remove_from_module_subclasses(arg1: VALUE);
    pub fn rb_obj_methods(argc: ::std::os::raw::c_int, argv: *mut VALUE,
                          obj: VALUE) -> VALUE;
    pub fn rb_obj_protected_methods(argc: ::std::os::raw::c_int,
                                    argv: *mut VALUE, obj: VALUE) -> VALUE;
    pub fn rb_obj_private_methods(argc: ::std::os::raw::c_int,
                                  argv: *mut VALUE, obj: VALUE) -> VALUE;
    pub fn rb_obj_public_methods(argc: ::std::os::raw::c_int,
                                 argv: *mut VALUE, obj: VALUE) -> VALUE;
    pub fn rb_obj_basic_to_s_p(arg1: VALUE) -> ::std::os::raw::c_int;
    pub fn rb_special_singleton_class(arg1: VALUE) -> VALUE;
    pub fn rb_singleton_class_clone_and_attach(obj: VALUE, attach: VALUE)
     -> VALUE;
    pub fn rb_singleton_class_get(obj: VALUE) -> VALUE;
    pub fn Init_class_hierarchy();
    pub fn rb_invcmp(arg1: VALUE, arg2: VALUE) -> VALUE;
    pub fn rb_dvar_defined(arg1: ID) -> ::std::os::raw::c_int;
    pub fn rb_local_defined(arg1: ID) -> ::std::os::raw::c_int;
    pub fn rb_parse_in_eval() -> ::std::os::raw::c_int;
    pub fn rb_parse_in_main() -> ::std::os::raw::c_int;
    pub fn rb_insns_name(i: ::std::os::raw::c_int)
     -> *const ::std::os::raw::c_char;
    pub fn rb_insns_name_array() -> VALUE;
    pub fn rb_obj_is_fiber(arg1: VALUE) -> VALUE;
    pub fn rb_fiber_reset_root_local_storage(arg1: VALUE);
    pub fn ruby_register_rollback_func_for_ensure(ensure_func:
                                                      ::std::option::Option<extern "C" fn()
                                                                                ->
                                                                                    VALUE>,
                                                  rollback_func:
                                                      ::std::option::Option<extern "C" fn()
                                                                                ->
                                                                                    VALUE>);
    pub fn ruby_debug_printf(arg1: *const ::std::os::raw::c_char, ...);
    pub fn Init_ext();
    pub fn rb_id_encoding() -> ID;
    pub fn rb_gc_mark_encodings();
    pub fn rb_compile_bug(arg1: *const ::std::os::raw::c_char,
                          arg2: ::std::os::raw::c_int,
                          arg3: *const ::std::os::raw::c_char, ...);
    pub fn rb_check_backtrace(arg1: VALUE) -> VALUE;
    pub fn rb_async_bug_errno(arg1: *const ::std::os::raw::c_char,
                              arg2: ::std::os::raw::c_int);
    pub fn rb_builtin_type_name(t: ::std::os::raw::c_int)
     -> *const ::std::os::raw::c_char;
    pub fn rb_builtin_class_name(x: VALUE) -> *const ::std::os::raw::c_char;
    pub fn rb_refinement_module_get_refined_class(module: VALUE) -> VALUE;
    pub fn ruby_error_print();
    pub fn rb_get_backtrace(info: VALUE) -> VALUE;
    pub fn rb_call_end_proc(data: VALUE);
    pub fn rb_mark_end_proc();
    pub fn rb_home_dir_of(user: VALUE, result: VALUE) -> VALUE;
    pub fn rb_default_home_dir(result: VALUE) -> VALUE;
    pub fn rb_realpath_internal(basedir: VALUE, path: VALUE,
                                strict: ::std::os::raw::c_int) -> VALUE;
    pub fn rb_file_const(arg1: *const ::std::os::raw::c_char, arg2: VALUE);
    pub fn rb_file_load_ok(arg1: *const ::std::os::raw::c_char)
     -> ::std::os::raw::c_int;
    pub fn rb_file_expand_path_fast(arg1: VALUE, arg2: VALUE) -> VALUE;
    pub fn rb_file_expand_path_internal(arg1: VALUE, arg2: VALUE,
                                        arg3: ::std::os::raw::c_int,
                                        arg4: ::std::os::raw::c_int,
                                        arg5: VALUE) -> VALUE;
    pub fn rb_get_path_check_to_string(arg1: VALUE,
                                       arg2: ::std::os::raw::c_int) -> VALUE;
    pub fn rb_get_path_check_convert(arg1: VALUE, arg2: VALUE,
                                     arg3: ::std::os::raw::c_int) -> VALUE;
    pub fn Init_File();
    pub fn rb_sys_fail_path_in(func_name: *const ::std::os::raw::c_char,
                               path: VALUE);
    pub fn rb_syserr_fail_path_in(func_name: *const ::std::os::raw::c_char,
                                  err: ::std::os::raw::c_int, path: VALUE);
    pub fn Init_heap();
    pub fn ruby_mimmalloc(size: size_t) -> *mut ::std::os::raw::c_void;
    pub fn ruby_mimfree(ptr: *mut ::std::os::raw::c_void);
    pub fn rb_objspace_set_event_hook(event: rb_event_flag_t);
    pub fn rb_gc_writebarrier_remember_promoted(obj: VALUE);
    pub fn ruby_gc_set_params(safe_level: ::std::os::raw::c_int);
    pub fn rb_gc_resurrect(ptr: VALUE);
    pub fn rb_hash_tbl_raw(hash: VALUE) -> *mut Struct_st_table;
    pub fn rb_hash_keys(hash: VALUE) -> VALUE;
    pub fn rb_hash_values(hash: VALUE) -> VALUE;
    pub fn rb_call_inits();
    pub fn ruby_get_inplace_mode() -> *const ::std::os::raw::c_char;
    pub fn ruby_set_inplace_mode(arg1: *const ::std::os::raw::c_char);
    pub fn rb_io_bufread(io: VALUE, buf: *mut ::std::os::raw::c_void,
                         size: size_t) -> ssize_t;
    pub fn rb_stdio_set_default_encoding();
    pub fn rb_write_error_str(mesg: VALUE);
    pub fn rb_io_flush_raw(arg1: VALUE, arg2: ::std::os::raw::c_int) -> VALUE;
    pub fn rb_iseq_clone(iseqval: VALUE, newcbase: VALUE) -> VALUE;
    pub fn rb_iseq_path(iseqval: VALUE) -> VALUE;
    pub fn rb_iseq_absolute_path(iseqval: VALUE) -> VALUE;
    pub fn rb_iseq_label(iseqval: VALUE) -> VALUE;
    pub fn rb_iseq_base_label(iseqval: VALUE) -> VALUE;
    pub fn rb_iseq_first_lineno(iseqval: VALUE) -> VALUE;
    pub fn rb_iseq_klass(iseqval: VALUE) -> VALUE;
    pub fn rb_iseq_method_name(_self: VALUE) -> VALUE;
    pub fn rb_get_load_path() -> VALUE;
    pub fn rb_get_expanded_load_path() -> VALUE;
    pub fn rb_load_fail(arg1: VALUE, arg2: *const ::std::os::raw::c_char);
    pub fn rb_math_atan2(arg1: VALUE, arg2: VALUE) -> VALUE;
    pub fn rb_math_cos(arg1: VALUE) -> VALUE;
    pub fn rb_math_cosh(arg1: VALUE) -> VALUE;
    pub fn rb_math_exp(arg1: VALUE) -> VALUE;
    pub fn rb_math_hypot(arg1: VALUE, arg2: VALUE) -> VALUE;
    pub fn rb_math_log(argc: ::std::os::raw::c_int, argv: *mut VALUE)
     -> VALUE;
    pub fn rb_math_sin(arg1: VALUE) -> VALUE;
    pub fn rb_math_sinh(arg1: VALUE) -> VALUE;
    pub fn rb_math_sqrt(arg1: VALUE) -> VALUE;
    pub fn Init_newline();
    pub fn rb_num_to_uint(val: VALUE, ret: *mut ::std::os::raw::c_uint)
     -> ::std::os::raw::c_int;
    pub fn ruby_num_interval_step_size(from: VALUE, to: VALUE, step: VALUE,
                                       excl: ::std::os::raw::c_int) -> VALUE;
    pub fn ruby_float_step(from: VALUE, to: VALUE, step: VALUE,
                           excl: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
    pub fn ruby_float_mod(x: ::std::os::raw::c_double,
                          y: ::std::os::raw::c_double)
     -> ::std::os::raw::c_double;
    pub fn rb_num_negative_p(arg1: VALUE) -> ::std::os::raw::c_int;
    pub fn rb_int_succ(num: VALUE) -> VALUE;
    pub fn rb_int_pred(num: VALUE) -> VALUE;
    pub fn rb_dbl_hash(d: ::std::os::raw::c_double) -> VALUE;
    pub fn rb_obj_copy_ivar(dest: VALUE, obj: VALUE);
    pub fn rb_obj_equal(obj1: VALUE, obj2: VALUE) -> VALUE;
    pub fn rb_class_search_ancestor(klass: VALUE, _super: VALUE) -> VALUE;
    pub fn rb_undefined_alloc(klass: VALUE);
    pub fn rb_is_const_name(name: VALUE) -> ::std::os::raw::c_int;
    pub fn rb_is_class_name(name: VALUE) -> ::std::os::raw::c_int;
    pub fn rb_is_global_name(name: VALUE) -> ::std::os::raw::c_int;
    pub fn rb_is_instance_name(name: VALUE) -> ::std::os::raw::c_int;
    pub fn rb_is_attrset_name(name: VALUE) -> ::std::os::raw::c_int;
    pub fn rb_is_local_name(name: VALUE) -> ::std::os::raw::c_int;
    pub fn rb_is_method_name(name: VALUE) -> ::std::os::raw::c_int;
    pub fn rb_is_junk_name(name: VALUE) -> ::std::os::raw::c_int;
    pub fn rb_gc_mark_parser();
    pub fn rb_gc_mark_symbols(full_mark: ::std::os::raw::c_int);
    pub fn rb_proc_location(_self: VALUE) -> VALUE;
    pub fn rb_hash_proc(hash: st_index_t, _proc: VALUE) -> st_index_t;
    pub fn rb_block_arity() -> ::std::os::raw::c_int;
    pub fn rb_block_clear_env_self(_proc: VALUE) -> VALUE;
    pub fn rb_fork_ruby(status: *mut ::std::os::raw::c_int) -> pid_t;
    pub fn rb_last_status_clear();
    pub fn rb_lcm(x: VALUE, y: VALUE) -> VALUE;
    pub fn rb_rational_reciprocal(x: VALUE) -> VALUE;
    pub fn rb_reg_compile(str: VALUE, options: ::std::os::raw::c_int,
                          sourcefile: *const ::std::os::raw::c_char,
                          sourceline: ::std::os::raw::c_int) -> VALUE;
    pub fn rb_reg_check_preprocess(arg1: VALUE) -> VALUE;
    pub fn rb_get_next_signal() -> ::std::os::raw::c_int;
    pub fn rb_sigaltstack_size() -> ::std::os::raw::c_int;
    pub fn rb_fstring(arg1: VALUE) -> VALUE;
    pub fn rb_str_buf_cat_escaped_char(result: VALUE,
                                       c: ::std::os::raw::c_uint,
                                       unicode_p: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
    pub fn rb_str_symname_p(arg1: VALUE) -> ::std::os::raw::c_int;
    pub fn rb_str_quote_unprintable(arg1: VALUE) -> VALUE;
    pub fn rb_id_quote_unprintable(arg1: ID) -> VALUE;
    pub fn rb_str_fill_terminator(str: VALUE, termlen: ::std::os::raw::c_int);
    pub fn rb_str_locktmp_ensure(str: VALUE,
                                 func:
                                     ::std::option::Option<extern "C" fn(arg1:
                                                                             VALUE)
                                                               -> VALUE>,
                                 arg: VALUE) -> VALUE;
    pub fn rb_struct_init_copy(copy: VALUE, s: VALUE) -> VALUE;
    pub fn rb_obj_is_mutex(obj: VALUE) -> VALUE;
    pub fn rb_suppress_tracing(func:
                                   ::std::option::Option<extern "C" fn(arg1:
                                                                           VALUE)
                                                             -> VALUE>,
                               arg: VALUE) -> VALUE;
    pub fn rb_thread_execute_interrupts(th: VALUE);
    pub fn rb_clear_trace_func();
    pub fn rb_get_coverages() -> VALUE;
    pub fn rb_thread_shield_new() -> VALUE;
    pub fn rb_thread_shield_wait(_self: VALUE) -> VALUE;
    pub fn rb_thread_shield_release(_self: VALUE) -> VALUE;
    pub fn rb_thread_shield_destroy(_self: VALUE) -> VALUE;
    pub fn rb_mutex_allow_trap(_self: VALUE, val: ::std::os::raw::c_int);
    pub fn rb_uninterruptible(b_proc:
                                  ::std::option::Option<extern "C" fn()
                                                            -> VALUE>,
                              data: VALUE) -> VALUE;
    pub fn rb_mutex_owned_p(_self: VALUE) -> VALUE;
    pub fn ruby_kill(pid: pid_t, sig: ::std::os::raw::c_int);
    pub fn Init_native_thread();
    pub fn rb_next_class_serial() -> rb_serial_t;
    pub fn rb_obj_is_thread(obj: VALUE) -> VALUE;
    pub fn rb_vm_mark(ptr: *mut ::std::os::raw::c_void);
    pub fn Init_BareVM();
    pub fn rb_vm_top_self() -> VALUE;
    pub fn rb_thread_recycle_stack_release(arg1: *mut VALUE);
    pub fn rb_vm_change_state();
    pub fn rb_vm_inc_const_missing_count();
    pub fn rb_thread_mark(th: *mut ::std::os::raw::c_void);
    pub fn rb_vm_get_insns_address_table()
     -> *mut *const ::std::os::raw::c_void;
    pub fn rb_sourcefilename() -> VALUE;
    pub fn rb_vm_pop_cfunc_frame();
    pub fn rb_vm_bugreport();
    pub fn rb_print_backtrace();
    pub fn Init_vm_eval();
    pub fn rb_current_realfilepath() -> VALUE;
    pub fn rb_check_block_call(arg1: VALUE, arg2: ID,
                               arg3: ::std::os::raw::c_int,
                               arg4: *const VALUE, arg5: rb_block_call_func_t,
                               arg6: VALUE) -> VALUE;
    pub fn rb_check_funcall_with_hook(recv: VALUE, mid: ID,
                                      argc: ::std::os::raw::c_int,
                                      argv: *const VALUE,
                                      hook:
                                          *mut ::std::option::Option<extern "C" fn()>,
                                      arg: VALUE) -> VALUE;
    pub fn rb_catch_protect(t: VALUE,
                            func:
                                *mut ::std::option::Option<extern "C" fn()
                                                               -> VALUE>,
                            data: VALUE, stateptr: *mut ::std::os::raw::c_int)
     -> VALUE;
    pub fn rb_equal_opt(obj1: VALUE, obj2: VALUE) -> VALUE;
    pub fn rb_get_kwargs(keyword_hash: VALUE, table: *const ID,
                         required: ::std::os::raw::c_int,
                         optional: ::std::os::raw::c_int, arg1: *mut VALUE)
     -> ::std::os::raw::c_int;
    pub fn rb_extract_keywords(orighash: *mut VALUE) -> VALUE;
    pub fn Init_eval_method();
    pub fn rb_method_defined_by(obj: VALUE, mid: ID,
                                cfunc:
                                    ::std::option::Option<extern "C" fn()
                                                              -> VALUE>)
     -> ::std::os::raw::c_int;
    pub fn Init_prelude();
    pub fn Init_vm_backtrace();
    pub fn rb_vm_thread_backtrace(argc: ::std::os::raw::c_int,
                                  argv: *mut VALUE, thval: VALUE) -> VALUE;
    pub fn rb_vm_thread_backtrace_locations(argc: ::std::os::raw::c_int,
                                            argv: *mut VALUE, thval: VALUE)
     -> VALUE;
    pub fn rb_backtrace_print_as_bugreport();
    pub fn rb_backtrace_p(obj: VALUE) -> ::std::os::raw::c_int;
    pub fn rb_backtrace_to_str_ary(obj: VALUE) -> VALUE;
    pub fn rb_backtrace_to_location_ary(obj: VALUE) -> VALUE;
    pub fn rb_backtrace_print_to(output: VALUE);
    pub fn rb_vm_backtrace_object() -> VALUE;
    pub fn rb_objspace_data_type_name(obj: VALUE)
     -> *const ::std::os::raw::c_char;
    pub fn rb_thread_io_blocking_region(func:
                                            *mut ::std::option::Option<extern "C" fn()
                                                                           ->
                                                                               VALUE>,
                                        data1: *mut ::std::os::raw::c_void,
                                        fd: ::std::os::raw::c_int) -> VALUE;
    pub fn rb_big_mul_normal(x: VALUE, y: VALUE) -> VALUE;
    pub fn rb_big_mul_balance(x: VALUE, y: VALUE) -> VALUE;
    pub fn rb_big_mul_karatsuba(x: VALUE, y: VALUE) -> VALUE;
    pub fn rb_big_mul_toom3(x: VALUE, y: VALUE) -> VALUE;
    pub fn rb_big_sq_fast(x: VALUE) -> VALUE;
    pub fn rb_big_divrem_normal(x: VALUE, y: VALUE) -> VALUE;
    pub fn rb_big2str_poweroftwo(x: VALUE, base: ::std::os::raw::c_int)
     -> VALUE;
    pub fn rb_big2str_generic(x: VALUE, base: ::std::os::raw::c_int) -> VALUE;
    pub fn rb_str2big_poweroftwo(arg: VALUE, base: ::std::os::raw::c_int,
                                 badcheck: ::std::os::raw::c_int) -> VALUE;
    pub fn rb_str2big_normal(arg: VALUE, base: ::std::os::raw::c_int,
                             badcheck: ::std::os::raw::c_int) -> VALUE;
    pub fn rb_str2big_karatsuba(arg: VALUE, base: ::std::os::raw::c_int,
                                badcheck: ::std::os::raw::c_int) -> VALUE;
    pub fn rb_big_mul_gmp(x: VALUE, y: VALUE) -> VALUE;
    pub fn rb_big_divrem_gmp(x: VALUE, y: VALUE) -> VALUE;
    pub fn rb_big2str_gmp(x: VALUE, base: ::std::os::raw::c_int) -> VALUE;
    pub fn rb_str2big_gmp(arg: VALUE, base: ::std::os::raw::c_int,
                          badcheck: ::std::os::raw::c_int) -> VALUE;
    pub fn rb_bug_reporter_add(func:
                                   ::std::option::Option<unsafe extern "C" fn(arg1:
                                                                                  *mut FILE,
                                                                              arg2:
                                                                                  *mut ::std::os::raw::c_void)>,
                               data: *mut ::std::os::raw::c_void)
     -> ::std::os::raw::c_int;
    pub fn rb_maygvl_fd_fix_cloexec(fd: ::std::os::raw::c_int);
    pub fn rb_int_positive_pow(x: ::std::os::raw::c_long,
                               y: ::std::os::raw::c_ulong) -> VALUE;
    pub fn rb_exec_async_signal_safe(e: *const Struct_rb_execarg,
                                     errmsg: *mut ::std::os::raw::c_char,
                                     errmsg_buflen: size_t)
     -> ::std::os::raw::c_int;
    pub fn rb_fork_async_signal_safe(status: *mut ::std::os::raw::c_int,
                                     chfunc:
                                         ::std::option::Option<unsafe extern "C" fn(arg1:
                                                                                        *mut ::std::os::raw::c_void,
                                                                                    arg2:
                                                                                        *mut ::std::os::raw::c_char,
                                                                                    arg3:
                                                                                        size_t)
                                                                   ->
                                                                       ::std::os::raw::c_int>,
                                     charg: *mut ::std::os::raw::c_void,
                                     fds: VALUE,
                                     errmsg: *mut ::std::os::raw::c_char,
                                     errmsg_buflen: size_t) -> pid_t;
    pub fn rb_execarg_new(argc: ::std::os::raw::c_int, argv: *mut VALUE,
                          accept_shell: ::std::os::raw::c_int) -> VALUE;
    pub fn rb_execarg_get(execarg_obj: VALUE) -> *mut Struct_rb_execarg;
    pub fn rb_execarg_init(argc: ::std::os::raw::c_int, argv: *mut VALUE,
                           accept_shell: ::std::os::raw::c_int,
                           execarg_obj: VALUE) -> VALUE;
    pub fn rb_execarg_addopt(execarg_obj: VALUE, key: VALUE, val: VALUE)
     -> ::std::os::raw::c_int;
    pub fn rb_execarg_fixup(execarg_obj: VALUE);
    pub fn rb_execarg_run_options(e: *const Struct_rb_execarg,
                                  s: *mut Struct_rb_execarg,
                                  errmsg: *mut ::std::os::raw::c_char,
                                  errmsg_buflen: size_t)
     -> ::std::os::raw::c_int;
    pub fn rb_execarg_extract_options(execarg_obj: VALUE, opthash: VALUE)
     -> VALUE;
    pub fn rb_execarg_setenv(execarg_obj: VALUE, env: VALUE);
    pub fn rb_gcd_normal(_self: VALUE, other: VALUE) -> VALUE;
    pub fn rb_gcd_gmp(x: VALUE, y: VALUE) -> VALUE;
    pub fn ruby_scan_digits(str: *const ::std::os::raw::c_char, len: ssize_t,
                            base: ::std::os::raw::c_int, retlen: *mut size_t,
                            overflow: *mut ::std::os::raw::c_int)
     -> ::std::os::raw::c_ulong;
    pub fn rb_gc_mark_global_tbl();
    pub fn rb_mark_generic_ivar(arg1: VALUE);
    pub fn rb_mark_generic_ivar_tbl();
    pub fn rb_st_insert_id_and_value(obj: VALUE, tbl: *mut st_table, key: ID,
                                     value: VALUE) -> ::std::os::raw::c_int;
    pub fn rb_st_copy(obj: VALUE, orig_tbl: *mut Struct_st_table)
     -> *mut st_table;
    pub fn rb_obj_memsize_of(arg1: VALUE) -> size_t;
    pub fn rb_obj_gc_flags(arg1: VALUE, arg2: *mut ID, arg3: size_t)
     -> size_t;
    pub fn rb_add_method_cfunc(klass: VALUE, mid: ID,
                               func:
                                   ::std::option::Option<extern "C" fn()
                                                             -> VALUE>,
                               argc: ::std::os::raw::c_int,
                               noex: rb_method_flag_t);
    pub fn rb_add_method(klass: VALUE, mid: ID, _type: rb_method_type_t,
                         option: *mut ::std::os::raw::c_void,
                         noex: rb_method_flag_t) -> *mut rb_method_entry_t;
    pub fn rb_method_entry(klass: VALUE, id: ID, define_class_ptr: *mut VALUE)
     -> *mut rb_method_entry_t;
    pub fn rb_method_entry_at(obj: VALUE, id: ID) -> *mut rb_method_entry_t;
    pub fn rb_add_refined_method_entry(refined_class: VALUE, mid: ID);
    pub fn rb_resolve_refined_method(refinements: VALUE,
                                     me: *const rb_method_entry_t,
                                     defined_class_ptr: *mut VALUE)
     -> *mut rb_method_entry_t;
    pub fn rb_method_entry_with_refinements(klass: VALUE, id: ID,
                                            defined_class_ptr: *mut VALUE)
     -> *mut rb_method_entry_t;
    pub fn rb_method_entry_without_refinements(klass: VALUE, id: ID,
                                               defined_class_ptr: *mut VALUE)
     -> *mut rb_method_entry_t;
    pub fn rb_method_entry_get_without_cache(klass: VALUE, id: ID,
                                             define_class_ptr: *mut VALUE)
     -> *mut rb_method_entry_t;
    pub fn rb_method_entry_set(klass: VALUE, mid: ID,
                               arg1: *const rb_method_entry_t,
                               noex: rb_method_flag_t)
     -> *mut rb_method_entry_t;
    pub fn rb_method_entry_arity(me: *const rb_method_entry_t)
     -> ::std::os::raw::c_int;
    pub fn rb_method_entry_eq(m1: *const rb_method_entry_t,
                              m2: *const rb_method_entry_t)
     -> ::std::os::raw::c_int;
    pub fn rb_hash_method_entry(hash: st_index_t,
                                me: *const rb_method_entry_t) -> st_index_t;
    pub fn rb_method_entry_location(me: *mut rb_method_entry_t) -> VALUE;
    pub fn rb_mod_method_location(_mod: VALUE, id: ID) -> VALUE;
    pub fn rb_obj_method_location(obj: VALUE, id: ID) -> VALUE;
    pub fn rb_mark_method_entry(me: *const rb_method_entry_t);
    pub fn rb_free_method_entry(me: *mut rb_method_entry_t);
    pub fn rb_sweep_method_entry(vm: *mut ::std::os::raw::c_void);
    pub fn rb_free_m_tbl(tbl: *mut st_table);
    pub fn rb_free_m_tbl_wrapper(wrapper: *mut Struct_method_table_wrapper);
    pub fn clone(__fn:
                     ::std::option::Option<unsafe extern "C" fn(__arg:
                                                                    *mut ::std::os::raw::c_void)
                                               -> ::std::os::raw::c_int>,
                 __child_stack: *mut ::std::os::raw::c_void,
                 __flags: ::std::os::raw::c_int,
                 __arg: *mut ::std::os::raw::c_void, ...)
     -> ::std::os::raw::c_int;
    pub fn unshare(__flags: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
    pub fn sched_getcpu() -> ::std::os::raw::c_int;
    pub fn setns(__fd: ::std::os::raw::c_int, __nstype: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
    pub fn __sched_cpucount(__setsize: size_t, __setp: *const cpu_set_t)
     -> ::std::os::raw::c_int;
    pub fn __sched_cpualloc(__count: size_t) -> *mut cpu_set_t;
    pub fn __sched_cpufree(__set: *mut cpu_set_t);
    pub fn sched_setparam(__pid: __pid_t, __param: *const Struct_sched_param)
     -> ::std::os::raw::c_int;
    pub fn sched_getparam(__pid: __pid_t, __param: *mut Struct_sched_param)
     -> ::std::os::raw::c_int;
    pub fn sched_setscheduler(__pid: __pid_t, __policy: ::std::os::raw::c_int,
                              __param: *const Struct_sched_param)
     -> ::std::os::raw::c_int;
    pub fn sched_getscheduler(__pid: __pid_t) -> ::std::os::raw::c_int;
    pub fn sched_yield() -> ::std::os::raw::c_int;
    pub fn sched_get_priority_max(__algorithm: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
    pub fn sched_get_priority_min(__algorithm: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
    pub fn sched_rr_get_interval(__pid: __pid_t, __t: *mut Struct_timespec)
     -> ::std::os::raw::c_int;
    pub fn sched_setaffinity(__pid: __pid_t, __cpusetsize: size_t,
                             __cpuset: *const cpu_set_t)
     -> ::std::os::raw::c_int;
    pub fn sched_getaffinity(__pid: __pid_t, __cpusetsize: size_t,
                             __cpuset: *mut cpu_set_t)
     -> ::std::os::raw::c_int;
    pub fn clock_adjtime(__clock_id: __clockid_t, __utx: *mut Struct_timex)
     -> ::std::os::raw::c_int;
    pub fn clock() -> clock_t;
    pub fn time(__timer: *mut time_t) -> time_t;
    pub fn difftime(__time1: time_t, __time0: time_t)
     -> ::std::os::raw::c_double;
    pub fn mktime(__tp: *mut Struct_tm) -> time_t;
    pub fn strftime(__s: *mut ::std::os::raw::c_char, __maxsize: size_t,
                    __format: *const ::std::os::raw::c_char,
                    __tp: *const Struct_tm) -> size_t;
    pub fn strptime(__s: *const ::std::os::raw::c_char,
                    __fmt: *const ::std::os::raw::c_char,
                    __tp: *mut Struct_tm) -> *mut ::std::os::raw::c_char;
    pub fn strftime_l(__s: *mut ::std::os::raw::c_char, __maxsize: size_t,
                      __format: *const ::std::os::raw::c_char,
                      __tp: *const Struct_tm, __loc: __locale_t) -> size_t;
    pub fn strptime_l(__s: *const ::std::os::raw::c_char,
                      __fmt: *const ::std::os::raw::c_char,
                      __tp: *mut Struct_tm, __loc: __locale_t)
     -> *mut ::std::os::raw::c_char;
    pub fn gmtime(__timer: *const time_t) -> *mut Struct_tm;
    pub fn localtime(__timer: *const time_t) -> *mut Struct_tm;
    pub fn gmtime_r(__timer: *const time_t, __tp: *mut Struct_tm)
     -> *mut Struct_tm;
    pub fn localtime_r(__timer: *const time_t, __tp: *mut Struct_tm)
     -> *mut Struct_tm;
    pub fn asctime(__tp: *const Struct_tm) -> *mut ::std::os::raw::c_char;
    pub fn ctime(__timer: *const time_t) -> *mut ::std::os::raw::c_char;
    pub fn asctime_r(__tp: *const Struct_tm,
                     __buf: *mut ::std::os::raw::c_char)
     -> *mut ::std::os::raw::c_char;
    pub fn ctime_r(__timer: *const time_t, __buf: *mut ::std::os::raw::c_char)
     -> *mut ::std::os::raw::c_char;
    pub fn tzset();
    pub fn stime(__when: *const time_t) -> ::std::os::raw::c_int;
    pub fn timegm(__tp: *mut Struct_tm) -> time_t;
    pub fn timelocal(__tp: *mut Struct_tm) -> time_t;
    pub fn dysize(__year: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
    pub fn nanosleep(__requested_time: *const Struct_timespec,
                     __remaining: *mut Struct_timespec)
     -> ::std::os::raw::c_int;
    pub fn clock_getres(__clock_id: clockid_t, __res: *mut Struct_timespec)
     -> ::std::os::raw::c_int;
    pub fn clock_gettime(__clock_id: clockid_t, __tp: *mut Struct_timespec)
     -> ::std::os::raw::c_int;
    pub fn clock_settime(__clock_id: clockid_t, __tp: *const Struct_timespec)
     -> ::std::os::raw::c_int;
    pub fn clock_nanosleep(__clock_id: clockid_t,
                           __flags: ::std::os::raw::c_int,
                           __req: *const Struct_timespec,
                           __rem: *mut Struct_timespec)
     -> ::std::os::raw::c_int;
    pub fn clock_getcpuclockid(__pid: pid_t, __clock_id: *mut clockid_t)
     -> ::std::os::raw::c_int;
    pub fn timer_create(__clock_id: clockid_t, __evp: *mut Struct_sigevent,
                        __timerid: *mut timer_t) -> ::std::os::raw::c_int;
    pub fn timer_delete(__timerid: timer_t) -> ::std::os::raw::c_int;
    pub fn timer_settime(__timerid: timer_t, __flags: ::std::os::raw::c_int,
                         __value: *const Struct_itimerspec,
                         __ovalue: *mut Struct_itimerspec)
     -> ::std::os::raw::c_int;
    pub fn timer_gettime(__timerid: timer_t, __value: *mut Struct_itimerspec)
     -> ::std::os::raw::c_int;
    pub fn timer_getoverrun(__timerid: timer_t) -> ::std::os::raw::c_int;
    pub fn getdate(__string: *const ::std::os::raw::c_char) -> *mut Struct_tm;
    pub fn getdate_r(__string: *const ::std::os::raw::c_char,
                     __resbufp: *mut Struct_tm) -> ::std::os::raw::c_int;
    pub fn pthread_create(__newthread: *mut pthread_t,
                          __attr: *const pthread_attr_t,
                          __start_routine:
                              ::std::option::Option<unsafe extern "C" fn(arg1:
                                                                             *mut ::std::os::raw::c_void)
                                                        ->
                                                            *mut ::std::os::raw::c_void>,
                          __arg: *mut ::std::os::raw::c_void)
     -> ::std::os::raw::c_int;
    pub fn pthread_exit(__retval: *mut ::std::os::raw::c_void);
    pub fn pthread_join(__th: pthread_t,
                        __thread_return: *mut *mut ::std::os::raw::c_void)
     -> ::std::os::raw::c_int;
    pub fn pthread_tryjoin_np(__th: pthread_t,
                              __thread_return:
                                  *mut *mut ::std::os::raw::c_void)
     -> ::std::os::raw::c_int;
    pub fn pthread_timedjoin_np(__th: pthread_t,
                                __thread_return:
                                    *mut *mut ::std::os::raw::c_void,
                                __abstime: *const Struct_timespec)
     -> ::std::os::raw::c_int;
    pub fn pthread_detach(__th: pthread_t) -> ::std::os::raw::c_int;
    pub fn pthread_self() -> pthread_t;
    pub fn pthread_equal(__thread1: pthread_t, __thread2: pthread_t)
     -> ::std::os::raw::c_int;
    pub fn pthread_attr_init(__attr: *mut pthread_attr_t)
     -> ::std::os::raw::c_int;
    pub fn pthread_attr_destroy(__attr: *mut pthread_attr_t)
     -> ::std::os::raw::c_int;
    pub fn pthread_attr_getdetachstate(__attr: *const pthread_attr_t,
                                       __detachstate:
                                           *mut ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
    pub fn pthread_attr_setdetachstate(__attr: *mut pthread_attr_t,
                                       __detachstate: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
    pub fn pthread_attr_getguardsize(__attr: *const pthread_attr_t,
                                     __guardsize: *mut size_t)
     -> ::std::os::raw::c_int;
    pub fn pthread_attr_setguardsize(__attr: *mut pthread_attr_t,
                                     __guardsize: size_t)
     -> ::std::os::raw::c_int;
    pub fn pthread_attr_getschedparam(__attr: *const pthread_attr_t,
                                      __param: *mut Struct_sched_param)
     -> ::std::os::raw::c_int;
    pub fn pthread_attr_setschedparam(__attr: *mut pthread_attr_t,
                                      __param: *const Struct_sched_param)
     -> ::std::os::raw::c_int;
    pub fn pthread_attr_getschedpolicy(__attr: *const pthread_attr_t,
                                       __policy: *mut ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
    pub fn pthread_attr_setschedpolicy(__attr: *mut pthread_attr_t,
                                       __policy: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
    pub fn pthread_attr_getinheritsched(__attr: *const pthread_attr_t,
                                        __inherit: *mut ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
    pub fn pthread_attr_setinheritsched(__attr: *mut pthread_attr_t,
                                        __inherit: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
    pub fn pthread_attr_getscope(__attr: *const pthread_attr_t,
                                 __scope: *mut ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
    pub fn pthread_attr_setscope(__attr: *mut pthread_attr_t,
                                 __scope: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
    pub fn pthread_attr_getstackaddr(__attr: *const pthread_attr_t,
                                     __stackaddr:
                                         *mut *mut ::std::os::raw::c_void)
     -> ::std::os::raw::c_int;
    pub fn pthread_attr_setstackaddr(__attr: *mut pthread_attr_t,
                                     __stackaddr: *mut ::std::os::raw::c_void)
     -> ::std::os::raw::c_int;
    pub fn pthread_attr_getstacksize(__attr: *const pthread_attr_t,
                                     __stacksize: *mut size_t)
     -> ::std::os::raw::c_int;
    pub fn pthread_attr_setstacksize(__attr: *mut pthread_attr_t,
                                     __stacksize: size_t)
     -> ::std::os::raw::c_int;
    pub fn pthread_attr_getstack(__attr: *const pthread_attr_t,
                                 __stackaddr:
                                     *mut *mut ::std::os::raw::c_void,
                                 __stacksize: *mut size_t)
     -> ::std::os::raw::c_int;
    pub fn pthread_attr_setstack(__attr: *mut pthread_attr_t,
                                 __stackaddr: *mut ::std::os::raw::c_void,
                                 __stacksize: size_t)
     -> ::std::os::raw::c_int;
    pub fn pthread_attr_setaffinity_np(__attr: *mut pthread_attr_t,
                                       __cpusetsize: size_t,
                                       __cpuset: *const cpu_set_t)
     -> ::std::os::raw::c_int;
    pub fn pthread_attr_getaffinity_np(__attr: *const pthread_attr_t,
                                       __cpusetsize: size_t,
                                       __cpuset: *mut cpu_set_t)
     -> ::std::os::raw::c_int;
    pub fn pthread_getattr_np(__th: pthread_t, __attr: *mut pthread_attr_t)
     -> ::std::os::raw::c_int;
    pub fn pthread_setschedparam(__target_thread: pthread_t,
                                 __policy: ::std::os::raw::c_int,
                                 __param: *const Struct_sched_param)
     -> ::std::os::raw::c_int;
    pub fn pthread_getschedparam(__target_thread: pthread_t,
                                 __policy: *mut ::std::os::raw::c_int,
                                 __param: *mut Struct_sched_param)
     -> ::std::os::raw::c_int;
    pub fn pthread_setschedprio(__target_thread: pthread_t,
                                __prio: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
    pub fn pthread_getname_np(__target_thread: pthread_t,
                              __buf: *mut ::std::os::raw::c_char,
                              __buflen: size_t) -> ::std::os::raw::c_int;
    pub fn pthread_setname_np(__target_thread: pthread_t,
                              __name: *const ::std::os::raw::c_char)
     -> ::std::os::raw::c_int;
    pub fn pthread_getconcurrency() -> ::std::os::raw::c_int;
    pub fn pthread_setconcurrency(__level: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
    pub fn pthread_yield() -> ::std::os::raw::c_int;
    pub fn pthread_setaffinity_np(__th: pthread_t, __cpusetsize: size_t,
                                  __cpuset: *const cpu_set_t)
     -> ::std::os::raw::c_int;
    pub fn pthread_getaffinity_np(__th: pthread_t, __cpusetsize: size_t,
                                  __cpuset: *mut cpu_set_t)
     -> ::std::os::raw::c_int;
    pub fn pthread_once(__once_control: *mut pthread_once_t,
                        __init_routine:
                            ::std::option::Option<extern "C" fn()>)
     -> ::std::os::raw::c_int;
    pub fn pthread_setcancelstate(__state: ::std::os::raw::c_int,
                                  __oldstate: *mut ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
    pub fn pthread_setcanceltype(__type: ::std::os::raw::c_int,
                                 __oldtype: *mut ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
    pub fn pthread_cancel(__th: pthread_t) -> ::std::os::raw::c_int;
    pub fn pthread_testcancel();
    pub fn __pthread_register_cancel(__buf: *mut __pthread_unwind_buf_t);
    pub fn __pthread_unregister_cancel(__buf: *mut __pthread_unwind_buf_t);
    pub fn __pthread_register_cancel_defer(__buf:
                                               *mut __pthread_unwind_buf_t);
    pub fn __pthread_unregister_cancel_restore(__buf:
                                                   *mut __pthread_unwind_buf_t);
    pub fn __pthread_unwind_next(__buf: *mut __pthread_unwind_buf_t);
    pub fn __sigsetjmp(__env: *mut Struct___jmp_buf_tag,
                       __savemask: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
    pub fn pthread_mutex_init(__mutex: *mut pthread_mutex_t,
                              __mutexattr: *const pthread_mutexattr_t)
     -> ::std::os::raw::c_int;
    pub fn pthread_mutex_destroy(__mutex: *mut pthread_mutex_t)
     -> ::std::os::raw::c_int;
    pub fn pthread_mutex_trylock(__mutex: *mut pthread_mutex_t)
     -> ::std::os::raw::c_int;
    pub fn pthread_mutex_lock(__mutex: *mut pthread_mutex_t)
     -> ::std::os::raw::c_int;
    pub fn pthread_mutex_timedlock(__mutex: *mut pthread_mutex_t,
                                   __abstime: *const Struct_timespec)
     -> ::std::os::raw::c_int;
    pub fn pthread_mutex_unlock(__mutex: *mut pthread_mutex_t)
     -> ::std::os::raw::c_int;
    pub fn pthread_mutex_getprioceiling(__mutex: *const pthread_mutex_t,
                                        __prioceiling:
                                            *mut ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
    pub fn pthread_mutex_setprioceiling(__mutex: *mut pthread_mutex_t,
                                        __prioceiling: ::std::os::raw::c_int,
                                        __old_ceiling:
                                            *mut ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
    pub fn pthread_mutex_consistent(__mutex: *mut pthread_mutex_t)
     -> ::std::os::raw::c_int;
    pub fn pthread_mutex_consistent_np(__mutex: *mut pthread_mutex_t)
     -> ::std::os::raw::c_int;
    pub fn pthread_mutexattr_init(__attr: *mut pthread_mutexattr_t)
     -> ::std::os::raw::c_int;
    pub fn pthread_mutexattr_destroy(__attr: *mut pthread_mutexattr_t)
     -> ::std::os::raw::c_int;
    pub fn pthread_mutexattr_getpshared(__attr: *const pthread_mutexattr_t,
                                        __pshared: *mut ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
    pub fn pthread_mutexattr_setpshared(__attr: *mut pthread_mutexattr_t,
                                        __pshared: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
    pub fn pthread_mutexattr_gettype(__attr: *const pthread_mutexattr_t,
                                     __kind: *mut ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
    pub fn pthread_mutexattr_settype(__attr: *mut pthread_mutexattr_t,
                                     __kind: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
    pub fn pthread_mutexattr_getprotocol(__attr: *const pthread_mutexattr_t,
                                         __protocol:
                                             *mut ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
    pub fn pthread_mutexattr_setprotocol(__attr: *mut pthread_mutexattr_t,
                                         __protocol: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
    pub fn pthread_mutexattr_getprioceiling(__attr:
                                                *const pthread_mutexattr_t,
                                            __prioceiling:
                                                *mut ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
    pub fn pthread_mutexattr_setprioceiling(__attr: *mut pthread_mutexattr_t,
                                            __prioceiling:
                                                ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
    pub fn pthread_mutexattr_getrobust(__attr: *const pthread_mutexattr_t,
                                       __robustness:
                                           *mut ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
    pub fn pthread_mutexattr_getrobust_np(__attr: *const pthread_mutexattr_t,
                                          __robustness:
                                              *mut ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
    pub fn pthread_mutexattr_setrobust(__attr: *mut pthread_mutexattr_t,
                                       __robustness: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
    pub fn pthread_mutexattr_setrobust_np(__attr: *mut pthread_mutexattr_t,
                                          __robustness: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
    pub fn pthread_rwlock_init(__rwlock: *mut pthread_rwlock_t,
                               __attr: *const pthread_rwlockattr_t)
     -> ::std::os::raw::c_int;
    pub fn pthread_rwlock_destroy(__rwlock: *mut pthread_rwlock_t)
     -> ::std::os::raw::c_int;
    pub fn pthread_rwlock_rdlock(__rwlock: *mut pthread_rwlock_t)
     -> ::std::os::raw::c_int;
    pub fn pthread_rwlock_tryrdlock(__rwlock: *mut pthread_rwlock_t)
     -> ::std::os::raw::c_int;
    pub fn pthread_rwlock_timedrdlock(__rwlock: *mut pthread_rwlock_t,
                                      __abstime: *const Struct_timespec)
     -> ::std::os::raw::c_int;
    pub fn pthread_rwlock_wrlock(__rwlock: *mut pthread_rwlock_t)
     -> ::std::os::raw::c_int;
    pub fn pthread_rwlock_trywrlock(__rwlock: *mut pthread_rwlock_t)
     -> ::std::os::raw::c_int;
    pub fn pthread_rwlock_timedwrlock(__rwlock: *mut pthread_rwlock_t,
                                      __abstime: *const Struct_timespec)
     -> ::std::os::raw::c_int;
    pub fn pthread_rwlock_unlock(__rwlock: *mut pthread_rwlock_t)
     -> ::std::os::raw::c_int;
    pub fn pthread_rwlockattr_init(__attr: *mut pthread_rwlockattr_t)
     -> ::std::os::raw::c_int;
    pub fn pthread_rwlockattr_destroy(__attr: *mut pthread_rwlockattr_t)
     -> ::std::os::raw::c_int;
    pub fn pthread_rwlockattr_getpshared(__attr: *const pthread_rwlockattr_t,
                                         __pshared:
                                             *mut ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
    pub fn pthread_rwlockattr_setpshared(__attr: *mut pthread_rwlockattr_t,
                                         __pshared: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
    pub fn pthread_rwlockattr_getkind_np(__attr: *const pthread_rwlockattr_t,
                                         __pref: *mut ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
    pub fn pthread_rwlockattr_setkind_np(__attr: *mut pthread_rwlockattr_t,
                                         __pref: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
    pub fn pthread_cond_init(__cond: *mut pthread_cond_t,
                             __cond_attr: *const pthread_condattr_t)
     -> ::std::os::raw::c_int;
    pub fn pthread_cond_destroy(__cond: *mut pthread_cond_t)
     -> ::std::os::raw::c_int;
    pub fn pthread_cond_signal(__cond: *mut pthread_cond_t)
     -> ::std::os::raw::c_int;
    pub fn pthread_cond_broadcast(__cond: *mut pthread_cond_t)
     -> ::std::os::raw::c_int;
    pub fn pthread_cond_wait(__cond: *mut pthread_cond_t,
                             __mutex: *mut pthread_mutex_t)
     -> ::std::os::raw::c_int;
    pub fn pthread_cond_timedwait(__cond: *mut pthread_cond_t,
                                  __mutex: *mut pthread_mutex_t,
                                  __abstime: *const Struct_timespec)
     -> ::std::os::raw::c_int;
    pub fn pthread_condattr_init(__attr: *mut pthread_condattr_t)
     -> ::std::os::raw::c_int;
    pub fn pthread_condattr_destroy(__attr: *mut pthread_condattr_t)
     -> ::std::os::raw::c_int;
    pub fn pthread_condattr_getpshared(__attr: *const pthread_condattr_t,
                                       __pshared: *mut ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
    pub fn pthread_condattr_setpshared(__attr: *mut pthread_condattr_t,
                                       __pshared: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
    pub fn pthread_condattr_getclock(__attr: *const pthread_condattr_t,
                                     __clock_id: *mut __clockid_t)
     -> ::std::os::raw::c_int;
    pub fn pthread_condattr_setclock(__attr: *mut pthread_condattr_t,
                                     __clock_id: __clockid_t)
     -> ::std::os::raw::c_int;
    pub fn pthread_spin_init(__lock: *mut pthread_spinlock_t,
                             __pshared: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
    pub fn pthread_spin_destroy(__lock: *mut pthread_spinlock_t)
     -> ::std::os::raw::c_int;
    pub fn pthread_spin_lock(__lock: *mut pthread_spinlock_t)
     -> ::std::os::raw::c_int;
    pub fn pthread_spin_trylock(__lock: *mut pthread_spinlock_t)
     -> ::std::os::raw::c_int;
    pub fn pthread_spin_unlock(__lock: *mut pthread_spinlock_t)
     -> ::std::os::raw::c_int;
    pub fn pthread_barrier_init(__barrier: *mut pthread_barrier_t,
                                __attr: *const pthread_barrierattr_t,
                                __count: ::std::os::raw::c_uint)
     -> ::std::os::raw::c_int;
    pub fn pthread_barrier_destroy(__barrier: *mut pthread_barrier_t)
     -> ::std::os::raw::c_int;
    pub fn pthread_barrier_wait(__barrier: *mut pthread_barrier_t)
     -> ::std::os::raw::c_int;
    pub fn pthread_barrierattr_init(__attr: *mut pthread_barrierattr_t)
     -> ::std::os::raw::c_int;
    pub fn pthread_barrierattr_destroy(__attr: *mut pthread_barrierattr_t)
     -> ::std::os::raw::c_int;
    pub fn pthread_barrierattr_getpshared(__attr:
                                              *const pthread_barrierattr_t,
                                          __pshared:
                                              *mut ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
    pub fn pthread_barrierattr_setpshared(__attr: *mut pthread_barrierattr_t,
                                          __pshared: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
    pub fn pthread_key_create(__key: *mut pthread_key_t,
                              __destr_function:
                                  ::std::option::Option<unsafe extern "C" fn(arg1:
                                                                                 *mut ::std::os::raw::c_void)>)
     -> ::std::os::raw::c_int;
    pub fn pthread_key_delete(__key: pthread_key_t) -> ::std::os::raw::c_int;
    pub fn pthread_getspecific(__key: pthread_key_t)
     -> *mut ::std::os::raw::c_void;
    pub fn pthread_setspecific(__key: pthread_key_t,
                               __pointer: *const ::std::os::raw::c_void)
     -> ::std::os::raw::c_int;
    pub fn pthread_getcpuclockid(__thread_id: pthread_t,
                                 __clock_id: *mut __clockid_t)
     -> ::std::os::raw::c_int;
    pub fn pthread_atfork(__prepare: ::std::option::Option<extern "C" fn()>,
                          __parent: ::std::option::Option<extern "C" fn()>,
                          __child: ::std::option::Option<extern "C" fn()>)
     -> ::std::os::raw::c_int;
    pub fn sem_init(__sem: *mut sem_t, __pshared: ::std::os::raw::c_int,
                    __value: ::std::os::raw::c_uint) -> ::std::os::raw::c_int;
    pub fn sem_destroy(__sem: *mut sem_t) -> ::std::os::raw::c_int;
    pub fn sem_open(__name: *const ::std::os::raw::c_char,
                    __oflag: ::std::os::raw::c_int, ...) -> *mut sem_t;
    pub fn sem_close(__sem: *mut sem_t) -> ::std::os::raw::c_int;
    pub fn sem_unlink(__name: *const ::std::os::raw::c_char)
     -> ::std::os::raw::c_int;
    pub fn sem_wait(__sem: *mut sem_t) -> ::std::os::raw::c_int;
    pub fn sem_timedwait(__sem: *mut sem_t, __abstime: *const Struct_timespec)
     -> ::std::os::raw::c_int;
    pub fn sem_trywait(__sem: *mut sem_t) -> ::std::os::raw::c_int;
    pub fn sem_post(__sem: *mut sem_t) -> ::std::os::raw::c_int;
    pub fn sem_getvalue(__sem: *mut sem_t, __sval: *mut ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
    pub fn rb_nativethread_self() -> rb_nativethread_id_t;
    pub fn rb_nativethread_lock_initialize(lock: *mut rb_nativethread_lock_t);
    pub fn rb_nativethread_lock_destroy(lock: *mut rb_nativethread_lock_t);
    pub fn rb_nativethread_lock_lock(lock: *mut rb_nativethread_lock_t);
    pub fn rb_nativethread_lock_unlock(lock: *mut rb_nativethread_lock_t);
    pub fn setjmp(__env: jmp_buf) -> ::std::os::raw::c_int;
    pub fn _setjmp(__env: *mut Struct___jmp_buf_tag) -> ::std::os::raw::c_int;
    pub fn longjmp(__env: *mut Struct___jmp_buf_tag,
                   __val: ::std::os::raw::c_int);
    pub fn _longjmp(__env: *mut Struct___jmp_buf_tag,
                    __val: ::std::os::raw::c_int);
    pub fn siglongjmp(__env: sigjmp_buf, __val: ::std::os::raw::c_int);
    pub fn __sigismember(arg1: *const __sigset_t, arg2: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
    pub fn __sigaddset(arg1: *mut __sigset_t, arg2: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
    pub fn __sigdelset(arg1: *mut __sigset_t, arg2: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
    pub fn __sysv_signal(__sig: ::std::os::raw::c_int,
                         __handler: __sighandler_t) -> __sighandler_t;
    pub fn sysv_signal(__sig: ::std::os::raw::c_int,
                       __handler: __sighandler_t) -> __sighandler_t;
    pub fn signal(__sig: ::std::os::raw::c_int, __handler: __sighandler_t)
     -> __sighandler_t;
    pub fn bsd_signal(__sig: ::std::os::raw::c_int, __handler: __sighandler_t)
     -> __sighandler_t;
    pub fn kill(__pid: __pid_t, __sig: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
    pub fn killpg(__pgrp: __pid_t, __sig: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
    pub fn raise(__sig: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
    pub fn ssignal(__sig: ::std::os::raw::c_int, __handler: __sighandler_t)
     -> __sighandler_t;
    pub fn gsignal(__sig: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
    pub fn psignal(__sig: ::std::os::raw::c_int,
                   __s: *const ::std::os::raw::c_char);
    pub fn psiginfo(__pinfo: *const siginfo_t,
                    __s: *const ::std::os::raw::c_char);
    pub fn __sigpause(__sig_or_mask: ::std::os::raw::c_int,
                      __is_sig: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
    pub fn sigpause(__sig: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
    pub fn sigblock(__mask: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
    pub fn sigsetmask(__mask: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
    pub fn siggetmask() -> ::std::os::raw::c_int;
    pub fn sigemptyset(__set: *mut sigset_t) -> ::std::os::raw::c_int;
    pub fn sigfillset(__set: *mut sigset_t) -> ::std::os::raw::c_int;
    pub fn sigaddset(__set: *mut sigset_t, __signo: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
    pub fn sigdelset(__set: *mut sigset_t, __signo: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
    pub fn sigismember(__set: *const sigset_t, __signo: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
    pub fn sigisemptyset(__set: *const sigset_t) -> ::std::os::raw::c_int;
    pub fn sigandset(__set: *mut sigset_t, __left: *const sigset_t,
                     __right: *const sigset_t) -> ::std::os::raw::c_int;
    pub fn sigorset(__set: *mut sigset_t, __left: *const sigset_t,
                    __right: *const sigset_t) -> ::std::os::raw::c_int;
    pub fn sigprocmask(__how: ::std::os::raw::c_int, __set: *const sigset_t,
                       __oset: *mut sigset_t) -> ::std::os::raw::c_int;
    pub fn sigsuspend(__set: *const sigset_t) -> ::std::os::raw::c_int;
    pub fn sigaction(__sig: ::std::os::raw::c_int,
                     __act: *const Struct_sigaction,
                     __oact: *mut Struct_sigaction) -> ::std::os::raw::c_int;
    pub fn sigpending(__set: *mut sigset_t) -> ::std::os::raw::c_int;
    pub fn sigwait(__set: *const sigset_t, __sig: *mut ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
    pub fn sigwaitinfo(__set: *const sigset_t, __info: *mut siginfo_t)
     -> ::std::os::raw::c_int;
    pub fn sigtimedwait(__set: *const sigset_t, __info: *mut siginfo_t,
                        __timeout: *const Struct_timespec)
     -> ::std::os::raw::c_int;
    pub fn sigqueue(__pid: __pid_t, __sig: ::std::os::raw::c_int,
                    __val: Union_sigval) -> ::std::os::raw::c_int;
    pub fn sigvec(__sig: ::std::os::raw::c_int, __vec: *const Struct_sigvec,
                  __ovec: *mut Struct_sigvec) -> ::std::os::raw::c_int;
    pub fn sigreturn(__scp: *mut Struct_sigcontext) -> ::std::os::raw::c_int;
    pub fn siginterrupt(__sig: ::std::os::raw::c_int,
                        __interrupt: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
    pub fn sigstack(__ss: *mut Struct_sigstack, __oss: *mut Struct_sigstack)
     -> ::std::os::raw::c_int;
    pub fn sigaltstack(__ss: *const Struct_sigaltstack,
                       __oss: *mut Struct_sigaltstack)
     -> ::std::os::raw::c_int;
    pub fn sighold(__sig: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
    pub fn sigrelse(__sig: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
    pub fn sigignore(__sig: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
    pub fn sigset(__sig: ::std::os::raw::c_int, __disp: __sighandler_t)
     -> __sighandler_t;
    pub fn pthread_sigmask(__how: ::std::os::raw::c_int,
                           __newmask: *const __sigset_t,
                           __oldmask: *mut __sigset_t)
     -> ::std::os::raw::c_int;
    pub fn pthread_kill(__threadid: pthread_t, __signo: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
    pub fn pthread_sigqueue(__threadid: pthread_t,
                            __signo: ::std::os::raw::c_int,
                            __value: Union_sigval) -> ::std::os::raw::c_int;
    pub fn __libc_current_sigrtmin() -> ::std::os::raw::c_int;
    pub fn __libc_current_sigrtmax() -> ::std::os::raw::c_int;
    pub fn rb_objspace_free(arg1: *mut Struct_rb_objspace);
    pub fn rb_iseq_new(arg1: *mut NODE, arg2: VALUE, arg3: VALUE, arg4: VALUE,
                       arg5: VALUE, arg6: Enum_iseq_type) -> VALUE;
    pub fn rb_iseq_new_top(node: *mut NODE, name: VALUE, path: VALUE,
                           absolute_path: VALUE, parent: VALUE) -> VALUE;
    pub fn rb_iseq_new_main(node: *mut NODE, path: VALUE,
                            absolute_path: VALUE) -> VALUE;
    pub fn rb_iseq_new_with_bopt(arg1: *mut NODE, arg2: VALUE, arg3: VALUE,
                                 arg4: VALUE, arg5: VALUE, arg6: VALUE,
                                 arg7: Enum_iseq_type, arg8: VALUE) -> VALUE;
    pub fn rb_iseq_new_with_opt(arg1: *mut NODE, arg2: VALUE, arg3: VALUE,
                                arg4: VALUE, arg5: VALUE, arg6: VALUE,
                                arg7: Enum_iseq_type,
                                arg8: *const rb_compile_option_t) -> VALUE;
    pub fn rb_iseq_compile(src: VALUE, file: VALUE, line: VALUE) -> VALUE;
    pub fn rb_iseq_compile_on_base(src: VALUE, file: VALUE, line: VALUE,
                                   base_block: *mut rb_block_t) -> VALUE;
    pub fn rb_iseq_compile_with_option(src: VALUE, file: VALUE,
                                       absolute_path: VALUE, line: VALUE,
                                       base_block: *mut rb_block_t,
                                       opt: VALUE) -> VALUE;
    pub fn rb_iseq_disasm(_self: VALUE) -> VALUE;
    pub fn rb_iseq_disasm_insn(str: VALUE, iseqval: *mut VALUE, pos: size_t,
                               iseq: *mut rb_iseq_t, child: VALUE)
     -> ::std::os::raw::c_int;
    pub fn ruby_node_name(node: ::std::os::raw::c_int)
     -> *const ::std::os::raw::c_char;
    pub fn rb_vm_ep_local_ep(ep: *mut VALUE) -> *mut VALUE;
    pub fn rb_vm_control_frame_block_ptr(cfp: *mut rb_control_frame_t)
     -> *mut rb_block_t;
    pub fn rb_thread_alloc(klass: VALUE) -> VALUE;
    pub fn rb_proc_alloc(klass: VALUE) -> VALUE;
    pub fn rb_binding_alloc(klass: VALUE) -> VALUE;
    pub fn rb_vmdebug_stack_dump_raw(arg1: *mut rb_thread_t,
                                     arg2: *mut rb_control_frame_t);
    pub fn rb_vmdebug_debug_print_pre(th: *mut rb_thread_t,
                                      cfp: *mut rb_control_frame_t,
                                      _pc: *mut VALUE);
    pub fn rb_vmdebug_debug_print_post(th: *mut rb_thread_t,
                                       cfp: *mut rb_control_frame_t);
    pub fn rb_iseq_eval(iseqval: VALUE) -> VALUE;
    pub fn rb_iseq_eval_main(iseqval: VALUE) -> VALUE;
    pub fn rb_thread_method_id_and_class(th: *mut rb_thread_t, idp: *mut ID,
                                         klassp: *mut VALUE)
     -> ::std::os::raw::c_int;
    pub fn rb_vm_invoke_proc(th: *mut rb_thread_t, _proc: *mut rb_proc_t,
                             argc: ::std::os::raw::c_int, argv: *const VALUE,
                             blockptr: *const rb_block_t) -> VALUE;
    pub fn rb_vm_make_proc(th: *mut rb_thread_t, block: *const rb_block_t,
                           klass: VALUE) -> VALUE;
    pub fn rb_vm_make_binding(th: *mut rb_thread_t,
                              src_cfp: *const rb_control_frame_t) -> VALUE;
    pub fn rb_vm_make_env_object(th: *mut rb_thread_t,
                                 cfp: *mut rb_control_frame_t) -> VALUE;
    pub fn rb_binding_new_with_cfp(th: *mut rb_thread_t,
                                   src_cfp: *const rb_control_frame_t)
     -> VALUE;
    pub fn rb_binding_add_dynavars(bind: *mut rb_binding_t,
                                   dyncount: ::std::os::raw::c_int,
                                   dynvars: *const ID) -> *mut VALUE;
    pub fn rb_vm_gvl_destroy(vm: *mut rb_vm_t);
    pub fn rb_vm_call(th: *mut rb_thread_t, recv: VALUE, id: VALUE,
                      argc: ::std::os::raw::c_int, argv: *const VALUE,
                      me: *const rb_method_entry_t, defined_class: VALUE)
     -> VALUE;
    pub fn rb_unlink_method_entry(me: *mut rb_method_entry_t);
    pub fn rb_gc_mark_unlinked_live_method_entries(pvm:
                                                       *mut ::std::os::raw::c_void);
    pub fn rb_thread_start_timer_thread();
    pub fn rb_thread_stop_timer_thread(arg1: ::std::os::raw::c_int);
    pub fn rb_thread_reset_timer_thread();
    pub fn rb_thread_wakeup_timer_thread();
    pub fn ruby_thread_has_gvl_p() -> ::std::os::raw::c_int;
    pub fn rb_vm_get_ruby_level_next_cfp(th: *mut rb_thread_t,
                                         cfp: *const rb_control_frame_t)
     -> *mut rb_control_frame_t;
    pub fn rb_vm_get_binding_creatable_next_cfp(th: *mut rb_thread_t,
                                                cfp:
                                                    *const rb_control_frame_t)
     -> *mut rb_control_frame_t;
    pub fn rb_vm_get_sourceline(arg1: *const rb_control_frame_t)
     -> ::std::os::raw::c_int;
    pub fn rb_name_err_mesg_new(obj: VALUE, mesg: VALUE, recv: VALUE,
                                method: VALUE) -> VALUE;
    pub fn rb_vm_stack_to_heap(th: *mut rb_thread_t);
    pub fn ruby_thread_init_stack(th: *mut rb_thread_t);
    pub fn rb_vm_control_frame_id_and_class(cfp: *const rb_control_frame_t,
                                            idp: *mut ID, klassp: *mut VALUE)
     -> ::std::os::raw::c_int;
    pub fn rb_vm_rewind_cfp(th: *mut rb_thread_t,
                            cfp: *mut rb_control_frame_t);
    pub fn rb_gc_mark_machine_stack(th: *mut rb_thread_t);
    pub fn rb_autoloading_value(_mod: VALUE, id: ID, value: *mut VALUE)
     -> ::std::os::raw::c_int;
    pub fn rb_vm_rewrite_cref_stack(node: *mut NODE, old_klass: VALUE,
                                    new_klass: VALUE,
                                    new_cref_ptr: *mut *mut NODE);
    pub fn rb_signal_buff_size() -> ::std::os::raw::c_int;
    pub fn rb_signal_exec(th: *mut rb_thread_t, sig: ::std::os::raw::c_int);
    pub fn rb_threadptr_check_signal(mth: *mut rb_thread_t);
    pub fn rb_threadptr_signal_raise(th: *mut rb_thread_t,
                                     sig: ::std::os::raw::c_int);
    pub fn rb_threadptr_signal_exit(th: *mut rb_thread_t);
    pub fn rb_threadptr_execute_interrupts(arg1: *mut rb_thread_t,
                                           arg2: ::std::os::raw::c_int);
    pub fn rb_threadptr_interrupt(th: *mut rb_thread_t);
    pub fn rb_threadptr_unlock_all_locking_mutexes(th: *mut rb_thread_t);
    pub fn rb_threadptr_pending_interrupt_clear(th: *mut rb_thread_t);
    pub fn rb_threadptr_pending_interrupt_enque(th: *mut rb_thread_t,
                                                v: VALUE);
    pub fn rb_threadptr_pending_interrupt_active_p(th: *mut rb_thread_t)
     -> ::std::os::raw::c_int;
    pub fn rb_threadptr_exec_event_hooks(trace_arg:
                                             *mut Struct_rb_trace_arg_struct);
    pub fn rb_threadptr_exec_event_hooks_and_pop_frame(trace_arg:
                                                           *mut Struct_rb_trace_arg_struct);
    pub fn rb_threadptr_reset_recursive_data(th: *mut rb_thread_t) -> VALUE;
    pub fn rb_threadptr_restore_recursive_data(th: *mut rb_thread_t,
                                               old: VALUE);
    pub fn rb_thread_check_trap_pending() -> ::std::os::raw::c_int;
    pub fn rb_set_coverages(arg1: VALUE);
    pub fn rb_reset_coverages();
    pub fn rb_postponed_job_flush(vm: *mut rb_vm_t);
}
